<?xml version="1.0" encoding="UTF-8"?>
<codeintel description="HTML enhanced for web apps!" name="AngularJS-1.4.9" version="2.0">
  <file lang="JavaScript" path="AngularJS">
    <scope ilk="blob" lang="JavaScript" name="AngularJS-1.4.9">
      <scope ilk="namespace" name="angular">
        <scope doc="Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for&#xA;`fn`). You can supply optional `args` that are prebound to the function. This feature is also&#xA;known as [partial application](http://en.wikipedia.org/wiki/Partial_application), as&#xA;distinguished from [function currying](http://en.wikipedia.org/wiki/Currying#Contrast_with_partial_function_application).&#xA;" ilk="function" name="bind" returns="function()" signature="bind(self,args) =&gt; function()">
          <variable citdl="Object" doc="Context which `fn` should be evaluated in." ilk="argument" name="self" />
          <variable citdl="...*" doc="Optional arguments to be prebound to the `fn` function call." ilk="argument" name="args" />
        </scope>
        <scope doc="Use this function to manually start up angular application.&#xA;* See: {@link guide/bootstrap Bootstrap}&#xA;* Note that Protractor based end-to-end tests cannot use this function to bootstrap manually.&#xA;They must use {@link ng.directive:ngApp ngApp}.&#xA;* Angular will detect if it has been loaded into the browser more than once and only allow the&#xA;first loaded script to be bootstrapped and will report a warning to the browser console for&#xA;each of the subsequent scripts. This prevents strange results in applications, where otherwise&#xA;multiple instances of Angular try to work on the DOM.&#xA;* ```html&#xA;&lt;!doctype html&gt;&#xA;&lt;html&gt;&#xA;&lt;body&gt;&#xA;&lt;div ng-controller=&quot;WelcomeController&quot;&gt;&#xA;{{greeting}}&#xA;&lt;/div&gt;&#xA;* &lt;script src=&quot;angular.js&quot;&gt;&lt;/script&gt;&#xA;&lt;script&gt;&#xA;var app = angular.module(&apos;demo&apos;, [])&#xA;.controller(&apos;WelcomeController&apos;, function($scope) {&#xA;$scope.greeting = &apos;Welcome!&apos;;&#xA;});&#xA;angular.bootstrap(document, [&apos;demo&apos;]);&#xA;&lt;/script&gt;&#xA;&lt;/body&gt;&#xA;&lt;/html&gt;&#xA;```&#xA;" ilk="function" name="bootstrap" returns="auto.$injector" signature="bootstrap(element) =&gt; auto.$injector">
          <variable citdl="DOMElement" doc="DOM element which is the root of angular application." ilk="argument" name="element" />
        </scope>
        <scope doc="Creates a deep copy of `source`, which should be an object or an array.&#xA;* * If no destination is supplied, a copy of the object or array is created.&#xA;* If a destination is provided, all of its elements (for arrays) or properties (for objects)&#xA;are deleted and then all elements/properties from the source are copied to it.&#xA;* If `source` is not an object or array (inc. `null` and `undefined`), `source` is returned.&#xA;* If `source` is identical to &apos;destination&apos; an exception will be thrown.&#xA;" ilk="function" name="copy" returns="*" signature="copy() =&gt; *" />
        <scope doc="Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.&#xA;* If jQuery is available, `angular.element` is an alias for the&#xA;[jQuery](http://api.jquery.com/jQuery/) function. If jQuery is not available, `angular.element`&#xA;delegates to Angular&apos;s built-in subset of jQuery, called &quot;jQuery lite&quot; or **jqLite**.&#xA;* jqLite is a tiny, API-compatible subset of jQuery that allows&#xA;Angular to manipulate the DOM in a cross-browser compatible way. jqLite implements only the most&#xA;commonly needed functionality with the goal of having a very small footprint.&#xA;* To use `jQuery`, simply ensure it is loaded before the `angular.js` file. You can also use the&#xA;{@link ngJq `ngJq`} directive to specify that jqlite should be used over jQuery, or to use a&#xA;specific version of jQuery if multiple versions exist on the page.&#xA;* &lt;div class=&quot;alert alert-info&quot;&gt;**Note:** All element references in Angular are always wrapped with jQuery or&#xA;jqLite (such as the element argument in a directive&apos;s compile / link function). They are never raw DOM references.&lt;/div&gt;&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;**Note:** Keep in mind that this function will not find elements&#xA;by tag name / CSS selector. For lookups by tag name, try instead `angular.element(document).find(...)`&#xA;or `$document.find()`, or use the standard DOM APIs, e.g. `document.querySelectorAll()`.&lt;/div&gt;&#xA;* ## Angular&apos;s jqLite&#xA;jqLite provides only the following jQuery methods:&#xA;* - [`addClass()`](http://api.jquery.com/addClass/)&#xA;- [`after()`](http://api.jquery.com/after/)&#xA;- [`append()`](http://api.jquery.com/append/)&#xA;- [`attr()`](http://api.jquery.com/attr/) - Does not support functions as parameters&#xA;- [`bind()`](http://api.jquery.com/bind/) - Does not support namespaces, selectors or eventData&#xA;- [`children()`](http://api.jquery.com/children/) - Does not support selectors&#xA;- [`clone()`](http://api.jquery.com/clone/)&#xA;- [`contents()`](http://api.jquery.com/contents/)&#xA;- [`css()`](http://api.jquery.com/css/) - Only retrieves inline-styles, does not call `getComputedStyle()`.&#xA;As a setter, does not convert numbers to strings or append &apos;px&apos;, and also does not have automatic property prefixing.&#xA;- [`data()`](http://api.jquery.com/data/)&#xA;- [`detach()`](http://api.jquery.com/detach/)&#xA;- [`empty()`](http://api.jquery.com/empty/)&#xA;- [`eq()`](http://api.jquery.com/eq/)&#xA;- [`find()`](http://api.jquery.com/find/) - Limited to lookups by tag name&#xA;- [`hasClass()`](http://api.jquery.com/hasClass/)&#xA;- [`html()`](http://api.jquery.com/html/)&#xA;- [`next()`](http://api.jquery.com/next/) - Does not support selectors&#xA;- [`on()`](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData&#xA;- [`off()`](http://api.jquery.com/off/) - Does not support namespaces, selectors or event object as parameter&#xA;- [`one()`](http://api.jquery.com/one/) - Does not support namespaces or selectors&#xA;- [`parent()`](http://api.jquery.com/parent/) - Does not support selectors&#xA;- [`prepend()`](http://api.jquery.com/prepend/)&#xA;- [`prop()`](http://api.jquery.com/prop/)&#xA;- [`ready()`](http://api.jquery.com/ready/)&#xA;- [`remove()`](http://api.jquery.com/remove/)&#xA;- [`removeAttr()`](http://api.jquery.com/removeAttr/)&#xA;- [`removeClass()`](http://api.jquery.com/removeClass/)&#xA;- [`removeData()`](http://api.jquery.com/removeData/)&#xA;- [`replaceWith()`](http://api.jquery.com/replaceWith/)&#xA;- [`text()`](http://api.jquery.com/text/)&#xA;- [`toggleClass()`](http://api.jquery.com/toggleClass/)&#xA;- [`triggerHandler()`](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.&#xA;- [`unbind()`](http://api.jquery.com/unbind/) - Does not support namespaces or event object as parameter&#xA;- [`val()`](http://api.jquery.com/val/)&#xA;- [`wrap()`](http://api.jquery.com/wrap/)&#xA;* ## jQuery/jqLite Extras&#xA;Angular also provides the following additional methods and events to both jQuery and jqLite:&#xA;* ### Events&#xA;- `$destroy` - AngularJS intercepts all jqLite/jQuery&apos;s DOM destruction apis and fires this event&#xA;on all DOM nodes being removed.  This can be used to clean up any 3rd party bindings to the DOM&#xA;element before it is removed.&#xA;* ### Methods&#xA;- `controller(name)` - retrieves the controller of the current element or its parent. By default&#xA;retrieves controller associated with the `ngController` directive. If `name` is provided as&#xA;camelCase directive name, then the controller for this directive will be retrieved (e.g.&#xA;`&apos;ngModel&apos;`).&#xA;- `injector()` - retrieves the injector of the current element or its parent.&#xA;- `scope()` - retrieves the {@link ng.$rootScope.Scope scope} of the current&#xA;element or its parent. Requires {@link guide/production#disabling-debug-data Debug Data} to&#xA;be enabled.&#xA;- `isolateScope()` - retrieves an isolate {@link ng.$rootScope.Scope scope} if one is attached directly to the&#xA;current element. This getter should be used only on elements that contain a directive which starts a new isolate&#xA;scope. Calling `scope()` on this element always returns the original non-isolate scope.&#xA;Requires {@link guide/production#disabling-debug-data Debug Data} to be enabled.&#xA;- `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top&#xA;parent element is reached.&#xA;" ilk="function" name="element" returns="Object" signature="element(element) =&gt; Object">
          <variable citdl="string|DOMElement" doc="HTML string or DOMElement to be wrapped into jQuery." ilk="argument" name="element" />
        </scope>
        <scope doc="Determines if two objects or two values are equivalent. Supports value types, regular&#xA;expressions, arrays and objects.&#xA;* Two objects or values are considered equivalent if at least one of the following is true:&#xA;* * Both objects or values pass `===` comparison.&#xA;* Both objects or values are of the same type and all of their properties are equal by&#xA;comparing them with `angular.equals`.&#xA;* Both values are NaN. (In JavaScript, NaN == NaN =&gt; false. But we consider two NaN as equal)&#xA;* Both values represent the same regular expression (In JavaScript,&#xA;/abc/ == /abc/ =&gt; false. But we consider two regular expressions as equal when their textual&#xA;representation matches).&#xA;* During a property comparison, properties of `function` type and properties with names&#xA;that begin with `$` are ignored.&#xA;* Scope and DOMWindow objects are being compared only by identify (`===`).&#xA;" ilk="function" name="equals" returns="boolean" signature="equals(o1) =&gt; boolean">
          <variable citdl="*" doc="Object or value to compare." ilk="argument" name="o1" />
        </scope>
        <scope doc="Extends the destination object `dst` by copying own enumerable properties from the `src` object(s)&#xA;to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so&#xA;by passing an empty object as the target: `var object = angular.extend({}, object1, object2)`.&#xA;* **Note:** Keep in mind that `angular.extend` does not support recursive merge (deep copy). Use&#xA;{@link angular.merge} for this.&#xA;" ilk="function" name="extend" returns="Object" signature="extend(dst) =&gt; Object">
          <variable citdl="Object" doc="Destination object." ilk="argument" name="dst" />
        </scope>
        <scope doc="Invokes the `iterator` function once for each item in `obj` collection, which can be either an&#xA;object or an array. The `iterator` function is invoked with `iterator(value, key, obj)`, where `value`&#xA;is the value of an object property or an array element, `key` is the object property key or&#xA;array element index and obj is the `obj` itself. Specifying a `context` for the function is optional.&#xA;* It is worth noting that `.forEach` does not iterate over inherited properties because it filters&#xA;using the `hasOwnProperty` method.&#xA;* Unlike ES262&apos;s&#xA;[Array.prototype.forEach](http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.18),&#xA;Providing &apos;undefined&apos; or &apos;null&apos; values for `obj` will not throw a TypeError, but rather just&#xA;return the value provided.&#xA;```js&#xA;     var values = {name: &apos;misko&apos;, gender: &apos;male&apos;};&#xA;     var log = [];&#xA;     angular.forEach(values, function(value, key) {&#xA;       this.push(key + &apos;: &apos; + value);&#xA;     }, log);&#xA;     expect(log).toEqual([&apos;name: misko&apos;, &apos;gender: male&apos;]);&#xA;   ```&#xA;" ilk="function" name="forEach" returns="Object|Array" signature="forEach(obj,context) =&gt; Object|Array">
          <variable citdl="Object|Array" doc="Object to iterate over." ilk="argument" name="obj" />
          <variable citdl="Object=" doc="Object to become context (`this`) for the iterator function." ilk="argument" name="context" />
        </scope>
        <scope doc="Deserializes a JSON string.&#xA;" ilk="function" name="fromJson" returns="Object|Array|string|number" signature="fromJson(json) =&gt; Object|Array|string|number">
          <variable citdl="string" doc="JSON string to deserialize." ilk="argument" name="json" />
        </scope>
        <scope doc="A function that returns its first argument. This function is useful when writing code in the&#xA;functional style.&#xA;```js&#xA;     function transformer(transformationFn, value) {&#xA;       return (transformationFn || angular.identity)(value);&#xA;     };&#xA;   ```" ilk="function" name="identity" returns="*" signature="identity(value) =&gt; *">
          <variable citdl="*" doc="to be returned." ilk="argument" name="value" />
        </scope>
        <scope doc="Creates an injector object that can be used for retrieving services as well as for&#xA;dependency injection (see {@link guide/di dependency injection}).&#xA;" ilk="function" name="injector" returns="injector" signature="injector() =&gt; injector" />
        <scope doc="Determines if a reference is an `Array`.&#xA;" ilk="function" name="isArray" returns="boolean" signature="isArray(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a value is a date.&#xA;" ilk="function" name="isDate" returns="boolean" signature="isDate(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is defined.&#xA;" ilk="function" name="isDefined" returns="boolean" signature="isDefined(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is a DOM element (or wrapped jQuery element).&#xA;" ilk="function" name="isElement" returns="boolean" signature="isElement(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is a `Function`.&#xA;" ilk="function" name="isFunction" returns="boolean" signature="isFunction(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is a `Number`.&#xA;* This includes the &quot;special&quot; numbers `NaN`, `+Infinity` and `-Infinity`.&#xA;* If you wish to exclude these then you can use the native&#xA;[`isFinite&apos;](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite)&#xA;method.&#xA;" ilk="function" name="isNumber" returns="boolean" signature="isNumber(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not&#xA;considered to be objects. Note that JavaScript arrays are objects.&#xA;" ilk="function" name="isObject" returns="boolean" signature="isObject(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is a `String`.&#xA;" ilk="function" name="isString" returns="boolean" signature="isString(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Determines if a reference is undefined.&#xA;" ilk="function" name="isUndefined" returns="boolean" signature="isUndefined(value) =&gt; boolean">
          <variable citdl="*" doc="Reference to check." ilk="argument" name="value" />
        </scope>
        <scope doc="Converts the specified string to lowercase." ilk="function" name="lowercase" returns="string" signature="lowercase(string) =&gt; string">
          <variable citdl="string" doc="String to be converted to lowercase." ilk="argument" name="string" />
        </scope>
        <scope doc="Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)&#xA;to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so&#xA;by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.&#xA;Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source&#xA;objects, performing a deep copy.&#xA;" ilk="function" name="merge" returns="Object" signature="merge(dst) =&gt; Object">
          <variable citdl="Object" doc="Destination object." ilk="argument" name="dst" />
        </scope>
        <scope doc="* The `angular.module` is a global place for creating, registering and retrieving Angular&#xA;modules.&#xA;All modules (angular core or 3rd party) that should be available to an application must be&#xA;registered using this mechanism.&#xA;* Passing one argument retrieves an existing {@link angular.Module},&#xA;whereas passing more than one argument creates a new {@link angular.Module}&#xA;*&#xA;# Module&#xA;* A module is a collection of services, directives, controllers, filters, and configuration information.&#xA;`angular.module` is used to configure the {@link auto.$injector $injector}.&#xA;* ```js&#xA;// Create a new module&#xA;var myModule = angular.module(&apos;myModule&apos;, []);&#xA;* // register a new service&#xA;myModule.value(&apos;appName&apos;, &apos;MyCoolApp&apos;);&#xA;* // configure existing services inside initialization blocks.&#xA;myModule.config([&apos;$locationProvider&apos;, function($locationProvider) {&#xA;// Configure existing providers&#xA;$locationProvider.hashPrefix(&apos;!&apos;);&#xA;}]);&#xA;```&#xA;* Then you can create an injector and load your modules like this:&#xA;* ```js&#xA;var injector = angular.injector([&apos;ng&apos;, &apos;myModule&apos;])&#xA;```&#xA;* However it&apos;s more likely that you&apos;ll just use&#xA;{@link ng.directive:ngApp ngApp} or&#xA;{@link angular.bootstrap} to simplify this process for you.&#xA;" ilk="function" name="module" returns="angular.Module" signature="module(name) =&gt; angular.Module">
          <variable citdl="!string" doc="The name of the module to create or retrieve." ilk="argument" name="name" />
        </scope>
        <scope ilk="function" name="noop" signature="noop()" />
        <scope ilk="function" name="reloadWithDebugInfo" signature="reloadWithDebugInfo()" />
        <scope doc="Serializes input into a JSON-formatted string. Properties with leading $$ characters will be&#xA;stripped since angular uses this notation internally.&#xA;" ilk="function" name="toJson" returns="string|undefined" signature="toJson(obj) =&gt; string|undefined">
          <variable citdl="Object|Array|Date|string|number" doc="Input to be serialized into JSON." ilk="argument" name="obj" />
        </scope>
        <scope doc="Converts the specified string to uppercase." ilk="function" name="uppercase" returns="string" signature="uppercase(string) =&gt; string">
          <variable citdl="string" doc="String to be converted to uppercase." ilk="argument" name="string" />
        </scope>
        <scope ilk="class" name="Module">
          <scope ilk="function" name="animation" signature="animation(name)">
            <variable citdl="string" doc="animation name" ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="config" signature="config()" />
          <scope ilk="function" name="constant" signature="constant(name)">
            <variable citdl="string" doc="constant name" ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="controller" signature="controller(constructor)">
            <variable citdl="Function" doc="Controller constructor function." ilk="argument" name="constructor" />
          </scope>
          <scope ilk="function" name="decorator" signature="decorator(The)">
            <variable citdl="string" doc="name of the service to decorate." ilk="argument" name="The" />
          </scope>
          <scope ilk="function" name="directive" signature="directive()" />
          <scope ilk="function" name="factory" signature="factory(name)">
            <variable citdl="string" doc="service name" ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="filter" signature="filter(name)">
            <variable citdl="string" doc="Filter name - this must be a valid angular expression identifier" ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="provider" signature="provider(name)">
            <variable citdl="string" doc="service name" ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="run" signature="run()" />
          <scope ilk="function" name="service" signature="service(name)">
            <variable citdl="string" doc="service name" ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="value" signature="value(name)">
            <variable citdl="string" doc="service name" ilk="argument" name="name" />
          </scope>
          <variable name="name" />
          <variable name="requires" />
        </scope>
        <variable name="version" />
      </scope>
      <scope ilk="class" name="$anchorScrollProvider">
        <scope ilk="function" name="disableAutoScrolling" signature="disableAutoScrolling()" />
      </scope>
      <scope ilk="class" name="$animateProvider">
        <scope doc="Sets and/or returns the CSS class regular expression that is checked when performing&#xA;an animation. Upon bootstrap the classNameFilter value is not set at all and will&#xA;therefore enable $animate to attempt to perform an animation on any element that is triggered.&#xA;When setting the `classNameFilter` value, animations will only be performed on elements&#xA;that successfully match the filter expression. This in turn can boost performance&#xA;for low-powered devices as well as applications containing a lot of structural operations." ilk="function" name="classNameFilter" signature="classNameFilter(expression)">
          <variable citdl="RegExp=" doc="The className expression which will be checked against all animations" ilk="argument" name="expression" />
        </scope>
        <scope doc="Registers a new injectable animation factory function. The factory function produces the&#xA;animation object which contains callback functions for each event that is expected to be&#xA;animated.&#xA;*   * `eventFn`: `function(element, ... , doneFunction, options)`&#xA;The element to animate, the `doneFunction` and the options fed into the animation. Depending&#xA;on the type of animation additional arguments will be injected into the animation function. The&#xA;list below explains the function signatures for the different animation methods:&#xA;*   - setClass: function(element, addedClasses, removedClasses, doneFunction, options)&#xA;- addClass: function(element, addedClasses, doneFunction, options)&#xA;- removeClass: function(element, removedClasses, doneFunction, options)&#xA;- enter, leave, move: function(element, doneFunction, options)&#xA;- animate: function(element, fromStyles, toStyles, doneFunction, options)&#xA;*   Make sure to trigger the `doneFunction` once the animation is fully complete.&#xA;* ```js&#xA;return {&#xA;//enter, leave, move signature&#xA;eventFn : function(element, done, options) {&#xA;//code to run the animation&#xA;//once complete, then run done()&#xA;return function endFunction(wasCancelled) {&#xA;//code to cancel the animation&#xA;}&#xA;}&#xA;}&#xA;```&#xA;" ilk="function" name="register" signature="register(name)">
          <variable citdl="string" doc="The name of the animation (this is what the class-based CSS value will be compared to)." ilk="argument" name="name" />
        </scope>
      </scope>
      <scope ilk="class" name="$compileProvider">
        <scope doc="Retrieves or overrides the default regular expression that is used for whitelisting of safe&#xA;urls during a[href] sanitization.&#xA;* The sanitization is a security measure aimed at preventing XSS attacks via html links.&#xA;* Any url about to be assigned to a[href] via data-binding is first normalized and turned into&#xA;an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`&#xA;regular expression. If a match is found, the original url is written into the dom. Otherwise,&#xA;the absolute url is prefixed with `&apos;unsafe:&apos;` string and only then is it written into the DOM.&#xA;" ilk="function" name="aHrefSanitizationWhitelist" returns="RegExp|ng.$compileProvider" signature="aHrefSanitizationWhitelist(regexp) =&gt; RegExp|ng.$compileProvider">
          <variable citdl="RegExp=" doc="New regexp to whitelist urls with." ilk="argument" name="regexp" />
        </scope>
        <scope ilk="function" name="debugInfoEnabled" returns="*" signature="debugInfoEnabled() =&gt; *" />
        <scope doc="Register a new directive with the compiler.&#xA;" ilk="function" name="directive" returns="ng.$compileProvider" signature="directive() =&gt; ng.$compileProvider" />
        <scope doc="Retrieves or overrides the default regular expression that is used for whitelisting of safe&#xA;urls during img[src] sanitization.&#xA;* The sanitization is a security measure aimed at prevent XSS attacks via html links.&#xA;* Any url about to be assigned to img[src] via data-binding is first normalized and turned into&#xA;an absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist`&#xA;regular expression. If a match is found, the original url is written into the dom. Otherwise,&#xA;the absolute url is prefixed with `&apos;unsafe:&apos;` string and only then is it written into the DOM.&#xA;" ilk="function" name="imgSrcSanitizationWhitelist" returns="RegExp|ng.$compileProvider" signature="imgSrcSanitizationWhitelist(regexp) =&gt; RegExp|ng.$compileProvider">
          <variable citdl="RegExp=" doc="New regexp to whitelist urls with." ilk="argument" name="regexp" />
        </scope>
      </scope>
      <scope ilk="class" name="$controllerProvider">
        <scope ilk="function" name="allowGlobals" signature="allowGlobals()" />
        <scope ilk="function" name="register" signature="register()" />
      </scope>
      <scope ilk="class" name="$filterProvider">
        <scope ilk="function" name="register" returns="Object" signature="register(factory) =&gt; Object">
          <variable citdl="Function" doc="If the first argument was a string, a factory function for the filter to be registered." ilk="argument" name="factory" />
        </scope>
      </scope>
      <scope ilk="class" name="$httpProvider">
        <scope doc="* Configure $http service to combine processing of multiple http responses received at around&#xA;the same time via {@link ng.$rootScope.Scope#$applyAsync $rootScope.$applyAsync}. This can result in&#xA;significant performance improvement for bigger applications that make many HTTP requests&#xA;concurrently (common during application bootstrap).&#xA;* Defaults to false. If no value is specified, returns the current configured value.&#xA;" ilk="function" name="useApplyAsync" returns="boolean|Object" signature="useApplyAsync() =&gt; boolean|Object" />
        <scope doc="* Configure `$http` service to return promises without the shorthand methods `success` and `error`.&#xA;This should be used to make sure that applications work without these methods.&#xA;* Defaults to true. If no value is specified, returns the current configured value.&#xA;" ilk="function" name="useLegacyPromiseExtensions" returns="boolean|Object" signature="useLegacyPromiseExtensions() =&gt; boolean|Object" />
        <variable name="defaults" />
        <variable name="interceptors" />
      </scope>
      <scope doc="* Used for configuring the interpolation markup. Defaults to `{{` and `}}`.&#xA;" ilk="class" name="$interpolateProvider">
        <scope doc="Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.&#xA;" ilk="function" name="endSymbol" returns="string|self" signature="endSymbol(value) =&gt; string|self">
          <variable citdl="string=" doc="new value to set the ending symbol to." ilk="argument" name="value" />
        </scope>
        <scope doc="Symbol to denote start of expression in the interpolated string. Defaults to `{{`.&#xA;" ilk="function" name="startSymbol" returns="string|self" signature="startSymbol(value) =&gt; string|self">
          <variable citdl="string=" doc="new value to set the starting symbol to." ilk="argument" name="value" />
        </scope>
      </scope>
      <scope ilk="class" name="$locationProvider">
        <scope doc="@param {string=} prefix Prefix for hash part (containing path and search)" ilk="function" name="hashPrefix" returns="*" signature="hashPrefix(prefix) =&gt; *">
          <variable citdl="string=" doc="Prefix for hash part (containing path and search)" ilk="argument" name="prefix" />
        </scope>
        <scope doc="@param {(boolean|Object)=} mode If boolean, sets `html5Mode.enabled` to value.&#xA;If object, sets `enabled`, `requireBase` and `rewriteLinks` to respective values. Supported&#xA;properties:&#xA;- **enabled** &#226;&#128;&#147; `{boolean}` &#226;&#128;&#147; (default: false) If true, will rely on `history.pushState` to&#xA;change urls where supported. Will fall back to hash-prefixed paths in browsers that do not&#xA;support `pushState`.&#xA;- **requireBase** - `{boolean}` - (default: `true`) When html5Mode is enabled, specifies&#xA;whether or not a &lt;base&gt; tag is required to be present. If `enabled` and `requireBase` are&#xA;true, and a base tag is not present, an error will be thrown when `$location` is injected.&#xA;See the {@link guide/$location $location guide for more information}&#xA;- **rewriteLinks** - `{boolean}` - (default: `true`) When html5Mode is enabled,&#xA;enables/disables url rewriting for relative links.&#xA;" ilk="function" name="html5Mode" returns="Object" signature="html5Mode() =&gt; Object" />
      </scope>
      <scope ilk="class" name="$logProvider">
        <scope doc="@param {boolean=} flag enable or disable debug level messages" ilk="function" name="debugEnabled" returns="*" signature="debugEnabled(flag) =&gt; *">
          <variable citdl="boolean=" doc="enable or disable debug level messages" ilk="argument" name="flag" />
        </scope>
      </scope>
      <scope ilk="class" name="$parseProvider" />
      <scope ilk="class" name="$rootScopeProvider">
        <scope doc="* Sets the number of `$digest` iterations the scope should attempt to execute before giving up and&#xA;assuming that the model is unstable.&#xA;* The current default is 10 iterations.&#xA;* In complex applications it&apos;s possible that the dependencies between `$watch`s will result in&#xA;several digest iterations. However if an application needs more than the default 10 digest&#xA;iterations for its model to stabilize then you should investigate what is causing the model to&#xA;continuously change during the digest.&#xA;* Increasing the TTL could have performance implications, so you should not change it without&#xA;proper justification.&#xA;" ilk="function" name="digestTtl" signature="digestTtl()" />
      </scope>
      <scope ilk="class" name="$sceDelegateProvider">
        <scope ilk="function" name="resourceUrlBlacklist" signature="resourceUrlBlacklist()" />
        <scope ilk="function" name="resourceUrlWhitelist" signature="resourceUrlWhitelist()" />
      </scope>
      <scope ilk="class" name="$sceProvider">
        <scope ilk="function" name="enabled" signature="enabled(value)">
          <variable citdl="boolean=" doc="If provided, then enables/disables SCE." ilk="argument" name="value" />
        </scope>
      </scope>
      <scope doc="When called, it scrolls to the element related to the specified `hash` or (if omitted) to the&#xA;current value of {@link ng.$location#hash $location.hash()}, according to the rules specified&#xA;in the&#xA;[HTML5 spec](http://www.w3.org/html/wg/drafts/html/master/browsers.html#the-indicated-part-of-the-document).&#xA;* It also watches the {@link ng.$location#hash $location.hash()} and automatically scrolls to&#xA;match any anchor whenever it changes. This can be disabled by calling&#xA;{@link ng.$anchorScrollProvider#disableAutoScrolling $anchorScrollProvider.disableAutoScrolling()}.&#xA;* Additionally, you can use its {@link ng.$anchorScroll#yOffset yOffset} property to specify a&#xA;vertical scroll-offset (either fixed or dynamic).&#xA;" ilk="class" name="$anchorScroll" />
      <scope ilk="class" name="$animate">
        <scope doc="Triggers an addClass animation surrounding the addition of the provided CSS class(es). Upon&#xA;execution, the addClass operation will only be handled after the next digest and it will not trigger an&#xA;animation if element already contains the CSS class or if the class is removed at a later step.&#xA;Note that class-based animations are treated differently compared to structural animations&#xA;(like enter, move and leave) since the CSS classes may be added/removed at different points&#xA;depending if CSS or JavaScript animations are used.&#xA;" ilk="function" name="addClass" signature="addClass(element)">
          <variable citdl="DOMElement" doc="the element which the CSS classes will be applied to" ilk="argument" name="element" />
        </scope>
        <scope doc="Performs an inline animation on the element which applies the provided to and from CSS styles to the element.&#xA;If any detected CSS transition, keyframe or JavaScript matches the provided className value, then the animation will take&#xA;on the provided styles. For example, if a transition animation is set for the given className, then the provided `from` and&#xA;`to` styles will be applied alongside the given transition. If the CSS style provided in `from` does not have a corresponding&#xA;style in `to`, the style in `from` is applied immediately, and no animation is run.&#xA;If a JavaScript animation is detected then the provided styles will be given in as function parameters into the `animate`&#xA;method (or as part of the `options` parameter):&#xA;* ```js&#xA;ngModule.animation(&apos;.my-inline-animation&apos;, function() {&#xA;return {&#xA;animate : function(element, from, to, done, options) {&#xA;//animation&#xA;done();&#xA;}&#xA;}&#xA;});&#xA;```&#xA;" ilk="function" name="animate" signature="animate(element,to)">
          <variable citdl="DOMElement" doc="the element which the CSS styles will be applied to" ilk="argument" name="element" />
          <variable citdl="object" doc="the to (destination) CSS styles that will be applied to the element and across the animation." ilk="argument" name="to" />
        </scope>
        <scope doc="Cancels the provided animation.&#xA;" ilk="function" name="cancel" signature="cancel()" />
        <scope doc="Used to get and set whether animations are enabled or not on the entire application or on an element and its children. This&#xA;function can be called in four ways:&#xA;* ```js&#xA;// returns true or false&#xA;$animate.enabled();&#xA;* // changes the enabled state for all animations&#xA;$animate.enabled(false);&#xA;$animate.enabled(true);&#xA;* // returns true or false if animations are enabled for an element&#xA;$animate.enabled(element);&#xA;* // changes the enabled state for an element and its children&#xA;$animate.enabled(element, true);&#xA;$animate.enabled(element, false);&#xA;```&#xA;" ilk="function" name="enabled" signature="enabled(element)">
          <variable citdl="DOMElement=" doc="the element that will be considered for checking/setting the enabled state" ilk="argument" name="element" />
        </scope>
        <scope doc="Inserts the element into the DOM either after the `after` element (if provided) or&#xA;as the first child within the `parent` element and then triggers an animation.&#xA;A promise is returned that will be resolved during the next digest once the animation&#xA;has completed.&#xA;" ilk="function" name="enter" signature="enter(element,after)">
          <variable citdl="DOMElement" doc="the element which will be inserted into the DOM" ilk="argument" name="element" />
          <variable citdl="DOMElement=" doc="the sibling element after which the element will be appended" ilk="argument" name="after" />
        </scope>
        <scope doc="Triggers an animation and then removes the element from the DOM.&#xA;When the function is called a promise is returned that will be resolved during the next&#xA;digest once the animation has completed.&#xA;" ilk="function" name="leave" signature="leave(element)">
          <variable citdl="DOMElement" doc="the element which will be removed from the DOM" ilk="argument" name="element" />
        </scope>
        <scope doc="Inserts (moves) the element into its new position in the DOM either after&#xA;the `after` element (if provided) or as the first child within the `parent` element&#xA;and then triggers an animation. A promise is returned that will be resolved&#xA;during the next digest once the animation has completed.&#xA;" ilk="function" name="move" signature="move(element,after)">
          <variable citdl="DOMElement" doc="the element which will be moved into the new DOM position" ilk="argument" name="element" />
          <variable citdl="DOMElement=" doc="the sibling element after which the element will be appended" ilk="argument" name="after" />
        </scope>
        <scope doc="Deregisters an event listener based on the event which has been associated with the provided element. This method&#xA;can be used in three different ways depending on the arguments:&#xA;* ```js&#xA;// remove all the animation event listeners listening for `enter`&#xA;$animate.off(&apos;enter&apos;);&#xA;* // remove all the animation event listeners listening for `enter` on the given element and its children&#xA;$animate.off(&apos;enter&apos;, container);&#xA;* // remove the event listener function provided by `listenerFn` that is set&#xA;// to listen for `enter` on the given `element` as well as its children&#xA;$animate.off(&apos;enter&apos;, container, callback);&#xA;```&#xA;" ilk="function" name="off" signature="off(event)">
          <variable citdl="string" doc="the animation event (e.g. enter, leave, move, addClass, removeClass, etc...)" ilk="argument" name="event" />
        </scope>
        <scope doc="Sets up an event listener to fire whenever the animation event (enter, leave, move, etc...)&#xA;has fired on the given element or among any of its children. Once the listener is fired, the provided callback&#xA;is fired with the following params:&#xA;* ```js&#xA;$animate.on(&apos;enter&apos;, container,&#xA;function callback(element, phase) {&#xA;// cool we detected an enter animation within the container&#xA;}&#xA;);&#xA;```&#xA;" ilk="function" name="on" signature="on(event)">
          <variable citdl="string" doc="the animation event that will be captured (e.g. enter, leave, move, addClass, removeClass, etc...)" ilk="argument" name="event" />
        </scope>
        <scope doc="Associates the provided element with a host parent element to allow the element to be animated even if it exists&#xA;outside of the DOM structure of the Angular application. By doing so, any animation triggered via `$animate` can be issued on the&#xA;element despite being outside the realm of the application or within another application. Say for example if the application&#xA;was bootstrapped on an element that is somewhere inside of the `&lt;body&gt;` tag, but we wanted to allow for an element to be situated&#xA;as a direct child of `document.body`, then this can be achieved by pinning the element via `$animate.pin(element)`. Keep in mind&#xA;that calling `$animate.pin(element, parentElement)` will not actually insert into the DOM anywhere; it will just create the association.&#xA;*    Note that this feature is only active when the `ngAnimate` module is used.&#xA;" ilk="function" name="pin" signature="pin(element)">
          <variable citdl="DOMElement" doc="the external element that will be pinned" ilk="argument" name="element" />
        </scope>
        <scope doc="Triggers a removeClass animation surrounding the removal of the provided CSS class(es). Upon&#xA;execution, the removeClass operation will only be handled after the next digest and it will not trigger an&#xA;animation if element does not contain the CSS class or if the class is added at a later step.&#xA;Note that class-based animations are treated differently compared to structural animations&#xA;(like enter, move and leave) since the CSS classes may be added/removed at different points&#xA;depending if CSS or JavaScript animations are used.&#xA;" ilk="function" name="removeClass" signature="removeClass(element)">
          <variable citdl="DOMElement" doc="the element which the CSS classes will be applied to" ilk="argument" name="element" />
        </scope>
        <scope doc="Performs both the addition and removal of a CSS classes on an element and (during the process)&#xA;triggers an animation surrounding the class addition/removal. Much like `$animate.addClass` and&#xA;`$animate.removeClass`, `setClass` will only evaluate the classes being added/removed once a digest has&#xA;passed. Note that class-based animations are treated differently compared to structural animations&#xA;(like enter, move and leave) since the CSS classes may be added/removed at different points&#xA;depending if CSS or JavaScript animations are used.&#xA;" ilk="function" name="setClass" signature="setClass(element,remove)">
          <variable citdl="DOMElement" doc="the element which the CSS classes will be applied to" ilk="argument" name="element" />
          <variable citdl="string" doc="the CSS class(es) that will be removed (multiple classes are separated via spaces)" ilk="argument" name="remove" />
        </scope>
      </scope>
      <scope ilk="class" name="$animateCss" />
      <scope doc="Factory that constructs {@link $cacheFactory.Cache Cache} objects and gives access to&#xA;them.&#xA;* ```js&#xA;*  var cache = $cacheFactory(&apos;cacheId&apos;);&#xA;expect($cacheFactory.get(&apos;cacheId&apos;)).toBe(cache);&#xA;expect($cacheFactory.get(&apos;noSuchCacheId&apos;)).not.toBeDefined();&#xA;*  cache.put(&quot;key&quot;, &quot;value&quot;);&#xA;cache.put(&quot;another key&quot;, &quot;another value&quot;);&#xA;*  // We&apos;ve specified no options on creation&#xA;expect(cache.info()).toEqual({id: &apos;cacheId&apos;, size: 2});&#xA;* ```&#xA;*" ilk="class" name="$cacheFactory">
        <scope ilk="class" name="Cache">
          <scope ilk="function" name="destroy" signature="destroy()" />
          <scope doc="Retrieves named data stored in the {@link $cacheFactory.Cache Cache} object.&#xA;" ilk="function" name="get" returns="*" signature="get(key) =&gt; *">
            <variable citdl="string" doc="the key of the data to be retrieved" ilk="argument" name="key" />
          </scope>
          <scope doc="Retrieve information regarding a particular {@link $cacheFactory.Cache Cache}.&#xA;" ilk="function" name="info" returns="object" signature="info() =&gt; object" />
          <scope doc="Inserts a named entry into the {@link $cacheFactory.Cache Cache} object to be&#xA;retrieved later, and incrementing the size of the cache if the key was not already&#xA;present in the cache. If behaving like an LRU cache, it will also remove stale&#xA;entries from the set.&#xA;* It will not insert undefined values into the cache.&#xA;" ilk="function" name="put" returns="*" signature="put(key) =&gt; *">
            <variable citdl="string" doc="the key under which the cached data is stored." ilk="argument" name="key" />
          </scope>
          <scope doc="Removes an entry from the {@link $cacheFactory.Cache Cache} object.&#xA;" ilk="function" name="remove" signature="remove()" />
          <scope ilk="function" name="removeAll" signature="removeAll()" />
        </scope>
        <scope doc="Get access to a cache object by the `cacheId` used when it was created.&#xA;" ilk="function" name="get" returns="object" signature="get(cacheId) =&gt; object">
          <variable citdl="string" doc="Name or id of a cache to access." ilk="argument" name="cacheId" />
        </scope>
        <scope doc="Get information about all the caches that have been created&#xA;" ilk="function" name="info" returns="Object" signature="info() =&gt; Object" />
      </scope>
      <scope doc="Compiles an HTML string or DOM into a template and produces a template function, which&#xA;can then be used to link {@link ng.$rootScope.Scope `scope`} and the template together.&#xA;* The compilation is a process of walking the DOM tree and matching DOM elements to&#xA;{@link ng.$compileProvider#directive directives}.&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note:** This document is an in-depth reference of all directive options.&#xA;For a gentle introduction to directives with examples of common use cases,&#xA;see the {@link guide/directive directive guide}.&#xA;&lt;/div&gt;&#xA;* ## Comprehensive Directive API&#xA;* There are many different options for a directive.&#xA;* The difference resides in the return value of the factory function.&#xA;You can either return a &quot;Directive Definition Object&quot; (see below) that defines the directive properties,&#xA;or just the `postLink` function (all other properties will have the default values).&#xA;* &lt;div class=&quot;alert alert-success&quot;&gt;&#xA;**Best Practice:** It&apos;s recommended to use the &quot;directive definition object&quot; form.&#xA;&lt;/div&gt;&#xA;* Here&apos;s an example directive declared with a Directive Definition Object:&#xA;* ```js&#xA;var myModule = angular.module(...);&#xA;*   myModule.directive(&apos;directiveName&apos;, function factory(injectables) {&#xA;var directiveDefinitionObject = {&#xA;priority: 0,&#xA;template: &apos;&lt;div&gt;&lt;/div&gt;&apos;, // or // function(tElement, tAttrs) { ... },&#xA;// or&#xA;// templateUrl: &apos;directive.html&apos;, // or // function(tElement, tAttrs) { ... },&#xA;transclude: false,&#xA;restrict: &apos;A&apos;,&#xA;templateNamespace: &apos;html&apos;,&#xA;scope: false,&#xA;controller: function($scope, $element, $attrs, $transclude, otherInjectables) { ... },&#xA;controllerAs: &apos;stringIdentifier&apos;,&#xA;bindToController: false,&#xA;require: &apos;siblingDirectiveName&apos;, // or // [&apos;^parentDirectiveName&apos;, &apos;?optionalDirectiveName&apos;, &apos;?^optionalParent&apos;],&#xA;compile: function compile(tElement, tAttrs, transclude) {&#xA;return {&#xA;pre: function preLink(scope, iElement, iAttrs, controller) { ... },&#xA;post: function postLink(scope, iElement, iAttrs, controller) { ... }&#xA;}&#xA;// or&#xA;// return function postLink( ... ) { ... }&#xA;},&#xA;// or&#xA;// link: {&#xA;//  pre: function preLink(scope, iElement, iAttrs, controller) { ... },&#xA;//  post: function postLink(scope, iElement, iAttrs, controller) { ... }&#xA;// }&#xA;// or&#xA;// link: function postLink( ... ) { ... }&#xA;};&#xA;return directiveDefinitionObject;&#xA;});&#xA;```&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note:** Any unspecified options will use the default value. You can see the default values below.&#xA;&lt;/div&gt;&#xA;* Therefore the above can be simplified as:&#xA;* ```js&#xA;var myModule = angular.module(...);&#xA;*   myModule.directive(&apos;directiveName&apos;, function factory(injectables) {&#xA;var directiveDefinitionObject = {&#xA;link: function postLink(scope, iElement, iAttrs) { ... }&#xA;};&#xA;return directiveDefinitionObject;&#xA;// or&#xA;// return function postLink(scope, iElement, iAttrs) { ... }&#xA;});&#xA;```&#xA;*&#xA;* ### Directive Definition Object&#xA;* The directive definition object provides instructions to the {@link ng.$compile&#xA;compiler}. The attributes are:&#xA;* #### `multiElement`&#xA;When this property is set to true, the HTML compiler will collect DOM nodes between&#xA;nodes with the attributes `directive-name-start` and `directive-name-end`, and group them&#xA;together as the directive elements. It is recommended that this feature be used on directives&#xA;which are not strictly behavioural (such as {@link ngClick}), and which&#xA;do not manipulate or replace child nodes (such as {@link ngInclude}).&#xA;* #### `priority`&#xA;When there are multiple directives defined on a single DOM element, sometimes it&#xA;is necessary to specify the order in which the directives are applied. The `priority` is used&#xA;to sort the directives before their `compile` functions get called. Priority is defined as a&#xA;number. Directives with greater numerical `priority` are compiled first. Pre-link functions&#xA;are also run in priority order, but post-link functions are run in reverse order. The order&#xA;of directives with the same priority is undefined. The default priority is `0`.&#xA;* #### `terminal`&#xA;If set to true then the current `priority` will be the last set of directives&#xA;which will execute (any directives at the current priority will still execute&#xA;as the order of execution on same `priority` is undefined). Note that expressions&#xA;and other directives used in the directive&apos;s template will also be excluded from execution.&#xA;* #### `scope`&#xA;The scope property can be `true`, an object or a falsy value:&#xA;* * **falsy:** No scope will be created for the directive. The directive will use its parent&apos;s scope.&#xA;* * **`true`:** A new child scope that prototypically inherits from its parent will be created for&#xA;the directive&apos;s element. If multiple directives on the same element request a new scope,&#xA;only one new scope is created. The new scope rule does not apply for the root of the template&#xA;since the root of the template always gets a new scope.&#xA;* * **`{...}` (an object hash):** A new &quot;isolate&quot; scope is created for the directive&apos;s element. The&#xA;&apos;isolate&apos; scope differs from normal scope in that it does not prototypically inherit from its parent&#xA;scope. This is useful when creating reusable components, which should not accidentally read or modify&#xA;data in the parent scope.&#xA;* The &apos;isolate&apos; scope object hash defines a set of local scope properties derived from attributes on the&#xA;directive&apos;s element. These local properties are useful for aliasing values for templates. The keys in&#xA;the object hash map to the name of the property on the isolate scope; the values define how the property&#xA;is bound to the parent scope, via matching attributes on the directive&apos;s element:&#xA;* * `@` or `@attr` - bind a local scope property to the value of DOM attribute. The result is&#xA;always a string since DOM attributes are strings. If no `attr` name is specified  then the&#xA;attribute name is assumed to be the same as the local name.&#xA;Given `&lt;widget my-attr=&quot;hello {{name}}&quot;&gt;` and widget definition&#xA;of `scope: { localName:&apos;@myAttr&apos; }`, then widget scope property `localName` will reflect&#xA;the interpolated value of `hello {{name}}`. As the `name` attribute changes so will the&#xA;`localName` property on the widget scope. The `name` is read from the parent scope (not&#xA;component scope).&#xA;* * `=` or `=attr` - set up bi-directional binding between a local scope property and the&#xA;parent scope property of name defined via the value of the `attr` attribute. If no `attr`&#xA;name is specified then the attribute name is assumed to be the same as the local name.&#xA;Given `&lt;widget my-attr=&quot;parentModel&quot;&gt;` and widget definition of&#xA;`scope: { localModel:&apos;=myAttr&apos; }`, then widget scope property `localModel` will reflect the&#xA;value of `parentModel` on the parent scope. Any changes to `parentModel` will be reflected&#xA;in `localModel` and any changes in `localModel` will reflect in `parentModel`. If the parent&#xA;scope property doesn&apos;t exist, it will throw a NON_ASSIGNABLE_MODEL_EXPRESSION exception. You&#xA;can avoid this behavior using `=?` or `=?attr` in order to flag the property as optional. If&#xA;you want to shallow watch for changes (i.e. $watchCollection instead of $watch) you can use&#xA;`=*` or `=*attr` (`=*?` or `=*?attr` if the property is optional).&#xA;* * `&amp;` or `&amp;attr` - provides a way to execute an expression in the context of the parent scope.&#xA;If no `attr` name is specified then the attribute name is assumed to be the same as the&#xA;local name. Given `&lt;widget my-attr=&quot;count = count + value&quot;&gt;` and widget definition of&#xA;`scope: { localFn:&apos;&amp;myAttr&apos; }`, then isolate scope property `localFn` will point to&#xA;a function wrapper for the `count = count + value` expression. Often it&apos;s desirable to&#xA;pass data from the isolated scope via an expression to the parent scope, this can be&#xA;done by passing a map of local variable names and values into the expression wrapper fn.&#xA;For example, if the expression is `increment(amount)` then we can specify the amount value&#xA;by calling the `localFn` as `localFn({amount: 22})`.&#xA;* In general it&apos;s possible to apply more than one directive to one element, but there might be limitations&#xA;depending on the type of scope required by the directives. The following points will help explain these limitations.&#xA;For simplicity only two directives are taken into account, but it is also applicable for several directives:&#xA;* * **no scope** + **no scope** =&gt; Two directives which don&apos;t require their own scope will use their parent&apos;s scope&#xA;* **child scope** + **no scope** =&gt;  Both directives will share one single child scope&#xA;* **child scope** + **child scope** =&gt;  Both directives will share one single child scope&#xA;* **isolated scope** + **no scope** =&gt;  The isolated directive will use it&apos;s own created isolated scope. The other directive will use&#xA;its parent&apos;s scope&#xA;* **isolated scope** + **child scope** =&gt;  **Won&apos;t work!** Only one scope can be related to one element. Therefore these directives cannot&#xA;be applied to the same element.&#xA;* **isolated scope** + **isolated scope**  =&gt;  **Won&apos;t work!** Only one scope can be related to one element. Therefore these directives&#xA;cannot be applied to the same element.&#xA;*&#xA;#### `bindToController`&#xA;This property is used to bind scope properties directly to the controller. It can be either&#xA;`true` or an object hash with the same format as the `scope` property. Additionally, a controller&#xA;alias must be set, either by using `controllerAs: &apos;myAlias&apos;` or by specifying the alias in the controller&#xA;definition: `controller: &apos;myCtrl as myAlias&apos;`.&#xA;* When an isolate scope is used for a directive (see above), `bindToController: true` will&#xA;allow a component to have its properties bound to the controller, rather than to scope. When the controller&#xA;is instantiated, the initial values of the isolate scope bindings are already available.&#xA;* It is also possible to set `bindToController` to an object hash with the same format as the `scope` property.&#xA;This will set up the scope bindings to the controller directly. Note that `scope` can still be used&#xA;to define which kind of scope is created. By default, no scope is created. Use `scope: {}` to create an isolate&#xA;scope (useful for component directives).&#xA;* If both `bindToController` and `scope` are defined and have object hashes, `bindToController` overrides `scope`.&#xA;*&#xA;#### `controller`&#xA;Controller constructor function. The controller is instantiated before the&#xA;pre-linking phase and can be accessed by other directives (see&#xA;`require` attribute). This allows the directives to communicate with each other and augment&#xA;each other&apos;s behavior. The controller is injectable (and supports bracket notation) with the following locals:&#xA;* * `$scope` - Current scope associated with the element&#xA;* `$element` - Current element&#xA;* `$attrs` - Current attributes object for the element&#xA;* `$transclude` - A transclude linking function pre-bound to the correct transclusion scope:&#xA;`function([scope], cloneLinkingFn, futureParentElement)`.&#xA;* `scope`: optional argument to override the scope.&#xA;* `cloneLinkingFn`: optional argument to create clones of the original transcluded content.&#xA;* `futureParentElement`:&#xA;* defines the parent to which the `cloneLinkingFn` will add the cloned elements.&#xA;* default: `$element.parent()` resp. `$element` for `transclude:&apos;element&apos;` resp. `transclude:true`.&#xA;* only needed for transcludes that are allowed to contain non html elements (e.g. SVG elements)&#xA;and when the `cloneLinkinFn` is passed,&#xA;as those elements need to created and cloned in a special way when they are defined outside their&#xA;usual containers (e.g. like `&lt;svg&gt;`).&#xA;* See also the `directive.templateNamespace` property.&#xA;*&#xA;#### `require`&#xA;Require another directive and inject its controller as the fourth argument to the linking function. The&#xA;`require` takes a string name (or array of strings) of the directive(s) to pass in. If an array is used, the&#xA;injected argument will be an array in corresponding order. If no such directive can be&#xA;found, or if the directive does not have a controller, then an error is raised (unless no link function&#xA;is specified, in which case error checking is skipped). The name can be prefixed with:&#xA;* * (no prefix) - Locate the required controller on the current element. Throw an error if not found.&#xA;* `?` - Attempt to locate the required controller or pass `null` to the `link` fn if not found.&#xA;* `^` - Locate the required controller by searching the element and its parents. Throw an error if not found.&#xA;* `^^` - Locate the required controller by searching the element&apos;s parents. Throw an error if not found.&#xA;* `?^` - Attempt to locate the required controller by searching the element and its parents or pass&#xA;`null` to the `link` fn if not found.&#xA;* `?^^` - Attempt to locate the required controller by searching the element&apos;s parents, or pass&#xA;`null` to the `link` fn if not found.&#xA;*&#xA;#### `controllerAs`&#xA;Identifier name for a reference to the controller in the directive&apos;s scope.&#xA;This allows the controller to be referenced from the directive template. This is especially&#xA;useful when a directive is used as component, i.e. with an `isolate` scope. It&apos;s also possible&#xA;to use it in a directive without an `isolate` / `new` scope, but you need to be aware that the&#xA;`controllerAs` reference might overwrite a property that already exists on the parent scope.&#xA;*&#xA;#### `restrict`&#xA;String of subset of `EACM` which restricts the directive to a specific directive&#xA;declaration style. If omitted, the defaults (elements and attributes) are used.&#xA;* * `E` - Element name (default): `&lt;my-directive&gt;&lt;/my-directive&gt;`&#xA;* `A` - Attribute (default): `&lt;div my-directive=&quot;exp&quot;&gt;&lt;/div&gt;`&#xA;* `C` - Class: `&lt;div class=&quot;my-directive: exp;&quot;&gt;&lt;/div&gt;`&#xA;* `M` - Comment: `&lt;!-- directive: my-directive exp --&gt;`&#xA;*&#xA;#### `templateNamespace`&#xA;String representing the document type used by the markup in the template.&#xA;AngularJS needs this information as those elements need to be created and cloned&#xA;in a special way when they are defined outside their usual containers like `&lt;svg&gt;` and `&lt;math&gt;`.&#xA;* * `html` - All root nodes in the template are HTML. Root nodes may also be&#xA;top-level elements such as `&lt;svg&gt;` or `&lt;math&gt;`.&#xA;* `svg` - The root nodes in the template are SVG elements (excluding `&lt;math&gt;`).&#xA;* `math` - The root nodes in the template are MathML elements (excluding `&lt;svg&gt;`).&#xA;* If no `templateNamespace` is specified, then the namespace is considered to be `html`.&#xA;* #### `template`&#xA;HTML markup that may:&#xA;* Replace the contents of the directive&apos;s element (default).&#xA;* Replace the directive&apos;s element itself (if `replace` is true - DEPRECATED).&#xA;* Wrap the contents of the directive&apos;s element (if `transclude` is true).&#xA;* Value may be:&#xA;* * A string. For example `&lt;div red-on-hover&gt;{{delete_str}}&lt;/div&gt;`.&#xA;* A function which takes two arguments `tElement` and `tAttrs` (described in the `compile`&#xA;function api below) and returns a string value.&#xA;*&#xA;#### `templateUrl`&#xA;This is similar to `template` but the template is loaded from the specified URL, asynchronously.&#xA;* Because template loading is asynchronous the compiler will suspend compilation of directives on that element&#xA;for later when the template has been resolved.  In the meantime it will continue to compile and link&#xA;sibling and parent elements as though this element had not contained any directives.&#xA;* The compiler does not suspend the entire compilation to wait for templates to be loaded because this&#xA;would result in the whole app &quot;stalling&quot; until all templates are loaded asynchronously - even in the&#xA;case when only one deeply nested directive has `templateUrl`.&#xA;* Template loading is asynchronous even if the template has been preloaded into the {@link $templateCache}&#xA;* You can specify `templateUrl` as a string representing the URL or as a function which takes two&#xA;arguments `tElement` and `tAttrs` (described in the `compile` function api below) and returns&#xA;a string value representing the url.  In either case, the template URL is passed through {@link&#xA;$sce#getTrustedResourceUrl $sce.getTrustedResourceUrl}.&#xA;*&#xA;#### `replace` ([*DEPRECATED*!], will be removed in next major release - i.e. v2.0)&#xA;specify what the template should replace. Defaults to `false`.&#xA;* * `true` - the template will replace the directive&apos;s element.&#xA;* `false` - the template will replace the contents of the directive&apos;s element.&#xA;* The replacement process migrates all of the attributes / classes from the old element to the new&#xA;one. See the {@link guide/directive#template-expanding-directive&#xA;Directives Guide} for an example.&#xA;* There are very few scenarios where element replacement is required for the application function,&#xA;the main one being reusable custom components that are used within SVG contexts&#xA;(because SVG doesn&apos;t work with custom elements in the DOM tree).&#xA;* #### `transclude`&#xA;Extract the contents of the element where the directive appears and make it available to the directive.&#xA;The contents are compiled and provided to the directive as a **transclusion function**. See the&#xA;{@link $compile#transclusion Transclusion} section below.&#xA;* There are two kinds of transclusion depending upon whether you want to transclude just the contents of the&#xA;directive&apos;s element or the entire element:&#xA;* * `true` - transclude the content (i.e. the child nodes) of the directive&apos;s element.&#xA;* `&apos;element&apos;` - transclude the whole of the directive&apos;s element including any directives on this&#xA;element that defined at a lower priority than this directive. When used, the `template`&#xA;property is ignored.&#xA;*&#xA;#### `compile`&#xA;* ```js&#xA;function compile(tElement, tAttrs, transclude) { ... }&#xA;```&#xA;* The compile function deals with transforming the template DOM. Since most directives do not do&#xA;template transformation, it is not used often. The compile function takes the following arguments:&#xA;*   * `tElement` - template element - The element where the directive has been declared. It is&#xA;safe to do template transformation on the element and child elements only.&#xA;*   * `tAttrs` - template attributes - Normalized list of attributes declared on this element shared&#xA;between all directive compile functions.&#xA;*   * `transclude` -  [*DEPRECATED*!] A transclude linking function: `function(scope, cloneLinkingFn)`&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note:** The template instance and the link instance may be different objects if the template has&#xA;been cloned. For this reason it is **not** safe to do anything other than DOM transformations that&#xA;apply to all cloned DOM nodes within the compile function. Specifically, DOM listener registration&#xA;should be done in a linking function rather than in a compile function.&#xA;&lt;/div&gt;&#xA;&lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note:** The compile function cannot handle directives that recursively use themselves in their&#xA;own templates or compile functions. Compiling these directives results in an infinite loop and a&#xA;stack overflow errors.&#xA;* This can be avoided by manually using $compile in the postLink function to imperatively compile&#xA;a directive&apos;s template instead of relying on automatic template compilation via `template` or&#xA;`templateUrl` declaration or manual compilation inside the compile function.&#xA;&lt;/div&gt;&#xA;* &lt;div class=&quot;alert alert-danger&quot;&gt;&#xA;**Note:** The `transclude` function that is passed to the compile function is deprecated, as it&#xA;e.g. does not know about the right outer scope. Please use the transclude function that is passed&#xA;to the link function instead.&#xA;&lt;/div&gt;&#xA;A compile function can have a return value which can be either a function or an object.&#xA;* * returning a (post-link) function - is equivalent to registering the linking function via the&#xA;`link` property of the config object when the compile function is empty.&#xA;* * returning an object with function(s) registered via `pre` and `post` properties - allows you to&#xA;control when a linking function should be called during the linking phase. See info about&#xA;pre-linking and post-linking functions below.&#xA;*&#xA;#### `link`&#xA;This property is used only if the `compile` property is not defined.&#xA;* ```js&#xA;function link(scope, iElement, iAttrs, controller, transcludeFn) { ... }&#xA;```&#xA;* The link function is responsible for registering DOM listeners as well as updating the DOM. It is&#xA;executed after the template has been cloned. This is where most of the directive logic will be&#xA;put.&#xA;*   * `scope` - {@link ng.$rootScope.Scope Scope} - The scope to be used by the&#xA;directive for registering {@link ng.$rootScope.Scope#$watch watches}.&#xA;*   * `iElement` - instance element - The element where the directive is to be used. It is safe to&#xA;manipulate the children of the element only in `postLink` function since the children have&#xA;already been linked.&#xA;*   * `iAttrs` - instance attributes - Normalized list of attributes declared on this element shared&#xA;between all directive linking functions.&#xA;*   * `controller` - the directive&apos;s required controller instance(s) - Instances are shared&#xA;among all directives, which allows the directives to use the controllers as a communication&#xA;channel. The exact value depends on the directive&apos;s `require` property:&#xA;* no controller(s) required: the directive&apos;s own controller, or `undefined` if it doesn&apos;t have one&#xA;* `string`: the controller instance&#xA;* `array`: array of controller instances&#xA;*     If a required controller cannot be found, and it is optional, the instance is `null`,&#xA;otherwise the {@link error:$compile:ctreq Missing Required Controller} error is thrown.&#xA;*     Note that you can also require the directive&apos;s own controller - it will be made available like&#xA;any other controller.&#xA;*   * `transcludeFn` - A transclude linking function pre-bound to the correct transclusion scope.&#xA;This is the same as the `$transclude`&#xA;parameter of directive controllers, see there for details.&#xA;`function([scope], cloneLinkingFn, futureParentElement)`.&#xA;* #### Pre-linking function&#xA;* Executed before the child elements are linked. Not safe to do DOM transformation since the&#xA;compiler linking function will fail to locate the correct elements for linking.&#xA;* #### Post-linking function&#xA;* Executed after the child elements are linked.&#xA;* Note that child elements that contain `templateUrl` directives will not have been compiled&#xA;and linked since they are waiting for their template to load asynchronously and their own&#xA;compilation and linking has been suspended until that occurs.&#xA;* It is safe to do DOM transformation in the post-linking function on elements that are not waiting&#xA;for their async templates to be resolved.&#xA;*&#xA;### Transclusion&#xA;* Transclusion is the process of extracting a collection of DOM elements from one part of the DOM and&#xA;copying them to another part of the DOM, while maintaining their connection to the original AngularJS&#xA;scope from where they were taken.&#xA;* Transclusion is used (often with {@link ngTransclude}) to insert the&#xA;original contents of a directive&apos;s element into a specified place in the template of the directive.&#xA;The benefit of transclusion, over simply moving the DOM elements manually, is that the transcluded&#xA;content has access to the properties on the scope from which it was taken, even if the directive&#xA;has isolated scope.&#xA;See the {@link guide/directive#creating-a-directive-that-wraps-other-elements Directives Guide}.&#xA;* This makes it possible for the widget to have private state for its template, while the transcluded&#xA;content has access to its originating scope.&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note:** When testing an element transclude directive you must not place the directive at the root of the&#xA;DOM fragment that is being compiled. See {@link guide/unit-testing#testing-transclusion-directives&#xA;Testing Transclusion Directives}.&#xA;&lt;/div&gt;&#xA;* #### Transclusion Functions&#xA;* When a directive requests transclusion, the compiler extracts its contents and provides a **transclusion&#xA;function** to the directive&apos;s `link` function and `controller`. This transclusion function is a special&#xA;**linking function** that will return the compiled contents linked to a new transclusion scope.&#xA;* &lt;div class=&quot;alert alert-info&quot;&gt;&#xA;If you are just using {@link ngTransclude} then you don&apos;t need to worry about this function, since&#xA;ngTransclude will deal with it for us.&#xA;&lt;/div&gt;&#xA;* If you want to manually control the insertion and removal of the transcluded content in your directive&#xA;then you must use this transclude function. When you call a transclude function it returns a a jqLite/JQuery&#xA;object that contains the compiled DOM, which is linked to the correct transclusion scope.&#xA;* When you call a transclusion function you can pass in a **clone attach function**. This function accepts&#xA;two parameters, `function(clone, scope) { ... }`, where the `clone` is a fresh compiled copy of your transcluded&#xA;content and the `scope` is the newly created transclusion scope, to which the clone is bound.&#xA;* &lt;div class=&quot;alert alert-info&quot;&gt;&#xA;**Best Practice**: Always provide a `cloneFn` (clone attach function) when you call a translude function&#xA;since you then get a fresh clone of the original DOM and also have access to the new transclusion scope.&#xA;&lt;/div&gt;&#xA;* It is normal practice to attach your transcluded content (`clone`) to the DOM inside your **clone&#xA;attach function**:&#xA;* ```js&#xA;var transcludedContent, transclusionScope;&#xA;* $transclude(function(clone, scope) {&#xA;element.append(clone);&#xA;transcludedContent = clone;&#xA;transclusionScope = scope;&#xA;});&#xA;```&#xA;* Later, if you want to remove the transcluded content from your DOM then you should also destroy the&#xA;associated transclusion scope:&#xA;* ```js&#xA;transcludedContent.remove();&#xA;transclusionScope.$destroy();&#xA;```&#xA;* &lt;div class=&quot;alert alert-info&quot;&gt;&#xA;**Best Practice**: if you intend to add and remove transcluded content manually in your directive&#xA;(by calling the transclude function to get the DOM and calling `element.remove()` to remove it),&#xA;then you are also responsible for calling `$destroy` on the transclusion scope.&#xA;&lt;/div&gt;&#xA;* The built-in DOM manipulation directives, such as {@link ngIf}, {@link ngSwitch} and {@link ngRepeat}&#xA;automatically destroy their transluded clones as necessary so you do not need to worry about this if&#xA;you are simply using {@link ngTransclude} to inject the transclusion into your directive.&#xA;*&#xA;#### Transclusion Scopes&#xA;* When you call a transclude function it returns a DOM fragment that is pre-bound to a **transclusion&#xA;scope**. This scope is special, in that it is a child of the directive&apos;s scope (and so gets destroyed&#xA;when the directive&apos;s scope gets destroyed) but it inherits the properties of the scope from which it&#xA;was taken.&#xA;* For example consider a directive that uses transclusion and isolated scope. The DOM hierarchy might look&#xA;like this:&#xA;* ```html&#xA;&lt;div ng-app&gt;&#xA;&lt;div isolate&gt;&#xA;&lt;div transclusion&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;* The `$parent` scope hierarchy will look like this:&#xA;```&#xA;   - $rootScope&#xA;     - isolate&#xA;       - transclusion&#xA;   ```&#xA;* but the scopes will inherit prototypically from different scopes to their `$parent`.&#xA;```&#xA;   - $rootScope&#xA;     - transclusion&#xA;   - isolate&#xA;   ```&#xA;*&#xA;### Attributes&#xA;* The {@link ng.$compile.directive.Attributes Attributes} object - passed as a parameter in the&#xA;`link()` or `compile()` functions. It has a variety of uses.&#xA;* accessing *Normalized attribute names:*&#xA;Directives like &apos;ngBind&apos; can be expressed in many ways: &apos;ng:bind&apos;, `data-ng-bind`, or &apos;x-ng-bind&apos;.&#xA;the attributes object allows for normalized access to&#xA;the attributes.&#xA;* * *Directive inter-communication:* All directives share the same instance of the attributes&#xA;object which allows the directives to use the attributes object as inter directive&#xA;communication.&#xA;* * *Supports interpolation:* Interpolation attributes are assigned to the attribute object&#xA;allowing other directives to read the interpolated value.&#xA;* * *Observing interpolated attributes:* Use `$observe` to observe the value changes of attributes&#xA;that contain interpolation (e.g. `src=&quot;{{bar}}&quot;`). Not only is this very efficient but it&apos;s also&#xA;the only way to easily get the actual value because during the linking phase the interpolation&#xA;hasn&apos;t been evaluated yet and so the value is at this time set to `undefined`.&#xA;* ```js&#xA;function linkingFn(scope, elm, attrs, ctrl) {&#xA;// get the attribute value&#xA;console.log(attrs.ngModel);&#xA;*   // change the attribute&#xA;attrs.$set(&apos;ngModel&apos;, &apos;new value&apos;);&#xA;*   // observe changes to interpolated attribute&#xA;attrs.$observe(&apos;ngModel&apos;, function(value) {&#xA;console.log(&apos;ngModel has changed value to &apos; + value);&#xA;});&#xA;}&#xA;```&#xA;* ## Example&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note**: Typically directives are registered with `module.directive`. The example below is&#xA;to illustrate how `$compile` works.&#xA;&lt;/div&gt;&#xA;&lt;example module=&quot;compileExample&quot;&gt;&#xA;   &lt;file name=&quot;index.html&quot;&gt;&#xA;    &lt;script&gt;&#xA;      angular.module(&apos;compileExample&apos;, [], function($compileProvider) {&#xA;        // configure new &apos;compile&apos; directive by passing a directive&#xA;        // factory function. The factory function injects the &apos;$compile&apos;&#xA;        $compileProvider.directive(&apos;compile&apos;, function($compile) {&#xA;          // directive factory creates a link function&#xA;          return function(scope, element, attrs) {&#xA;            scope.$watch(&#xA;              function(scope) {&#xA;                 // watch the &apos;compile&apos; expression for changes&#xA;                return scope.$eval(attrs.compile);&#xA;              },&#xA;              function(value) {&#xA;                // when the &apos;compile&apos; expression changes&#xA;                // assign it into the current DOM&#xA;                element.html(value);&#xA;&#xA;                // compile the new DOM and link it to the current&#xA;                // scope.&#xA;                // NOTE: we only compile .childNodes so that&#xA;                // we don&apos;t get into infinite loop compiling ourselves&#xA;                $compile(element.contents())(scope);&#xA;              }&#xA;            );&#xA;          };&#xA;        });&#xA;      })&#xA;      .controller(&apos;GreeterController&apos;, [&apos;$scope&apos;, function($scope) {&#xA;        $scope.name = &apos;Angular&apos;;&#xA;        $scope.html = &apos;Hello {{name}}&apos;;&#xA;      }]);&#xA;    &lt;/script&gt;&#xA;    &lt;div ng-controller=&quot;GreeterController&quot;&gt;&#xA;      &lt;input ng-model=&quot;name&quot;&gt; &lt;br/&gt;&#xA;      &lt;textarea ng-model=&quot;html&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;&#xA;      &lt;div compile=&quot;html&quot;&gt;&lt;/div&gt;&#xA;    &lt;/div&gt;&#xA;   &lt;/file&gt;&#xA;   &lt;file name=&quot;protractor.js&quot; type=&quot;protractor&quot;&gt;&#xA;     it(&apos;should auto compile&apos;, function() {&#xA;       var textarea = $(&apos;textarea&apos;);&#xA;       var output = $(&apos;div[compile]&apos;);&#xA;       // The initial state reads &apos;Hello Angular&apos;.&#xA;       expect(output.getText()).toBe(&apos;Hello Angular&apos;);&#xA;       textarea.clear();&#xA;       textarea.sendKeys(&apos;{{name}}!&apos;);&#xA;       expect(output.getText()).toBe(&apos;Angular!&apos;);&#xA;     });&#xA;   &lt;/file&gt;&#xA; &lt;/example&gt;&#xA;*" ilk="class" name="$compile">
        <scope ilk="namespace" name="directive">
          <scope ilk="class" name="Attributes">
            <scope doc="Adds the CSS class value specified by the classVal parameter to the element. If animations&#xA;are enabled then an animation will be triggered for the class addition.&#xA;" ilk="function" name="$addClass" signature="$addClass()" />
            <scope doc="Converts an attribute name (e.g. dash/colon/underscore-delimited string, optionally prefixed with `x-` or&#xA;`data-`) to its normalized, camelCase form.&#xA;* Also there is special case for Moz prefix starting with upper case letter.&#xA;* For further information check out the guide on {@link guide/directive#matching-directives Matching Directives}&#xA;" ilk="function" name="$normalize" signature="$normalize()" />
            <scope doc="Observes an interpolated attribute.&#xA;* The observer function will be invoked once during the next `$digest` following&#xA;compilation. The observer is then invoked whenever the interpolated value&#xA;changes.&#xA;" ilk="function" name="$observe" returns="function()" signature="$observe(key) =&gt; function()">
              <variable citdl="string" doc="Normalized key. (ie ngAttribute) ." ilk="argument" name="key" />
            </scope>
            <scope doc="Removes the CSS class value specified by the classVal parameter from the element. If&#xA;animations are enabled then an animation will be triggered for the class removal.&#xA;" ilk="function" name="$removeClass" signature="$removeClass()" />
            <scope doc="Set DOM element attribute value.&#xA;*" ilk="function" name="$set" signature="$set()" />
            <scope doc="Adds and removes the appropriate CSS class values to the element based on the difference&#xA;between the new and old CSS class values (specified as newClasses and oldClasses).&#xA;" ilk="function" name="$updateClass" signature="$updateClass(newClasses)">
              <variable citdl="string" doc="The current CSS className value" ilk="argument" name="newClasses" />
            </scope>
            <variable name="$attr" />
          </scope>
        </scope>
      </scope>
      <scope ilk="class" name="$controller" />
      <scope doc="A {@link angular.element jQuery or jqLite} wrapper for the browser&apos;s `window.document` object.&#xA;" ilk="class" name="$document" />
      <scope doc="Any uncaught exception in angular expressions is delegated to this service.&#xA;The default implementation simply delegates to `$log.error` which logs it into&#xA;the browser console.&#xA;* In unit tests, if `angular-mocks.js` is loaded, this service is overridden by&#xA;{@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.&#xA;* ## Example:&#xA;* ```js&#xA;angular.module(&apos;exceptionOverride&apos;, []).factory(&apos;$exceptionHandler&apos;, function() {&#xA;return function(exception, cause) {&#xA;exception.message += &apos; (caused by &quot;&apos; + cause + &apos;&quot;)&apos;;&#xA;throw exception;&#xA;};&#xA;});&#xA;```&#xA;* This example will override the normal action of `$exceptionHandler`, to make angular&#xA;exceptions fail hard when they happen, instead of just logging to the console.&#xA;* &lt;hr /&gt;&#xA;Note, that code executed in event-listeners (even those registered using jqLite&apos;s `on`/`bind`&#xA;methods) does not delegate exceptions to the {@link ng.$exceptionHandler $exceptionHandler}&#xA;(unless executed during a digest).&#xA;* If you wish, you can manually delegate exceptions, e.g.&#xA;`try { ... } catch(e) { $exceptionHandler(e); }`&#xA;" ilk="class" name="$exceptionHandler" />
      <scope doc="Filters are used for formatting data displayed to the user.&#xA;* The general syntax in templates is as follows:&#xA;*         {{ expression [| filter_name[:parameter_value] ... ] }}&#xA;" ilk="class" name="$filter" />
      <scope doc="The `$http` service is a core Angular service that facilitates communication with the remote&#xA;HTTP servers via the browser's [XMLHttpRequest](https://developer.mozilla.org/en/xmlhttprequest)&#xA;object or via [JSONP](http://en.wikipedia.org/wiki/JSONP).&#xA;* For unit testing applications that use `$http` service, see&#xA;{@link ngMock.$httpBackend $httpBackend mock}.&#xA;* For a higher level of abstraction, please check out the {@link ngResource.$resource&#xA;$resource} service.&#xA;* The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by&#xA;the $q service. While for simple usage patterns this doesn't matter much, for advanced usage&#xA;it is important to familiarize yourself with these APIs and the guarantees they provide.&#xA;*&#xA;## General usage&#xA;The `$http` service is a function which takes a single argument &#226;&#128;&#148; a {@link $http#usage configuration object} &#226;&#128;&#148;&#xA;that is used to generate an HTTP request and returns  a {@link ng.$q promise}.&#xA;* ```js&#xA;// Simple GET request example:&#xA;$http({&#xA;method: 'GET',&#xA;url: '/someUrl'&#xA;}).then(function successCallback(response) {&#xA;// this callback will be called asynchronously&#xA;// when the response is available&#xA;}, function errorCallback(response) {&#xA;// called asynchronously if an error occurs&#xA;// or server returns response with an error status.&#xA;});&#xA;```&#xA;* The response object has these properties:&#xA;*   - **data** &#226;&#128;&#147; `{string|Object}` &#226;&#128;&#147; The response body transformed with the transform&#xA;functions.&#xA;- **status** &#226;&#128;&#147; `{number}` &#226;&#128;&#147; HTTP status code of the response.&#xA;- **headers** &#226;&#128;&#147; `{function([headerName])}` &#226;&#128;&#147; Header getter function.&#xA;- **config** &#226;&#128;&#147; `{Object}` &#226;&#128;&#147; The configuration object that was used to generate the request.&#xA;- **statusText** &#226;&#128;&#147; `{string}` &#226;&#128;&#147; HTTP status text of the response.&#xA;* A response status code between 200 and 299 is considered a success status and&#xA;will result in the success callback being called. Note that if the response is a redirect,&#xA;XMLHttpRequest will transparently follow it, meaning that the error callback will not be&#xA;called for such responses.&#xA;*&#xA;## Shortcut methods&#xA;* Shortcut methods are also available. All shortcut methods require passing in the URL, and&#xA;request data must be passed in for POST/PUT requests. An optional config can be passed as the&#xA;last argument.&#xA;* ```js&#xA;$http.get('/someUrl', config).then(successCallback, errorCallback);&#xA;$http.post('/someUrl', data, config).then(successCallback, errorCallback);&#xA;```&#xA;* Complete list of shortcut methods:&#xA;* - {@link ng.$http#get $http.get}&#xA;- {@link ng.$http#head $http.head}&#xA;- {@link ng.$http#post $http.post}&#xA;- {@link ng.$http#put $http.put}&#xA;- {@link ng.$http#delete $http.delete}&#xA;- {@link ng.$http#jsonp $http.jsonp}&#xA;- {@link ng.$http#patch $http.patch}&#xA;*&#xA;## Writing Unit Tests that use $http&#xA;When unit testing (using {@link ngMock ngMock}), it is necessary to call&#xA;{@link ngMock.$httpBackend#flush $httpBackend.flush()} to flush each pending&#xA;request using trained responses.&#xA;* ```&#xA;$httpBackend.expectGET(...);&#xA;$http.get(...);&#xA;$httpBackend.flush();&#xA;```&#xA;* ## Deprecation Notice&#xA;&lt;div class=&quot;alert alert-danger&quot;&gt;&#xA;The `$http` legacy promise methods `success` and `error` have been deprecated.&#xA;Use the standard `then` method instead.&#xA;If {@link $httpProvider#useLegacyPromiseExtensions `$httpProvider.useLegacyPromiseExtensions`} is set to&#xA;`false` then these methods will throw {@link $http:legacy `$http/legacy`} error.&#xA;&lt;/div&gt;&#xA;* ## Setting HTTP Headers&#xA;* The $http service will automatically add certain HTTP headers to all requests. These defaults&#xA;can be fully configured by accessing the `$httpProvider.defaults.headers` configuration&#xA;object, which currently contains this default configuration:&#xA;* - `$httpProvider.defaults.headers.common` (headers that are common for all requests):&#xA;- `Accept: application/json, text/plain, * / *`&#xA;- `$httpProvider.defaults.headers.post`: (header defaults for POST requests)&#xA;- `Content-Type: application/json`&#xA;- `$httpProvider.defaults.headers.put` (header defaults for PUT requests)&#xA;- `Content-Type: application/json`&#xA;* To add or overwrite these defaults, simply add or remove a property from these configuration&#xA;objects. To add headers for an HTTP method other than POST or PUT, simply add a new object&#xA;with the lowercased HTTP method name as the key, e.g.&#xA;`$httpProvider.defaults.headers.get = { 'My-Header' : 'value' }`.&#xA;* The defaults can also be set at runtime via the `$http.defaults` object in the same&#xA;fashion. For example:&#xA;* ```&#xA;module.run(function($http) {&#xA;$http.defaults.headers.common.Authorization = 'Basic YmVlcDpib29w'&#xA;});&#xA;```&#xA;* In addition, you can supply a `headers` property in the config object passed when&#xA;calling `$http(config)`, which overrides the defaults without changing them globally.&#xA;* To explicitly remove a header automatically added via $httpProvider.defaults.headers on a per request basis,&#xA;Use the `headers` property, setting the desired header to `undefined`. For example:&#xA;* ```js&#xA;var req = {&#xA;method: 'POST',&#xA;url: 'http://example.com',&#xA;headers: {&#xA;'Content-Type': undefined&#xA;},&#xA;data: { test: 'test' }&#xA;}&#xA;* $http(req).then(function(){...}, function(){...});&#xA;```&#xA;* ## Transforming Requests and Responses&#xA;* Both requests and responses can be transformed using transformation functions: `transformRequest`&#xA;and `transformResponse`. These properties can be a single function that returns&#xA;the transformed value (`function(data, headersGetter, status)`) or an array of such transformation functions,&#xA;which allows you to `push` or `unshift` a new transformation function into the transformation chain.&#xA;* ### Default Transformations&#xA;* The `$httpProvider` provider and `$http` service expose `defaults.transformRequest` and&#xA;`defaults.transformResponse` properties. If a request does not provide its own transformations&#xA;then these will be applied.&#xA;* You can augment or replace the default transformations by modifying these properties by adding to or&#xA;replacing the array.&#xA;* Angular provides the following default transformations:&#xA;* Request transformations (`$httpProvider.defaults.transformRequest` and `$http.defaults.transformRequest`):&#xA;* - If the `data` property of the request configuration object contains an object, serialize it&#xA;into JSON format.&#xA;* Response transformations (`$httpProvider.defaults.transformResponse` and `$http.defaults.transformResponse`):&#xA;*  - If XSRF prefix is detected, strip it (see Security Considerations section below).&#xA;- If JSON response is detected, deserialize it using a JSON parser.&#xA;*&#xA;### Overriding the Default Transformations Per Request&#xA;* If you wish override the request/response transformations only for a single request then provide&#xA;`transformRequest` and/or `transformResponse` properties on the configuration object passed&#xA;into `$http`.&#xA;* Note that if you provide these properties on the config object the default transformations will be&#xA;overwritten. If you wish to augment the default transformations then you must include them in your&#xA;local transformation array.&#xA;* The following code demonstrates adding a new response transformation to be run after the default response&#xA;transformations have been run.&#xA;* ```js&#xA;function appendTransform(defaults, transform) {&#xA;*   // We can't guarantee that the default transformation is an array&#xA;defaults = angular.isArray(defaults) ? defaults : [defaults];&#xA;*   // Append the new transformation to the defaults&#xA;return defaults.concat(transform);&#xA;}&#xA;* $http({&#xA;url: '...',&#xA;method: 'GET',&#xA;transformResponse: appendTransform($http.defaults.transformResponse, function(value) {&#xA;return doTransform(value);&#xA;})&#xA;});&#xA;```&#xA;*&#xA;## Caching&#xA;* To enable caching, set the request configuration `cache` property to `true` (to use default&#xA;cache) or to a custom cache object (built with {@link ng.$cacheFactory `$cacheFactory`}).&#xA;When the cache is enabled, `$http` stores the response from the server in the specified&#xA;cache. The next time the same request is made, the response is served from the cache without&#xA;sending a request to the server.&#xA;* Note that even if the response is served from cache, delivery of the data is asynchronous in&#xA;the same way that real requests are.&#xA;* If there are multiple GET requests for the same URL that should be cached using the same&#xA;cache, but the cache is not populated yet, only one request to the server will be made and&#xA;the remaining requests will be fulfilled using the response from the first request.&#xA;* You can change the default cache to a new object (built with&#xA;{@link ng.$cacheFactory `$cacheFactory`}) by updating the&#xA;{@link ng.$http#defaults `$http.defaults.cache`} property. All requests who set&#xA;their `cache` property to `true` will now use this cache object.&#xA;* If you set the default cache to `false` then only requests that specify their own custom&#xA;cache object will be cached.&#xA;* ## Interceptors&#xA;* Before you start creating interceptors, be sure to understand the&#xA;{@link ng.$q $q and deferred/promise APIs}.&#xA;* For purposes of global error handling, authentication, or any kind of synchronous or&#xA;asynchronous pre-processing of request or postprocessing of responses, it is desirable to be&#xA;able to intercept requests before they are handed to the server and&#xA;responses before they are handed over to the application code that&#xA;initiated these requests. The interceptors leverage the {@link ng.$q&#xA;promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.&#xA;* The interceptors are service factories that are registered with the `$httpProvider` by&#xA;adding them to the `$httpProvider.interceptors` array. The factory is called and&#xA;injected with dependencies (if specified) and returns the interceptor.&#xA;* There are two kinds of interceptors (and two kinds of rejection interceptors):&#xA;*   * `request`: interceptors get called with a http {@link $http#usage config} object. The function is free to&#xA;modify the `config` object or create a new one. The function needs to return the `config`&#xA;object directly, or a promise containing the `config` or a new `config` object.&#xA;* `requestError`: interceptor gets called when a previous interceptor threw an error or&#xA;resolved with a rejection.&#xA;* `response`: interceptors get called with http `response` object. The function is free to&#xA;modify the `response` object or create a new one. The function needs to return the `response`&#xA;object directly, or as a promise containing the `response` or a new `response` object.&#xA;* `responseError`: interceptor gets called when a previous interceptor threw an error or&#xA;resolved with a rejection.&#xA;*&#xA;```js&#xA;// register the interceptor as a service&#xA;$provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {&#xA;return {&#xA;// optional method&#xA;'request': function(config) {&#xA;// do something on success&#xA;return config;&#xA;},&#xA;*       // optional method&#xA;'requestError': function(rejection) {&#xA;// do something on error&#xA;if (canRecover(rejection)) {&#xA;return responseOrNewPromise&#xA;}&#xA;return $q.reject(rejection);&#xA;},&#xA;*&#xA;*       // optional method&#xA;'response': function(response) {&#xA;// do something on success&#xA;return response;&#xA;},&#xA;*       // optional method&#xA;'responseError': function(rejection) {&#xA;// do something on error&#xA;if (canRecover(rejection)) {&#xA;return responseOrNewPromise&#xA;}&#xA;return $q.reject(rejection);&#xA;}&#xA;};&#xA;});&#xA;*   $httpProvider.interceptors.push('myHttpInterceptor');&#xA;*&#xA;// alternatively, register the interceptor via an anonymous factory&#xA;$httpProvider.interceptors.push(function($q, dependency1, dependency2) {&#xA;return {&#xA;'request': function(config) {&#xA;// same as above&#xA;},&#xA;*       'response': function(response) {&#xA;// same as above&#xA;}&#xA;};&#xA;});&#xA;```&#xA;* ## Security Considerations&#xA;* When designing web applications, consider security threats from:&#xA;* - [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)&#xA;- [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery)&#xA;* Both server and the client must cooperate in order to eliminate these threats. Angular comes&#xA;pre-configured with strategies that address these issues, but for this to work backend server&#xA;cooperation is required.&#xA;* ### JSON Vulnerability Protection&#xA;* A [JSON vulnerability](http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx)&#xA;allows third party website to turn your JSON resource URL into&#xA;[JSONP](http://en.wikipedia.org/wiki/JSONP) request under some conditions. To&#xA;counter this your server can prefix all JSON requests with following string `&quot;)]}',\n&quot;`.&#xA;Angular will automatically strip the prefix before processing it as JSON.&#xA;* For example if your server needs to return:&#xA;```js&#xA;['one','two']&#xA;```&#xA;* which is vulnerable to attack, your server can return:&#xA;```js&#xA;)]}',&#xA;['one','two']&#xA;```&#xA;* Angular will strip the prefix, before processing the JSON.&#xA;*&#xA;### Cross Site Request Forgery (XSRF) Protection&#xA;* [XSRF](http://en.wikipedia.org/wiki/Cross-site_request_forgery) is a technique by which&#xA;an unauthorized site can gain your user's private data. Angular provides a mechanism&#xA;to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie&#xA;(by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only&#xA;JavaScript that runs on your domain could read the cookie, your server can be assured that&#xA;the XHR came from JavaScript running on your domain. The header will not be set for&#xA;cross-domain requests.&#xA;* To take advantage of this, your server needs to set a token in a JavaScript readable session&#xA;cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the&#xA;server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure&#xA;that only JavaScript running on your domain could have sent the request. The token must be&#xA;unique for each user and must be verifiable by the server (to prevent the JavaScript from&#xA;making up its own tokens). We recommend that the token is a digest of your site's&#xA;authentication cookie with a [salt](https://en.wikipedia.org/wiki/Salt_(cryptography&amp;#41;)&#xA;for added security.&#xA;* The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName&#xA;properties of either $httpProvider.defaults at config-time, $http.defaults at run-time,&#xA;or the per-request config object.&#xA;* In order to prevent collisions in environments where multiple Angular apps share the&#xA;same domain or subdomain, we recommend that each application uses unique cookie name.&#xA;" ilk="class" name="$http">
        <scope doc="Shortcut method to perform `DELETE` request.&#xA;" ilk="function" name="delete" returns="HttpPromise" signature="delete(url) =&gt; HttpPromise">
          <variable citdl="string" doc="Relative or absolute URL specifying the destination of the request" ilk="argument" name="url" />
        </scope>
        <scope doc="Shortcut method to perform `GET` request.&#xA;" ilk="function" name="get" returns="HttpPromise" signature="get(url) =&gt; HttpPromise">
          <variable citdl="string" doc="Relative or absolute URL specifying the destination of the request" ilk="argument" name="url" />
        </scope>
        <scope doc="Shortcut method to perform `HEAD` request.&#xA;" ilk="function" name="head" returns="HttpPromise" signature="head(url) =&gt; HttpPromise">
          <variable citdl="string" doc="Relative or absolute URL specifying the destination of the request" ilk="argument" name="url" />
        </scope>
        <scope doc="Shortcut method to perform `JSONP` request.&#xA;" ilk="function" name="jsonp" returns="HttpPromise" signature="jsonp(config) =&gt; HttpPromise">
          <variable citdl="Object=" doc="Optional configuration object" ilk="argument" name="config" />
        </scope>
        <scope doc="Shortcut method to perform `PATCH` request.&#xA;" ilk="function" name="patch" returns="HttpPromise" signature="patch(url,config) =&gt; HttpPromise">
          <variable citdl="string" doc="Relative or absolute URL specifying the destination of the request" ilk="argument" name="url" />
          <variable citdl="Object=" doc="Optional configuration object" ilk="argument" name="config" />
        </scope>
        <scope doc="Shortcut method to perform `POST` request.&#xA;" ilk="function" name="post" returns="HttpPromise" signature="post(url,config) =&gt; HttpPromise">
          <variable citdl="string" doc="Relative or absolute URL specifying the destination of the request" ilk="argument" name="url" />
          <variable citdl="Object=" doc="Optional configuration object" ilk="argument" name="config" />
        </scope>
        <scope doc="Shortcut method to perform `PUT` request.&#xA;" ilk="function" name="put" returns="HttpPromise" signature="put(url,config) =&gt; HttpPromise">
          <variable citdl="string" doc="Relative or absolute URL specifying the destination of the request" ilk="argument" name="url" />
          <variable citdl="Object=" doc="Optional configuration object" ilk="argument" name="config" />
        </scope>
        <variable name="defaults" />
      </scope>
      <scope ilk="class" name="$httpBackend" />
      <scope ilk="class" name="$httpParamSerializer" />
      <scope ilk="class" name="$httpParamSerializerJQLike" />
      <scope ilk="class" name="$injector">
        <scope doc="Returns an array of service names which the function is requesting for injection. This API is&#xA;used by the injector to determine which services need to be injected into the function when the&#xA;function is invoked. There are three ways in which the function can be annotated with the needed&#xA;dependencies.&#xA;* # Argument names&#xA;* The simplest form is to extract the dependencies from the arguments of the function. This is done&#xA;by converting the function into a string using `toString()` method and extracting the argument&#xA;names.&#xA;```js&#xA;// Given&#xA;function MyController($scope, $route) {&#xA;// ...&#xA;}&#xA;*   // Then&#xA;expect(injector.annotate(MyController)).toEqual([&apos;$scope&apos;, &apos;$route&apos;]);&#xA;```&#xA;* You can disallow this method by using strict injection mode.&#xA;* This method does not work with code minification / obfuscation. For this reason the following&#xA;annotation strategies are supported.&#xA;* # The `$inject` property&#xA;* If a function has an `$inject` property and its value is an array of strings, then the strings&#xA;represent names of services to be injected into the function.&#xA;```js&#xA;// Given&#xA;var MyController = function(obfuscatedScope, obfuscatedRoute) {&#xA;// ...&#xA;}&#xA;// Define function dependencies&#xA;MyController[&apos;$inject&apos;] = [&apos;$scope&apos;, &apos;$route&apos;];&#xA;*   // Then&#xA;expect(injector.annotate(MyController)).toEqual([&apos;$scope&apos;, &apos;$route&apos;]);&#xA;```&#xA;* # The array notation&#xA;* It is often desirable to inline Injected functions and that&apos;s when setting the `$inject` property&#xA;is very inconvenient. In these situations using the array notation to specify the dependencies in&#xA;a way that survives minification is a better choice:&#xA;* ```js&#xA;// We wish to write this (not minification / obfuscation safe)&#xA;injector.invoke(function($compile, $rootScope) {&#xA;// ...&#xA;});&#xA;*   // We are forced to write break inlining&#xA;var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {&#xA;// ...&#xA;};&#xA;tmpFn.$inject = [&apos;$compile&apos;, &apos;$rootScope&apos;];&#xA;injector.invoke(tmpFn);&#xA;*   // To better support inline function the inline annotation is supported&#xA;injector.invoke([&apos;$compile&apos;, &apos;$rootScope&apos;, function(obfCompile, obfRootScope) {&#xA;// ...&#xA;}]);&#xA;*   // Therefore&#xA;expect(injector.annotate(&#xA;[&apos;$compile&apos;, &apos;$rootScope&apos;, function(obfus_$compile, obfus_$rootScope) {}])&#xA;).toEqual([&apos;$compile&apos;, &apos;$rootScope&apos;]);&#xA;```&#xA;" ilk="function" name="annotate" returns="Array.&lt;string&gt;" signature="annotate() =&gt; Array.&lt;string&gt;" />
        <scope doc="Return an instance of the service.&#xA;" ilk="function" name="get" signature="get(name)">
          <variable citdl="string" doc="The name of the instance to retrieve." ilk="argument" name="name" />
        </scope>
        <scope doc="Allows the user to query if the particular service exists.&#xA;" ilk="function" name="has" returns="boolean" signature="has(name) =&gt; boolean">
          <variable citdl="string" doc="Name of the service to query." ilk="argument" name="name" />
        </scope>
        <scope doc="Create a new instance of JS type. The method takes a constructor function, invokes the new&#xA;operator, and supplies all of the arguments to the constructor function as specified by the&#xA;constructor annotation.&#xA;" ilk="function" name="instantiate" returns="Object" signature="instantiate(Type) =&gt; Object">
          <variable citdl="Function" doc="Annotated constructor function." ilk="argument" name="Type" />
        </scope>
        <scope doc="Invoke the method and supply the method arguments from the `$injector`.&#xA;" ilk="function" name="invoke" returns="*" signature="invoke(self) =&gt; *">
          <variable citdl="Object=" doc="The `this` for the invoked method." ilk="argument" name="self" />
        </scope>
      </scope>
      <scope doc="* Compiles a string with markup into an interpolation function. This service is used by the&#xA;HTML {@link ng.$compile $compile} service for data binding. See&#xA;{@link ng.$interpolateProvider $interpolateProvider} for configuring the&#xA;interpolation markup.&#xA;*&#xA;```js&#xA;var $interpolate = ...; // injected&#xA;var exp = $interpolate(&apos;Hello {{name | uppercase}}!&apos;);&#xA;expect(exp({name:&apos;Angular&apos;})).toEqual(&apos;Hello ANGULAR!&apos;);&#xA;```&#xA;* `$interpolate` takes an optional fourth argument, `allOrNothing`. If `allOrNothing` is&#xA;`true`, the interpolation function will return `undefined` unless all embedded expressions&#xA;evaluate to a value other than `undefined`.&#xA;* ```js&#xA;var $interpolate = ...; // injected&#xA;var context = {greeting: &apos;Hello&apos;, name: undefined };&#xA;*   // default &quot;forgiving&quot; mode&#xA;var exp = $interpolate(&apos;{{greeting}} {{name}}!&apos;);&#xA;expect(exp(context)).toEqual(&apos;Hello !&apos;);&#xA;*   // &quot;allOrNothing&quot; mode&#xA;exp = $interpolate(&apos;{{greeting}} {{name}}!&apos;, false, null, true);&#xA;expect(exp(context)).toBeUndefined();&#xA;context.name = &apos;Angular&apos;;&#xA;expect(exp(context)).toEqual(&apos;Hello Angular!&apos;);&#xA;```&#xA;* `allOrNothing` is useful for interpolating URLs. `ngSrc` and `ngSrcset` use this behavior.&#xA;* ####Escaped Interpolation&#xA;$interpolate provides a mechanism for escaping interpolation markers. Start and end markers&#xA;can be escaped by preceding each of their characters with a REVERSE SOLIDUS U+005C (backslash).&#xA;It will be rendered as a regular start/end marker, and will not be interpreted as an expression&#xA;or binding.&#xA;* This enables web-servers to prevent script injection attacks and defacing attacks, to some&#xA;degree, while also enabling code examples to work without relying on the&#xA;{@link ng.directive:ngNonBindable ngNonBindable} directive.&#xA;* **For security purposes, it is strongly encouraged that web servers escape user-supplied data,&#xA;replacing angle brackets (&amp;lt;, &amp;gt;) with &amp;amp;lt; and &amp;amp;gt; respectively, and replacing all&#xA;interpolation start/end markers with their escaped counterparts.**&#xA;* Escaped interpolation markers are only replaced with the actual interpolation markers in rendered&#xA;output when the $interpolate service processes the text. So, for HTML elements interpolated&#xA;by {@link ng.$compile $compile}, or otherwise interpolated with the `mustHaveExpression` parameter&#xA;set to `true`, the interpolated text must contain an unescaped interpolation expression. As such,&#xA;this is typically useful only when user-data is used in rendering a template from the server, or&#xA;when otherwise untrusted data is used by a directive.&#xA;* &lt;example&gt;&#xA;&lt;file name=&quot;index.html&quot;&gt;&#xA;&lt;div ng-init=&quot;username=&apos;A user&apos;&quot;&gt;&#xA;&lt;p ng-init=&quot;apptitle=&apos;Escaping demo&apos;&quot;&gt;{{apptitle}}: \{\{ username = &quot;defaced value&quot;; \}\}&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;{{username}}&lt;/strong&gt; attempts to inject code which will deface the&#xA;application, but fails to accomplish their task, because the server has correctly&#xA;escaped the interpolation start/end markers with REVERSE SOLIDUS U+005C (backslash)&#xA;characters.&lt;/p&gt;&#xA;&lt;p&gt;Instead, the result of the attempted script injection is visible, and can be removed&#xA;from the database by an administrator.&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;&lt;/file&gt;&#xA;&lt;/example&gt;&#xA;" ilk="class" name="$interpolate">
        <scope doc="Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.&#xA;* Use {@link ng.$interpolateProvider#endSymbol `$interpolateProvider.endSymbol`} to change&#xA;the symbol.&#xA;" ilk="function" name="endSymbol" returns="string" signature="endSymbol() =&gt; string" />
        <scope doc="Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.&#xA;* Use {@link ng.$interpolateProvider#startSymbol `$interpolateProvider.startSymbol`} to change&#xA;the symbol.&#xA;" ilk="function" name="startSymbol" returns="string" signature="startSymbol() =&gt; string" />
      </scope>
      <scope doc="Angular&apos;s wrapper for `window.setInterval`. The `fn` function is executed every `delay`&#xA;milliseconds.&#xA;* The return value of registering an interval function is a promise. This promise will be&#xA;notified upon each tick of the interval, and will be resolved after `count` iterations, or&#xA;run indefinitely if `count` is not defined. The value of the notification will be the&#xA;number of iterations that have run.&#xA;To cancel an interval, call `$interval.cancel(promise)`.&#xA;* In tests you can use {@link ngMock.$interval#flush `$interval.flush(millis)`} to&#xA;move forward by `millis` milliseconds and trigger any functions scheduled to run in that&#xA;time.&#xA;* &lt;div class=&quot;alert alert-warning&quot;&gt;&#xA;**Note**: Intervals created by this service must be explicitly destroyed when you are finished&#xA;with them.  In particular they are not automatically destroyed when a controller&apos;s scope or a&#xA;directive&apos;s element are destroyed.&#xA;You should take this into consideration and make sure to always cancel the interval at the&#xA;appropriate moment.  See the example below for more details on how and when to do this.&#xA;&lt;/div&gt;&#xA;" ilk="class" name="$interval">
        <scope doc="Cancels a task associated with the `promise`.&#xA;" ilk="function" name="cancel" returns="boolean" signature="cancel(promise) =&gt; boolean">
          <variable citdl="Promise=" doc="returned by the `$interval` function." ilk="argument" name="promise" />
        </scope>
      </scope>
      <scope ilk="class" name="$locale" />
      <scope ilk="class" name="$location">
        <scope doc="This method is getter only.&#xA;* Return full url representation with all segments encoded according to rules specified in&#xA;[RFC 3986](http://www.ietf.org/rfc/rfc3986.txt).&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var absUrl = $location.absUrl();&#xA;// =&gt; &quot;http://example.com/#/some/path?foo=bar&amp;baz=xoxo&quot;&#xA;```&#xA;" ilk="function" name="absUrl" signature="absUrl()" />
        <scope doc="This method is getter / setter.&#xA;* Returns the hash fragment when called without any parameters.&#xA;* Changes the hash fragment when called with a parameter and returns `$location`.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo#hashValue&#xA;var hash = $location.hash();&#xA;// =&gt; &quot;hashValue&quot;&#xA;```&#xA;" ilk="function" name="hash" signature="hash(hash)">
          <variable citdl="(string|number)=" doc="New hash fragment" ilk="argument" name="hash" />
        </scope>
        <scope doc="This method is getter only.&#xA;* Return host of current url.&#xA;* Note: compared to the non-angular version `location.host` which returns `hostname:port`, this returns the `hostname` portion only.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var host = $location.host();&#xA;// =&gt; &quot;example.com&quot;&#xA;* // given url http://user:password@example.com:8080/#/some/path?foo=bar&amp;baz=xoxo&#xA;host = $location.host();&#xA;// =&gt; &quot;example.com&quot;&#xA;host = location.host;&#xA;// =&gt; &quot;example.com:8080&quot;&#xA;```&#xA;" ilk="function" name="host" signature="host()" />
        <scope doc="This method is getter / setter.&#xA;* Return path of current url when called without any parameter.&#xA;* Change path when called with parameter and return `$location`.&#xA;* Note: Path should always begin with forward slash (/), this method will add the forward slash&#xA;if it is missing.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var path = $location.path();&#xA;// =&gt; &quot;/some/path&quot;&#xA;```&#xA;" ilk="function" name="path" signature="path(path)">
          <variable citdl="(string|number)=" doc="New path" ilk="argument" name="path" />
        </scope>
        <scope doc="This method is getter only.&#xA;* Return port of current url.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var port = $location.port();&#xA;// =&gt; 80&#xA;```&#xA;" ilk="function" name="port" signature="port()" />
        <scope doc="This method is getter only.&#xA;* Return protocol of current url.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var protocol = $location.protocol();&#xA;// =&gt; &quot;http&quot;&#xA;```&#xA;" ilk="function" name="protocol" signature="protocol()" />
        <scope ilk="function" name="replace" signature="replace()" />
        <scope doc="This method is getter / setter.&#xA;* Return search part (as object) of current url when called without any parameter.&#xA;* Change search part when called with parameter and return `$location`.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var searchObject = $location.search();&#xA;// =&gt; {foo: &apos;bar&apos;, baz: &apos;xoxo&apos;}&#xA;* // set foo to &apos;yipee&apos;&#xA;$location.search(&apos;foo&apos;, &apos;yipee&apos;);&#xA;// $location.search() =&gt; {foo: &apos;yipee&apos;, baz: &apos;xoxo&apos;}&#xA;```&#xA;" ilk="function" name="search" signature="search()" />
        <scope doc="This method is getter / setter.&#xA;* Return the history state object when called without any parameter.&#xA;* Change the history state object when called with one parameter and return `$location`.&#xA;The state object is later passed to `pushState` or `replaceState`.&#xA;* NOTE: This method is supported only in HTML5 mode and only in browsers supporting&#xA;the HTML5 History API (i.e. methods `pushState` and `replaceState`). If you need to support&#xA;older browsers (like IE9 or Android &lt; 4.0), don&apos;t use this method.&#xA;" ilk="function" name="state" signature="state(state)">
          <variable citdl="object=" doc="State object for pushState or replaceState" ilk="argument" name="state" />
        </scope>
        <scope doc="This method is getter / setter.&#xA;* Return url (e.g. `/path?a=b#hash`) when called without any parameter.&#xA;* Change path, search and hash, when called with parameter and return `$location`.&#xA;*&#xA;```js&#xA;// given url http://example.com/#/some/path?foo=bar&amp;baz=xoxo&#xA;var url = $location.url();&#xA;// =&gt; &quot;/some/path?foo=bar&amp;baz=xoxo&quot;&#xA;```&#xA;" ilk="function" name="url" signature="url(url)">
          <variable citdl="string=" doc="New url without base prefix (e.g. `/path?a=b#hash`)" ilk="argument" name="url" />
        </scope>
      </scope>
      <scope doc="Simple service for logging. Default implementation safely writes the message&#xA;into the browser&apos;s console (if present).&#xA;* The main purpose of this service is to simplify debugging and troubleshooting.&#xA;* The default is to log `debug` messages. You can use&#xA;{@link ng.$logProvider ng.$logProvider#debugEnabled} to change this.&#xA;" ilk="class" name="$log">
        <scope ilk="function" name="debug" signature="debug()" />
        <scope ilk="function" name="error" signature="error()" />
        <scope ilk="function" name="info" signature="info()" />
        <scope ilk="function" name="log" signature="log()" />
        <scope ilk="function" name="warn" signature="warn()" />
      </scope>
      <scope doc="* Converts Angular {@link guide/expression expression} into a function.&#xA;* ```js&#xA;var getter = $parse(&apos;user.name&apos;);&#xA;var setter = getter.assign;&#xA;var context = {user:{name:&apos;angular&apos;}};&#xA;var locals = {user:{name:&apos;local&apos;}};&#xA;*   expect(getter(context)).toEqual(&apos;angular&apos;);&#xA;setter(context, &apos;newValue&apos;);&#xA;expect(context.user.name).toEqual(&apos;newValue&apos;);&#xA;expect(getter(context, locals)).toEqual(&apos;local&apos;);&#xA;```&#xA;*" ilk="class" name="$parse" />
      <scope ilk="class" name="$provide">
        <scope doc="* Register a **constant service**, such as a string, a number, an array, an object or a function,&#xA;with the {@link auto.$injector $injector}. Unlike {@link auto.$provide#value value} it can be&#xA;injected into a module configuration function (see {@link angular.Module#config}) and it cannot&#xA;be overridden by an Angular {@link auto.$provide#decorator decorator}.&#xA;" ilk="function" name="constant" returns="Object" signature="constant(name) =&gt; Object">
          <variable citdl="string" doc="The name of the constant." ilk="argument" name="name" />
        </scope>
        <scope doc="* Register a **service decorator** with the {@link auto.$injector $injector}. A service decorator&#xA;intercepts the creation of a service, allowing it to override or modify the behavior of the&#xA;service. The object returned by the decorator may be the original service, or a new service&#xA;object which replaces or wraps and delegates to the original service.&#xA;" ilk="function" name="decorator" signature="decorator(name)">
          <variable citdl="string" doc="The name of the service to decorate." ilk="argument" name="name" />
        </scope>
        <scope doc="* Register a **service factory**, which will be called to return the service instance.&#xA;This is short for registering a service where its provider consists of only a `$get` property,&#xA;which is the given service factory function.&#xA;You should use {@link auto.$provide#factory $provide.factory(getFn)} if you do not need to&#xA;configure your service in a provider.&#xA;" ilk="function" name="factory" returns="Object" signature="factory(name) =&gt; Object">
          <variable citdl="string" doc="The name of the instance." ilk="argument" name="name" />
        </scope>
        <scope doc="* Register a **provider function** with the {@link auto.$injector $injector}. Provider functions&#xA;are constructor functions, whose instances are responsible for &quot;providing&quot; a factory for a&#xA;service.&#xA;* Service provider names start with the name of the service they provide followed by `Provider`.&#xA;For example, the {@link ng.$log $log} service has a provider called&#xA;{@link ng.$logProvider $logProvider}.&#xA;* Service provider objects can have additional methods which allow configuration of the provider&#xA;and its service. Importantly, you can configure what kind of service is created by the `$get`&#xA;method, or how that service will act. For example, the {@link ng.$logProvider $logProvider} has a&#xA;method {@link ng.$logProvider#debugEnabled debugEnabled}&#xA;which lets you specify whether the {@link ng.$log $log} service will log debug messages to the&#xA;console or not.&#xA;" ilk="function" name="provider" returns="Object" signature="provider() =&gt; Object" />
        <scope doc="* Register a **service constructor**, which will be invoked with `new` to create the service&#xA;instance.&#xA;This is short for registering a service where its provider&apos;s `$get` property is the service&#xA;constructor function that will be used to instantiate the service instance.&#xA;* You should use {@link auto.$provide#service $provide.service(class)} if you define your service&#xA;as a type/class.&#xA;" ilk="function" name="service" returns="Object" signature="service(name) =&gt; Object">
          <variable citdl="string" doc="The name of the instance." ilk="argument" name="name" />
        </scope>
        <scope doc="* Register a **value service** with the {@link auto.$injector $injector}, such as a string, a&#xA;number, an array, an object or a function.  This is short for registering a service where its&#xA;provider&apos;s `$get` property is a factory function that takes no arguments and returns the **value&#xA;service**.&#xA;* Value services are similar to constant services, except that they cannot be injected into a&#xA;module configuration function (see {@link angular.Module#config}) but they can be overridden by&#xA;an Angular&#xA;{@link auto.$provide#decorator decorator}.&#xA;" ilk="function" name="value" returns="Object" signature="value(name) =&gt; Object">
          <variable citdl="string" doc="The name of the instance." ilk="argument" name="name" />
        </scope>
      </scope>
      <scope doc="A service that helps you run functions asynchronously, and use their return values (or exceptions)&#xA;when they are done processing.&#xA;* This is an implementation of promises/deferred objects inspired by&#xA;[Kris Kowal's Q](https://github.com/kriskowal/q).&#xA;* $q can be used in two fashions --- one which is more similar to Kris Kowal's Q or jQuery's Deferred&#xA;implementations, and the other which resembles ES6 promises to some degree.&#xA;* # $q constructor&#xA;* The streamlined ES6 style promise is essentially just using $q as a constructor which takes a `resolver`&#xA;function as the first argument. This is similar to the native Promise implementation from ES6 Harmony,&#xA;see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).&#xA;* While the constructor-style use is supported, not all of the supporting methods from ES6 Harmony promises are&#xA;available yet.&#xA;* It can be used like so:&#xA;* ```js&#xA;// for the purpose of this example let's assume that variables `$q` and `okToGreet`&#xA;// are available in the current lexical scope (they could have been injected or passed in).&#xA;*   function asyncGreet(name) {&#xA;// perform some asynchronous operation, resolve or reject the promise when appropriate.&#xA;return $q(function(resolve, reject) {&#xA;setTimeout(function() {&#xA;if (okToGreet(name)) {&#xA;resolve('Hello, ' + name + '!');&#xA;} else {&#xA;reject('Greeting ' + name + ' is not allowed.');&#xA;}&#xA;}, 1000);&#xA;});&#xA;}&#xA;*   var promise = asyncGreet('Robin Hood');&#xA;promise.then(function(greeting) {&#xA;alert('Success: ' + greeting);&#xA;}, function(reason) {&#xA;alert('Failed: ' + reason);&#xA;});&#xA;```&#xA;* Note: progress/notify callbacks are not currently supported via the ES6-style interface.&#xA;* Note: unlike ES6 behaviour, an exception thrown in the constructor function will NOT implicitly reject the promise.&#xA;* However, the more traditional CommonJS-style usage is still available, and documented below.&#xA;* [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an&#xA;interface for interacting with an object that represents the result of an action that is&#xA;performed asynchronously, and may or may not be finished at any given point in time.&#xA;* From the perspective of dealing with error handling, deferred and promise APIs are to&#xA;asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.&#xA;* ```js&#xA;// for the purpose of this example let's assume that variables `$q` and `okToGreet`&#xA;// are available in the current lexical scope (they could have been injected or passed in).&#xA;*   function asyncGreet(name) {&#xA;var deferred = $q.defer();&#xA;*     setTimeout(function() {&#xA;deferred.notify('About to greet ' + name + '.');&#xA;*       if (okToGreet(name)) {&#xA;deferred.resolve('Hello, ' + name + '!');&#xA;} else {&#xA;deferred.reject('Greeting ' + name + ' is not allowed.');&#xA;}&#xA;}, 1000);&#xA;*     return deferred.promise;&#xA;}&#xA;*   var promise = asyncGreet('Robin Hood');&#xA;promise.then(function(greeting) {&#xA;alert('Success: ' + greeting);&#xA;}, function(reason) {&#xA;alert('Failed: ' + reason);&#xA;}, function(update) {&#xA;alert('Got notification: ' + update);&#xA;});&#xA;```&#xA;* At first it might not be obvious why this extra complexity is worth the trouble. The payoff&#xA;comes in the way of guarantees that promise and deferred APIs make, see&#xA;https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md.&#xA;* Additionally the promise api allows for composition that is very hard to do with the&#xA;traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.&#xA;For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the&#xA;section on serial or parallel joining of promises.&#xA;* # The Deferred API&#xA;* A new instance of deferred is constructed by calling `$q.defer()`.&#xA;* The purpose of the deferred object is to expose the associated Promise instance as well as APIs&#xA;that can be used for signaling the successful or unsuccessful completion, as well as the status&#xA;of the task.&#xA;* **Methods**&#xA;* - `resolve(value)` &#226;&#128;&#147; resolves the derived promise with the `value`. If the value is a rejection&#xA;constructed via `$q.reject`, the promise will be rejected instead.&#xA;- `reject(reason)` &#226;&#128;&#147; rejects the derived promise with the `reason`. This is equivalent to&#xA;resolving it with a rejection constructed via `$q.reject`.&#xA;- `notify(value)` - provides updates on the status of the promise's execution. This may be called&#xA;multiple times before the promise is either resolved or rejected.&#xA;* **Properties**&#xA;* - promise &#226;&#128;&#147; `{Promise}` &#226;&#128;&#147; promise object associated with this deferred.&#xA;*&#xA;# The Promise API&#xA;* A new promise instance is created when a deferred instance is created and can be retrieved by&#xA;calling `deferred.promise`.&#xA;* The purpose of the promise object is to allow for interested parties to get access to the result&#xA;of the deferred task when it completes.&#xA;* **Methods**&#xA;* - `then(successCallback, errorCallback, notifyCallback)` &#226;&#128;&#147; regardless of when the promise was or&#xA;will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously&#xA;as soon as the result is available. The callbacks are called with a single argument: the result&#xA;or rejection reason. Additionally, the notify callback may be called zero or more times to&#xA;provide a progress indication, before the promise is resolved or rejected.&#xA;*   This method *returns a new promise* which is resolved or rejected via the return value of the&#xA;`successCallback`, `errorCallback` (unless that value is a promise, in which case it is resolved&#xA;with the value which is resolved in that promise using&#xA;[promise chaining](http://www.html5rocks.com/en/tutorials/es6/promises/#toc-promises-queues)).&#xA;It also notifies via the return value of the `notifyCallback` method. The promise cannot be&#xA;resolved or rejected from the notifyCallback method.&#xA;* - `catch(errorCallback)` &#226;&#128;&#147; shorthand for `promise.then(null, errorCallback)`&#xA;* - `finally(callback, notifyCallback)` &#226;&#128;&#147; allows you to observe either the fulfillment or rejection of a promise,&#xA;but to do so without modifying the final value. This is useful to release resources or do some&#xA;clean-up that needs to be done whether the promise was rejected or resolved. See the [full&#xA;specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for&#xA;more information.&#xA;* # Chaining promises&#xA;* Because calling the `then` method of a promise returns a new derived promise, it is easily&#xA;possible to create a chain of promises:&#xA;* ```js&#xA;promiseB = promiseA.then(function(result) {&#xA;return result + 1;&#xA;});&#xA;*   // promiseB will be resolved immediately after promiseA is resolved and its value&#xA;// will be the result of promiseA incremented by 1&#xA;```&#xA;* It is possible to create chains of any length and since a promise can be resolved with another&#xA;promise (which will defer its resolution further), it is possible to pause/defer resolution of&#xA;the promises at any point in the chain. This makes it possible to implement powerful APIs like&#xA;$http's response interceptors.&#xA;*&#xA;# Differences between Kris Kowal's Q and $q&#xA;*  There are two main differences:&#xA;* - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation&#xA;mechanism in angular, which means faster propagation of resolution or rejection into your&#xA;models and avoiding unnecessary browser repaints, which would result in flickering UI.&#xA;- Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains&#xA;all the important functionality needed for common async tasks.&#xA;*  # Testing&#xA;*  ```js&#xA;it('should simulate promise', inject(function($q, $rootScope) {&#xA;var deferred = $q.defer();&#xA;var promise = deferred.promise;&#xA;var resolvedValue;&#xA;*      promise.then(function(value) { resolvedValue = value; });&#xA;expect(resolvedValue).toBeUndefined();&#xA;*      // Simulate resolving of promise&#xA;deferred.resolve(123);&#xA;// Note that the 'then' function does not get called synchronously.&#xA;// This is because we want the promise API to always be async, whether or not&#xA;// it got called synchronously or asynchronously.&#xA;expect(resolvedValue).toBeUndefined();&#xA;*      // Propagate promise resolution to 'then' functions using $apply().&#xA;$rootScope.$apply();&#xA;expect(resolvedValue).toEqual(123);&#xA;}));&#xA;```&#xA;" ilk="class" name="$q">
        <scope doc="Combines multiple promises into a single promise that is resolved when all of the input&#xA;promises are resolved.&#xA;" ilk="function" name="all" returns="Promise" signature="all(promises) =&gt; Promise">
          <variable citdl="Array.&lt;Promise&gt;|Object.&lt;Promise&gt;" doc="An array or hash of promises." ilk="argument" name="promises" />
        </scope>
        <scope doc="Creates a promise that is resolved as rejected with the specified `reason`. This api should be&#xA;used to forward rejection in a chain of promises. If you are dealing with the last promise in&#xA;a promise chain, you don&apos;t need to worry about it.&#xA;* When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of&#xA;`reject` as the `throw` keyword in JavaScript. This also means that if you &quot;catch&quot; an error via&#xA;a promise error callback and you want to forward the error to the promise derived from the&#xA;current promise, you have to &quot;rethrow&quot; the error by returning a rejection constructed via&#xA;`reject`.&#xA;* ```js&#xA;promiseB = promiseA.then(function(result) {&#xA;// success: do something and resolve promiseB&#xA;//          with the old or a new result&#xA;return result;&#xA;}, function(reason) {&#xA;// error: handle the error if possible and&#xA;//        resolve promiseB with newPromiseOrValue,&#xA;//        otherwise forward the rejection to promiseB&#xA;if (canHandle(reason)) {&#xA;// handle the error and recover&#xA;return newPromiseOrValue;&#xA;}&#xA;return $q.reject(reason);&#xA;});&#xA;```&#xA;" ilk="function" name="reject" returns="Promise" signature="reject(reason) =&gt; Promise">
          <variable citdl="*" doc="Constant, message, exception or an object representing the rejection reason." ilk="argument" name="reason" />
        </scope>
        <scope doc="Alias of {@link ng.$q#when when} to maintain naming consistency with ES6.&#xA;" ilk="function" name="resolve" returns="Promise" signature="resolve(value,errorCallback) =&gt; Promise">
          <variable citdl="*" doc="Value or a promise" ilk="argument" name="value" />
          <variable citdl="Function=" doc="* @param {Function=} progressCallback" ilk="argument" name="errorCallback" />
        </scope>
        <scope doc="Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.&#xA;This is useful when you are dealing with an object that might or might not be a promise, or if&#xA;the promise comes from a source that can&apos;t be trusted.&#xA;" ilk="function" name="when" returns="Promise" signature="when(value,errorCallback) =&gt; Promise">
          <variable citdl="*" doc="Value or a promise" ilk="argument" name="value" />
          <variable citdl="Function=" doc="* @param {Function=} progressCallback" ilk="argument" name="errorCallback" />
        </scope>
      </scope>
      <scope ilk="class" name="$rootElement" />
      <scope ilk="class" name="$rootScope">
        <scope doc="A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the&#xA;{@link auto.$injector $injector}. Child scopes are created using the&#xA;{@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when&#xA;compiled HTML template is executed.) See also the {@link guide/scope Scopes guide} for&#xA;an in-depth introduction and usage examples.&#xA;*&#xA;# Inheritance&#xA;A scope can inherit from a parent scope, as in this example:&#xA;```js&#xA;         var parent = $rootScope;&#xA;         var child = parent.$new();&#xA;&#xA;         parent.salutation = &quot;Hello&quot;;&#xA;         expect(child.salutation).toEqual(&apos;Hello&apos;);&#xA;&#xA;         child.salutation = &quot;Welcome&quot;;&#xA;         expect(child.salutation).toEqual(&apos;Welcome&apos;);&#xA;         expect(parent.salutation).toEqual(&apos;Hello&apos;);&#xA;```&#xA;* When interacting with `Scope` in tests, additional helper methods are available on the&#xA;instances of `Scope` type. See {@link ngMock.$rootScope.Scope ngMock Scope} for additional&#xA;details.&#xA;*" ilk="class" name="Scope">
          <scope doc="`$apply()` is used to execute an expression in angular from outside of the angular&#xA;framework. (For example from browser DOM events, setTimeout, XHR or third party libraries).&#xA;Because we are calling into the angular framework we need to perform proper scope life&#xA;cycle of {@link ng.$exceptionHandler exception handling},&#xA;{@link ng.$rootScope.Scope#$digest executing watches}.&#xA;* ## Life cycle&#xA;* # Pseudo-Code of `$apply()`&#xA;```js&#xA;           function $apply(expr) {&#xA;             try {&#xA;               return $eval(expr);&#xA;             } catch (e) {&#xA;               $exceptionHandler(e);&#xA;             } finally {&#xA;               $root.$digest();&#xA;             }&#xA;           }&#xA;```&#xA;*&#xA;Scope&apos;s `$apply()` method transitions through the following stages:&#xA;* 1. The {@link guide/expression expression} is executed using the&#xA;{@link ng.$rootScope.Scope#$eval $eval()} method.&#xA;2. Any exceptions from the execution of the expression are forwarded to the&#xA;{@link ng.$exceptionHandler $exceptionHandler} service.&#xA;3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the&#xA;expression was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.&#xA;*" ilk="function" name="$apply" returns="*" signature="$apply() =&gt; *" />
          <scope doc="Schedule the invocation of $apply to occur at a later time. The actual time difference&#xA;varies across browsers, but is typically around ~10 milliseconds.&#xA;* This can be used to queue up multiple expressions which need to be evaluated in the same&#xA;digest.&#xA;" ilk="function" name="$applyAsync" signature="$applyAsync()" />
          <scope doc="Dispatches an event `name` downwards to all child scopes (and their children) notifying the&#xA;registered {@link ng.$rootScope.Scope#$on} listeners.&#xA;* The event life cycle starts at the scope on which `$broadcast` was called. All&#xA;{@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get&#xA;notified. Afterwards, the event propagates to all direct and indirect scopes of the current&#xA;scope and calls all registered listeners along the way. The event cannot be canceled.&#xA;* Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed&#xA;onto the {@link ng.$exceptionHandler $exceptionHandler} service.&#xA;" ilk="function" name="$broadcast" signature="$broadcast(name)">
            <variable citdl="string" doc="Event name to broadcast." ilk="argument" name="name" />
          </scope>
          <scope ilk="function" name="$destroy" signature="$destroy()" />
          <scope ilk="function" name="$digest" signature="$digest()" />
          <scope doc="Dispatches an event `name` upwards through the scope hierarchy notifying the&#xA;registered {@link ng.$rootScope.Scope#$on} listeners.&#xA;* The event life cycle starts at the scope on which `$emit` was called. All&#xA;{@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get&#xA;notified. Afterwards, the event traverses upwards toward the root scope and calls all&#xA;registered listeners along the way. The event will stop propagating if one of the listeners&#xA;cancels it.&#xA;* Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed&#xA;onto the {@link ng.$exceptionHandler $exceptionHandler} service.&#xA;" ilk="function" name="$emit" signature="$emit(name)">
            <variable citdl="string" doc="Event name to emit." ilk="argument" name="name" />
          </scope>
          <scope doc="Executes the `expression` on the current scope and returns the result. Any exceptions in&#xA;the expression are propagated (uncaught). This is useful when evaluating Angular&#xA;expressions.&#xA;* # Example&#xA;```js&#xA;           var scope = ng.$rootScope.Scope();&#xA;           scope.a = 1;&#xA;           scope.b = 2;&#xA;&#xA;           expect(scope.$eval(&apos;a+b&apos;)).toEqual(3);&#xA;           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);&#xA;```&#xA;" ilk="function" name="$eval" returns="*" signature="$eval(locals) =&gt; *">
            <variable citdl="(object)=" doc="Local variables object, useful for overriding values in scope." ilk="argument" name="locals" />
          </scope>
          <scope doc="Executes the expression on the current scope at a later point in time.&#xA;* The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only&#xA;that:&#xA;*   - it will execute after the function that scheduled the evaluation (preferably before DOM&#xA;rendering).&#xA;- at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after&#xA;`expression` execution.&#xA;* Any exceptions from the execution of the expression are forwarded to the&#xA;{@link ng.$exceptionHandler $exceptionHandler} service.&#xA;* __Note:__ if this function is called outside of a `$digest` cycle, a new `$digest` cycle&#xA;will be scheduled. However, it is encouraged to always call code that changes the model&#xA;from within an `$apply` call. That includes code evaluated via `$evalAsync`.&#xA;" ilk="function" name="$evalAsync" signature="$evalAsync()" />
          <scope doc="Creates a new child {@link ng.$rootScope.Scope scope}.&#xA;* The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} event.&#xA;The scope can be removed from the scope hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.&#xA;* {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is&#xA;desired for the scope and its child scopes to be permanently detached from the parent and&#xA;thus stop participating in model change detection and listener notification by invoking.&#xA;" ilk="function" name="$new" returns="Object" signature="$new() =&gt; Object" />
          <scope doc="Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for&#xA;discussion of event life cycle.&#xA;* The event listener function format is: `function(event, args...)`. The `event` object&#xA;passed into the listener has the following attributes:&#xA;*   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or&#xA;`$broadcast`-ed.&#xA;- `currentScope` - `{Scope}`: the scope that is currently handling the event. Once the&#xA;event propagates through the scope hierarchy, this property is set to null.&#xA;- `name` - `{string}`: name of the event.&#xA;- `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel&#xA;further event propagation (available only for events that were `$emit`-ed).&#xA;- `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag&#xA;to true.&#xA;- `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.&#xA;" ilk="function" name="$on" returns="function()" signature="$on(name) =&gt; function()">
            <variable citdl="string" doc="Event name to listen on." ilk="argument" name="name" />
          </scope>
          <scope doc="Registers a `listener` callback to be executed whenever the `watchExpression` changes.&#xA;* - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest&#xA;$digest()} and should return the value that will be watched. (`watchExpression` should not change&#xA;its value when executed multiple times with the same input because it may be executed multiple&#xA;times by {@link ng.$rootScope.Scope#$digest $digest()}. That is, `watchExpression` should be&#xA;[idempotent](http://en.wikipedia.org/wiki/Idempotence).&#xA;- The `listener` is called only when the value from the current `watchExpression` and the&#xA;previous call to `watchExpression` are not equal (with the exception of the initial run,&#xA;see below). Inequality is determined according to reference inequality,&#xA;[strict comparison](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators)&#xA;via the `!==` Javascript operator, unless `objectEquality == true`&#xA;(see next point)&#xA;- When `objectEquality == true`, inequality of the `watchExpression` is determined&#xA;according to the {@link angular.equals} function. To save the value of the object for&#xA;later comparison, the {@link angular.copy} function is used. This therefore means that&#xA;watching complex objects will have adverse memory and performance implications.&#xA;- The watch `listener` may change the model, which may trigger other `listener`s to fire.&#xA;This is achieved by rerunning the watchers until no changes are detected. The rerun&#xA;iteration limit is 10 to prevent an infinite loop deadlock.&#xA;*&#xA;If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,&#xA;you can register a `watchExpression` function with no `listener`. (Be prepared for&#xA;multiple calls to your `watchExpression` because it will execute multiple times in a&#xA;single {@link ng.$rootScope.Scope#$digest $digest} cycle if a change is detected.)&#xA;* After a watcher is registered with the scope, the `listener` fn is called asynchronously&#xA;(via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the&#xA;watcher. In rare cases, this is undesirable because the listener is called when the result&#xA;of `watchExpression` didn&apos;t change. To detect this scenario within the `listener` fn, you&#xA;can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the&#xA;listener was called due to initialization.&#xA;*&#xA;* # Example&#xA;```js&#xA;           // let&apos;s assume that scope was dependency injected as the $rootScope&#xA;           var scope = $rootScope;&#xA;           scope.name = &apos;misko&apos;;&#xA;           scope.counter = 0;&#xA;&#xA;           expect(scope.counter).toEqual(0);&#xA;           scope.$watch(&apos;name&apos;, function(newValue, oldValue) {&#xA;             scope.counter = scope.counter + 1;&#xA;           });&#xA;           expect(scope.counter).toEqual(0);&#xA;&#xA;           scope.$digest();&#xA;           // the listener is always called during the first $digest loop after it was registered&#xA;           expect(scope.counter).toEqual(1);&#xA;&#xA;           scope.$digest();&#xA;           // but now it will not be called unless the value changes&#xA;           expect(scope.counter).toEqual(1);&#xA;&#xA;           scope.name = &apos;adam&apos;;&#xA;           scope.$digest();&#xA;           expect(scope.counter).toEqual(2);&#xA;&#xA;&#xA;&#xA;           // Using a function as a watchExpression&#xA;           var food;&#xA;           scope.foodCounter = 0;&#xA;           expect(scope.foodCounter).toEqual(0);&#xA;           scope.$watch(&#xA;             // This function returns the value being watched. It is called for each turn of the $digest loop&#xA;             function() { return food; },&#xA;             // This is the change listener, called when the value returned from the above function changes&#xA;             function(newValue, oldValue) {&#xA;               if ( newValue !== oldValue ) {&#xA;                 // Only increment the counter if the value changed&#xA;                 scope.foodCounter = scope.foodCounter + 1;&#xA;               }&#xA;             }&#xA;           );&#xA;           // No digest has been run so the counter will be zero&#xA;           expect(scope.foodCounter).toEqual(0);&#xA;&#xA;           // Run the digest but since food has not changed count will still be zero&#xA;           scope.$digest();&#xA;           expect(scope.foodCounter).toEqual(0);&#xA;&#xA;           // Update food and run digest.  Now the counter will increment&#xA;           food = &apos;cheeseburger&apos;;&#xA;           scope.$digest();&#xA;           expect(scope.foodCounter).toEqual(1);&#xA;```&#xA;*&#xA;" ilk="function" name="$watch" returns="function()" signature="$watch() =&gt; function()" />
          <scope doc="Shallow watches the properties of an object and fires whenever any of the properties change&#xA;(for arrays, this implies watching the array items; for object maps, this implies watching&#xA;the properties). If a change is detected, the `listener` callback is fired.&#xA;* - The `obj` collection is observed via standard $watch operation and is examined on every&#xA;call to $digest() to see if any items have been added, removed, or moved.&#xA;- The `listener` is called whenever anything within the `obj` has changed. Examples include&#xA;adding, removing, and moving items belonging to an object or array.&#xA;*&#xA;# Example&#xA;```js&#xA;          $scope.names = [&apos;igor&apos;, &apos;matias&apos;, &apos;misko&apos;, &apos;james&apos;];&#xA;          $scope.dataCount = 4;&#xA;&#xA;          $scope.$watchCollection(&apos;names&apos;, function(newNames, oldNames) {&#xA;            $scope.dataCount = newNames.length;&#xA;          });&#xA;&#xA;          expect($scope.dataCount).toEqual(4);&#xA;          $scope.$digest();&#xA;&#xA;          //still at 4 ... no changes&#xA;          expect($scope.dataCount).toEqual(4);&#xA;&#xA;          $scope.names.pop();&#xA;          $scope.$digest();&#xA;&#xA;          //now there&apos;s been a change&#xA;          expect($scope.dataCount).toEqual(3);&#xA;```&#xA;*" ilk="function" name="$watchCollection" returns="function()" signature="$watchCollection() =&gt; function()" />
          <scope doc="A variant of {@link ng.$rootScope.Scope#$watch $watch()} where it watches an array of `watchExpressions`.&#xA;If any one expression in the collection changes the `listener` is executed.&#xA;* - The items in the `watchExpressions` array are observed via standard $watch operation and are examined on every&#xA;call to $digest() to see if any items changes.&#xA;- The `listener` is called whenever any expression in the `watchExpressions` array changes.&#xA;" ilk="function" name="$watchGroup" returns="function()" signature="$watchGroup() =&gt; function()" />
          <variable name="$id" />
          <variable name="$parent" />
          <variable name="$root" />
        </scope>
      </scope>
      <scope ilk="class" name="$sce">
        <scope doc="Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such,&#xA;takes the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the&#xA;originally supplied value if the queried context type is a supertype of the created type.&#xA;If this condition isn&apos;t satisfied, throws an exception.&#xA;" ilk="function" name="getTrusted" returns="*" signature="getTrusted(type) =&gt; *">
          <variable citdl="string" doc="The kind of context in which this value is to be used." ilk="argument" name="type" />
        </scope>
        <scope doc="Shorthand method.  `$sce.getTrustedCss(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}&#xA;" ilk="function" name="getTrustedCss" returns="*" signature="getTrustedCss(value) =&gt; *">
          <variable citdl="*" doc="The value to pass to `$sce.getTrusted`." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.getTrustedHtml(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}&#xA;" ilk="function" name="getTrustedHtml" returns="*" signature="getTrustedHtml(value) =&gt; *">
          <variable citdl="*" doc="The value to pass to `$sce.getTrusted`." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.getTrustedJs(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}&#xA;" ilk="function" name="getTrustedJs" returns="*" signature="getTrustedJs(value) =&gt; *">
          <variable citdl="*" doc="The value to pass to `$sce.getTrusted`." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.getTrustedResourceUrl(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}&#xA;" ilk="function" name="getTrustedResourceUrl" returns="*" signature="getTrustedResourceUrl(value) =&gt; *">
          <variable citdl="*" doc="The value to pass to `$sceDelegate.getTrusted`." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.getTrustedUrl(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}&#xA;" ilk="function" name="getTrustedUrl" returns="*" signature="getTrustedUrl(value) =&gt; *">
          <variable citdl="*" doc="The value to pass to `$sce.getTrusted`." ilk="argument" name="value" />
        </scope>
        <scope ilk="function" name="isEnabled" signature="isEnabled()" />
        <scope doc="Converts Angular {@link guide/expression expression} into a function.  This is like {@link&#xA;ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it&#xA;wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,&#xA;*result*)}&#xA;" ilk="function" name="parseAs" returns="function(context, locals)" signature="parseAs(type) =&gt; function(context, locals)">
          <variable citdl="string" doc="The kind of SCE context in which this result will be used." ilk="argument" name="type" />
        </scope>
        <scope doc="Shorthand method.  `$sce.parseAsCss(value)` &#226;&#134;&#146;&#xA;{@link ng.$sce#parseAs `$sce.parseAs($sce.CSS, value)`}&#xA;" ilk="function" name="parseAsCss" returns="function(context, locals)" signature="parseAsCss(expression) =&gt; function(context, locals)">
          <variable citdl="string" doc="String expression to compile." ilk="argument" name="expression" />
        </scope>
        <scope doc="Shorthand method.  `$sce.parseAsHtml(expression string)` &#226;&#134;&#146;&#xA;{@link ng.$sce#parseAs `$sce.parseAs($sce.HTML, value)`}&#xA;" ilk="function" name="parseAsHtml" returns="function(context, locals)" signature="parseAsHtml(expression) =&gt; function(context, locals)">
          <variable citdl="string" doc="String expression to compile." ilk="argument" name="expression" />
        </scope>
        <scope doc="Shorthand method.  `$sce.parseAsJs(value)` &#226;&#134;&#146;&#xA;{@link ng.$sce#parseAs `$sce.parseAs($sce.JS, value)`}&#xA;" ilk="function" name="parseAsJs" returns="function(context, locals)" signature="parseAsJs(expression) =&gt; function(context, locals)">
          <variable citdl="string" doc="String expression to compile." ilk="argument" name="expression" />
        </scope>
        <scope doc="Shorthand method.  `$sce.parseAsResourceUrl(value)` &#226;&#134;&#146;&#xA;{@link ng.$sce#parseAs `$sce.parseAs($sce.RESOURCE_URL, value)`}&#xA;" ilk="function" name="parseAsResourceUrl" returns="function(context, locals)" signature="parseAsResourceUrl(expression) =&gt; function(context, locals)">
          <variable citdl="string" doc="String expression to compile." ilk="argument" name="expression" />
        </scope>
        <scope doc="Shorthand method.  `$sce.parseAsUrl(value)` &#226;&#134;&#146;&#xA;{@link ng.$sce#parseAs `$sce.parseAs($sce.URL, value)`}&#xA;" ilk="function" name="parseAsUrl" returns="function(context, locals)" signature="parseAsUrl(expression) =&gt; function(context, locals)">
          <variable citdl="string" doc="String expression to compile." ilk="argument" name="expression" />
        </scope>
        <scope doc="Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such,&#xA;returns an object that is trusted by angular for use in specified strict contextual&#xA;escaping contexts (such as ng-bind-html, ng-include, any src attribute&#xA;interpolation, any dom event binding attribute interpolation such as for onclick,  etc.)&#xA;that uses the provided value.  See * {@link ng.$sce $sce} for enabling strict contextual&#xA;escaping.&#xA;" ilk="function" name="trustAs" returns="*" signature="trustAs(value) =&gt; *">
          <variable citdl="*" doc="The value that that should be considered trusted/safe." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.trustAsHtml(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}&#xA;" ilk="function" name="trustAsHtml" returns="*" signature="trustAsHtml(value) =&gt; *">
          <variable citdl="*" doc="The value to trustAs." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.trustAsJs(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}&#xA;" ilk="function" name="trustAsJs" returns="*" signature="trustAsJs(value) =&gt; *">
          <variable citdl="*" doc="The value to trustAs." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.trustAsResourceUrl(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}&#xA;" ilk="function" name="trustAsResourceUrl" returns="*" signature="trustAsResourceUrl(value) =&gt; *">
          <variable citdl="*" doc="The value to trustAs." ilk="argument" name="value" />
        </scope>
        <scope doc="Shorthand method.  `$sce.trustAsUrl(value)` &#226;&#134;&#146;&#xA;{@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}&#xA;" ilk="function" name="trustAsUrl" returns="*" signature="trustAsUrl(value) =&gt; *">
          <variable citdl="*" doc="The value to trustAs." ilk="argument" name="value" />
        </scope>
      </scope>
      <scope ilk="class" name="$sceDelegate">
        <scope doc="Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and&#xA;returns the originally supplied value if the queried context type is a supertype of the&#xA;created type.  If this condition isn&apos;t satisfied, throws an exception.&#xA;" ilk="function" name="getTrusted" returns="*" signature="getTrusted(type) =&gt; *">
          <variable citdl="string" doc="The kind of context in which this value is to be used." ilk="argument" name="type" />
        </scope>
        <scope doc="Returns an object that is trusted by angular for use in specified strict&#xA;contextual escaping contexts (such as ng-bind-html, ng-include, any src&#xA;attribute interpolation, any dom event binding attribute interpolation&#xA;such as for onclick,  etc.) that uses the provided value.&#xA;See {@link ng.$sce $sce} for enabling strict contextual escaping.&#xA;" ilk="function" name="trustAs" returns="*" signature="trustAs(value) =&gt; *">
          <variable citdl="*" doc="The value that that should be considered trusted/safe." ilk="argument" name="value" />
        </scope>
        <scope doc="If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs&#xA;`$sceDelegate.trustAs`}, returns the value that had been passed to {@link&#xA;ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.&#xA;* If the passed parameter is not a value that had been returned by {@link&#xA;ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.&#xA;" ilk="function" name="valueOf" returns="*" signature="valueOf() =&gt; *" />
      </scope>
      <scope ilk="class" name="$templateCache" />
      <scope doc="The `$templateRequest` service runs security checks then downloads the provided template using&#xA;`$http` and, upon success, stores the contents inside of `$templateCache`. If the HTTP request&#xA;fails or the response data of the HTTP request is empty, a `$compile` error will be thrown (the&#xA;exception can be thwarted by setting the 2nd parameter of the function to true). Note that the&#xA;contents of `$templateCache` are trusted, so the call to `$sce.getTrustedUrl(tpl)` is omitted&#xA;when `tpl` is of type string and `$templateCache` has the matching entry.&#xA;" ilk="class" name="$templateRequest" />
      <scope doc="Angular&apos;s wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch&#xA;block and delegates any exceptions to&#xA;{@link ng.$exceptionHandler $exceptionHandler} service.&#xA;* The return value of calling `$timeout` is a promise, which will be resolved when&#xA;the delay has passed and the timeout function, if provided, is executed.&#xA;* To cancel a timeout request, call `$timeout.cancel(promise)`.&#xA;* In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to&#xA;synchronously flush the queue of deferred functions.&#xA;* If you only want a promise that will be resolved after some specified delay&#xA;then you can call `$timeout` without the `fn` function.&#xA;" ilk="class" name="$timeout">
        <scope doc="Cancels a task associated with the `promise`. As a result of this, the promise will be&#xA;resolved with a rejection.&#xA;" ilk="function" name="cancel" returns="boolean" signature="cancel(promise) =&gt; boolean">
          <variable citdl="Promise=" doc="Promise returned by the `$timeout` function." ilk="argument" name="promise" />
        </scope>
      </scope>
      <scope doc="A reference to the browser&apos;s `window` object. While `window`&#xA;is globally available in JavaScript, it causes testability problems, because&#xA;it is a global variable. In angular we always refer to it through the&#xA;`$window` service, so it may be overridden, removed or mocked for testing.&#xA;* Expressions, like the one defined for the `ngClick` directive in the example&#xA;below, are evaluated with respect to the current scope.  Therefore, there is&#xA;no risk of inadvertently coding in a dependency on a global value in such an&#xA;expression.&#xA;" ilk="class" name="$window" />
      <scope doc="Factory function used to create XMLHttpRequest objects.&#xA;* Replace or decorate this service to create your own custom XMLHttpRequest objects.&#xA;* ```&#xA;angular.module(&apos;myApp&apos;, [])&#xA;.factory(&apos;$xhrFactory&apos;, function() {&#xA;return function createXhr(method, url) {&#xA;return new window.XMLHttpRequest({mozSystem: true});&#xA;};&#xA;});&#xA;```&#xA;" ilk="class" name="$xhrFactory" />
      <scope ilk="namespace" name="form">
        <scope ilk="class" name="FormController">
          <scope ilk="function" name="$addControl" signature="$addControl()" />
          <scope ilk="function" name="$commitViewValue" signature="$commitViewValue()" />
          <scope ilk="function" name="$removeControl" signature="$removeControl()" />
          <scope ilk="function" name="$rollbackViewValue" signature="$rollbackViewValue()" />
          <scope ilk="function" name="$setDirty" signature="$setDirty()" />
          <scope ilk="function" name="$setPristine" signature="$setPristine()" />
          <scope ilk="function" name="$setSubmitted" signature="$setSubmitted()" />
          <scope ilk="function" name="$setUntouched" signature="$setUntouched()" />
          <scope ilk="function" name="$setValidity" signature="$setValidity()" />
        </scope>
      </scope>
      <scope ilk="namespace" name="ngModel">
        <scope doc="* `NgModelController` provides API for the {@link ngModel `ngModel`} directive.&#xA;The controller contains services for data-binding, validation, CSS updates, and value formatting&#xA;and parsing. It purposefully does not contain any logic which deals with DOM rendering or&#xA;listening to DOM events.&#xA;Such DOM related logic should be provided by other directives which make use of&#xA;`NgModelController` for data-binding to control elements.&#xA;Angular provides this DOM logic for most {@link input `input`} elements.&#xA;At the end of this page you can find a {@link ngModel.NgModelController#custom-control-example&#xA;custom control example} that uses `ngModelController` to bind to `contenteditable` elements.&#xA;" ilk="class" name="NgModelController">
          <scope ilk="function" name="$commitViewValue" signature="$commitViewValue()" />
          <scope doc="This is called when we need to determine if the value of an input is empty.&#xA;* For instance, the required directive does this to work out if the input has data or not.&#xA;* The default `$isEmpty` function checks whether the value is `undefined`, `&apos;&apos;`, `null` or `NaN`.&#xA;* You can override this for input directives whose concept of being empty is different from the&#xA;default. The `checkboxInputType` directive does this because in its case a value of `false`&#xA;implies empty.&#xA;" ilk="function" name="$isEmpty" returns="boolean" signature="$isEmpty(value) =&gt; boolean">
            <variable citdl="*" doc="The value of the input to check for emptiness." ilk="argument" name="value" />
          </scope>
          <scope ilk="function" name="$render" signature="$render()" />
          <scope ilk="function" name="$rollbackViewValue" signature="$rollbackViewValue()" />
          <scope ilk="function" name="$setDirty" signature="$setDirty()" />
          <scope ilk="function" name="$setPristine" signature="$setPristine()" />
          <scope ilk="function" name="$setTouched" signature="$setTouched()" />
          <scope ilk="function" name="$setUntouched" signature="$setUntouched()" />
          <scope doc="Change the validity state, and notify the form.&#xA;* This method can be called within $parsers/$formatters or a custom validation implementation.&#xA;However, in most cases it should be sufficient to use the `ngModel.$validators` and&#xA;`ngModel.$asyncValidators` collections which will call `$setValidity` automatically.&#xA;" ilk="function" name="$setValidity" signature="$setValidity()" />
          <scope doc="Update the view value.&#xA;* This method should be called when a control wants to change the view value; typically,&#xA;this is done from within a DOM event handler. For example, the {@link ng.directive:input input}&#xA;directive calls it when the value of the input changes and {@link ng.directive:select select}&#xA;calls it when an option is selected.&#xA;* When `$setViewValue` is called, the new `value` will be staged for committing through the `$parsers`&#xA;and `$validators` pipelines. If there are no special {@link ngModelOptions} specified then the staged&#xA;value sent directly for processing, finally to be applied to `$modelValue` and then the&#xA;**expression** specified in the `ng-model` attribute. Lastly, all the registered change listeners,&#xA;in the `$viewChangeListeners` list, are called.&#xA;* In case the {@link ng.directive:ngModelOptions ngModelOptions} directive is used with `updateOn`&#xA;and the `default` trigger is not listed, all those actions will remain pending until one of the&#xA;`updateOn` events is triggered on the DOM element.&#xA;All these actions will be debounced if the {@link ng.directive:ngModelOptions ngModelOptions}&#xA;directive is used with a custom debounce for this particular event.&#xA;Note that a `$digest` is only triggered once the `updateOn` events are fired, or if `debounce`&#xA;is specified, once the timer runs out.&#xA;* When used with standard inputs, the view value will always be a string (which is in some cases&#xA;parsed into another type, such as a `Date` object for `input[date]`.)&#xA;However, custom controls might also pass objects to this method. In this case, we should make&#xA;a copy of the object before passing it to `$setViewValue`. This is because `ngModel` does not&#xA;perform a deep watch of objects, it only looks for a change of identity. If you only change&#xA;the property of the object then ngModel will not realise that the object has changed and&#xA;will not invoke the `$parsers` and `$validators` pipelines. For this reason, you should&#xA;not change properties of the copy once it has been passed to `$setViewValue`.&#xA;Otherwise you may cause the model value on the scope to change incorrectly.&#xA;* &lt;div class=&quot;alert alert-info&quot;&gt;&#xA;In any case, the value passed to the method should always reflect the current value&#xA;of the control. For example, if you are calling `$setViewValue` for an input element,&#xA;you should pass the input DOM value. Otherwise, the control and the scope model become&#xA;out of sync. It&apos;s also important to note that `$setViewValue` does not call `$render` or change&#xA;the control&apos;s DOM value in any way. If we want to change the control&apos;s DOM value&#xA;programmatically, we should update the `ngModel` scope expression. Its new value will be&#xA;picked up by the model controller, which will run it through the `$formatters`, `$render` it&#xA;to update the DOM, and finally call `$validate` on it.&#xA;&lt;/div&gt;&#xA;" ilk="function" name="$setViewValue" signature="$setViewValue(value)">
            <variable citdl="*" doc="value from the view." ilk="argument" name="value" />
          </scope>
          <scope ilk="function" name="$validate" signature="$validate()" />
        </scope>
      </scope>
      <scope ilk="namespace" name="select">
        <scope ilk="class" name="SelectController" />
      </scope>
      <scope ilk="namespace" name="ng">
        <scope ilk="class" name="$q">
          <scope doc="Creates a `Deferred` object which represents a task which will finish in the future.&#xA;" ilk="function" name="defer" returns="Deferred" signature="defer() =&gt; Deferred" />
        </scope>
      </scope>
    </scope>
  </file>
</codeintel>
