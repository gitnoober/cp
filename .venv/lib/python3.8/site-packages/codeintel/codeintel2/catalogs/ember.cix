<?xml version="1.0" encoding="UTF-8"?>
<codeintel description="A framework for creating ambitious web applications" name="Ember-2.4.0" version="2.0">
  <file lang="JavaScript" path="Ember">
    <scope ilk="blob" lang="JavaScript" name="Ember-2.4.0">
      <scope ilk="class" name="Backburner" />
      <scope doc="A container used to instantiate and cache objects.&#xA;  &#xA;Every `Container` must be associated with a `Registry`, which is referenced&#xA;to determine the factory and options that should be used to instantiate&#xA;objects.&#xA;  &#xA;The public API for `Container` is still in flux and should not be considered&#xA;stable." ilk="class" name="Container">
        <scope attributes="private" doc="Trigger an event. Supports up to two arguments. Designed around&#xA;triggering transition events from one run loop instance to the&#xA;next, which requires an argument for the first instance and then&#xA;an argument for the next instance." ilk="function" name="_trigger" signature="_trigger(eventName,arg1,arg2)">
          <variable citdl="String" ilk="argument" name="eventName" />
          <variable citdl="Any" ilk="argument" name="arg1" />
          <variable citdl="Any" ilk="argument" name="arg2" />
        </scope>
        <variable attributes="property private" citdl="Object" name="Container" />
        <variable attributes="property private" citdl="Registry" name="Container" />
        <variable attributes="property private" citdl="InheritingDict" name="Container" />
        <variable attributes="property private" citdl="InheritingDict" name="Container" />
        <variable attributes="property private" citdl="InheritingDict" name="Container" />
        <scope attributes="private" doc="Given a fullName return a corresponding instance.&#xA; The default behaviour is for lookup to return a singleton instance.&#xA;The singleton is scoped to the container, allowing multiple containers&#xA;to all have their own locally scoped singletons.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;api:twitter&apos;, Twitter);&#xA; var twitter = container.lookup(&apos;api:twitter&apos;);&#xA; twitter instanceof Twitter; // =&gt; true&#xA; // by default the container will return singletons&#xA;var twitter2 = container.lookup(&apos;api:twitter&apos;);&#xA;twitter2 instanceof Twitter; // =&gt; true&#xA; twitter === twitter2; //=&gt; true&#xA;```&#xA; If singletons are not wanted an optional flag can be provided at lookup.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;api:twitter&apos;, Twitter);&#xA; var twitter = container.lookup(&apos;api:twitter&apos;, { singleton: false });&#xA;var twitter2 = container.lookup(&apos;api:twitter&apos;, { singleton: false });&#xA; twitter === twitter2; //=&gt; false&#xA;```" ilk="function" name="lookup" returns="Any" signature="lookup(fullName,options) =&gt; Any">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="Given a fullName return the corresponding factory." ilk="function" name="lookupFactory" returns="Any" signature="lookupFactory(fullName,options) =&gt; Any">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="A depth first traversal, destroying the container, its descendant containers and all&#xA;their managed objects." ilk="function" name="destroy" signature="destroy()" />
        <scope attributes="private" doc="Clear either the entire cache or just the cache for a particular key." ilk="function" name="reset" signature="reset(fullName)">
          <variable citdl="String" doc="optional key to reset; if missing, resets everything" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="Returns an object that can be used to provide an owner to a&#xA;manually created instance." ilk="function" name="ownerInjection" returns="Object" signature="ownerInjection() =&gt; Object" />
      </scope>
      <scope doc="ContainerProxyMixin is used to provide public access to specific&#xA;container functionality." ilk="class" name="ContainerProxyMixin">
        <variable attributes="property private" citdl="Ember.Container" doc="The container stores state." name="ContainerProxyMixin" />
        <scope attributes="public" doc="Returns an object that can be used to provide an owner to a&#xA;manually created instance.&#xA; Example:&#xA; ```&#xA;let owner = Ember.getOwner(this);&#xA; User.create(&#xA;  owner.ownerInjection(),&#xA;  { username: &apos;rwjblue&apos; }&#xA;)&#xA;```" ilk="function" name="ownerInjection" returns="Object" signature="ownerInjection() =&gt; Object" />
        <scope attributes="public" doc="Given a fullName return a corresponding instance.&#xA; The default behaviour is for lookup to return a singleton instance.&#xA;The singleton is scoped to the container, allowing multiple containers&#xA;to all have their own locally scoped singletons.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;api:twitter&apos;, Twitter);&#xA; var twitter = container.lookup(&apos;api:twitter&apos;);&#xA; twitter instanceof Twitter; // =&gt; true&#xA; // by default the container will return singletons&#xA;var twitter2 = container.lookup(&apos;api:twitter&apos;);&#xA;twitter2 instanceof Twitter; // =&gt; true&#xA; twitter === twitter2; //=&gt; true&#xA;```&#xA; If singletons are not wanted an optional flag can be provided at lookup.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;api:twitter&apos;, Twitter);&#xA; var twitter = container.lookup(&apos;api:twitter&apos;, { singleton: false });&#xA;var twitter2 = container.lookup(&apos;api:twitter&apos;, { singleton: false });&#xA; twitter === twitter2; //=&gt; false&#xA;```" ilk="function" name="lookup" returns="Any" signature="lookup(fullName,options) =&gt; Any">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="Given a fullName return the corresponding factory." ilk="function" name="_lookupFactory" returns="Any" signature="_lookupFactory(fullName) =&gt; Any">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
      </scope>
      <scope doc="DAG stands for Directed acyclic graph.&#xA;&#xA;It is used to build a graph of dependencies checking that there isn&apos;t circular&#xA;dependencies. p.e Registering initializers with a certain precedence order." ilk="class" name="DAG">
        <scope attributes="private" doc="Adds a vertex entry to the graph unless it is already added." ilk="function" name="add" signature="add(name)">
          <variable citdl="String" doc="The name of the vertex to add" ilk="argument" name="name" />
        </scope>
        <scope attributes="private" doc="Adds a vertex to the graph and sets its value." ilk="function" name="map" signature="map(name,value)">
          <variable citdl="String" doc="The name of the vertex." ilk="argument" name="name" />
          <variable doc="The value to put in the vertex." ilk="argument" name="value" />
        </scope>
        <scope attributes="private" doc="Connects the vertices with the given names, adding them to the graph if&#xA;necessary, only if this does not produce is any circular dependency." ilk="function" name="addEdge" signature="addEdge(fromName,toName)">
          <variable citdl="String" doc="The name the vertex where the edge starts." ilk="argument" name="fromName" />
          <variable citdl="String" doc="The name the vertex where the edge ends." ilk="argument" name="toName" />
        </scope>
        <scope doc="Visits all the vertex of the graph calling the given function with each one,&#xA;ensuring that the vertices are visited respecting their precedence." ilk="function" name="topsort" signature="topsort(fn)">
          <variable citdl="Function" doc="The function to be invoked on each vertex." ilk="argument" name="fn" />
        </scope>
        <scope doc="Adds a vertex with the given name and value to the graph and joins it with the&#xA;vertices referenced in _before_ and _after_. If there isn&apos;t vertices with those&#xA;names, they are added too.&#xA;&#xA;If either _before_ or _after_ are falsy/empty, the added vertex will not have&#xA;an incoming/outgoing edge." ilk="function" name="addEdges" signature="addEdges(name,value,before,after)">
          <variable citdl="String" doc="The name of the vertex to be added." ilk="argument" name="name" />
          <variable doc="The value of that vertex." ilk="argument" name="value" />
          <variable doc="An string or array of strings with the names of the vertices before&#xA;                     which this vertex must be visited." ilk="argument" name="before" />
          <variable doc="An string or array of strings with the names of the vertex after&#xA;                     which this vertex must be visited." ilk="argument" name="after" />
        </scope>
      </scope>
      <scope doc="Objects of this type can implement an interface to respond to requests to&#xA;get and set. The default implementation handles simple properties." ilk="class" name="Descriptor" />
      <scope doc="This namespace contains all Ember methods and functions. Future versions of&#xA;Ember may overwrite this namespace and therefore, you should avoid adding any&#xA;new properties.&#xA;  &#xA;You can also use the shorthand `Em` instead of `Ember`.&#xA;  &#xA;At the heart of Ember is Ember-Runtime, a set of core functions that provide&#xA;cross-platform compatibility and object property observing.  Ember-Runtime is&#xA;small and performance-focused so you can use it alongside other&#xA;cross-platform libraries such as jQuery. For more details, see&#xA;[Ember-Runtime](http://emberjs.com/api/modules/ember-runtime.html)." ilk="class" name="Ember">
        <scope doc="`Ember.ActionHandler` is available on some familiar classes including&#xA;`Ember.Route`, `Ember.View`, `Ember.Component`, and `Ember.Controller`.&#xA;(Internally the mixin is used by `Ember.CoreView`, `Ember.ControllerMixin`,&#xA;and `Ember.Route` and available to the above classes through&#xA;inheritance.)" ilk="class" name="ActionHandler">
          <variable attributes="property public" citdl="Object" doc="The collection of functions, keyed by name, available on this&#xA;`ActionHandler` as action targets.&#xA; These functions will be invoked when a matching `{{action}}` is triggered&#xA;from within a template and the application&apos;s current route is this route.&#xA; Actions can also be invoked from other parts of your application&#xA;via `ActionHandler#send`.&#xA; The `actions` hash will inherit action handlers from&#xA;the `actions` hash defined on extended parent classes&#xA;or mixins rather than just replace the entire hash, e.g.:&#xA; ```js&#xA;App.CanDisplayBanner = Ember.Mixin.create({&#xA;  actions: {&#xA;    displayBanner: function(msg) {&#xA;      // ...&#xA;    }&#xA;  }&#xA;});&#xA; App.WelcomeRoute = Ember.Route.extend(App.CanDisplayBanner, {&#xA;  actions: {&#xA;    playMusic: function() {&#xA;      // ...&#xA;    }&#xA;  }&#xA;});&#xA; // `WelcomeRoute`, when active, will be able to respond&#xA;// to both actions, since the actions hash is merged rather&#xA;// then replaced when extending mixins / parent classes.&#xA;this.send(&apos;displayBanner&apos;);&#xA;this.send(&apos;playMusic&apos;);&#xA;```&#xA; Within a Controller, Route, View or Component&apos;s action handler,&#xA;the value of the `this` context is the Controller, Route, View or&#xA;Component object:&#xA; ```js&#xA;App.SongRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    myAction: function() {&#xA;      this.controllerFor(&quot;song&quot;);&#xA;      this.transitionTo(&quot;other.route&quot;);&#xA;      ...&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; It is also possible to call `this._super(...arguments)` from within an&#xA;action handler if it overrides a handler defined on a parent&#xA;class or mixin:&#xA; Take for example the following routes:&#xA; ```js&#xA;App.DebugRoute = Ember.Mixin.create({&#xA;  actions: {&#xA;    debugRouteInformation: function() {&#xA;      console.debug(&quot;trololo&quot;);&#xA;    }&#xA;  }&#xA;});&#xA; App.AnnoyingDebugRoute = Ember.Route.extend(App.DebugRoute, {&#xA;  actions: {&#xA;    debugRouteInformation: function() {&#xA;      // also call the debugRouteInformation of mixed in App.DebugRoute&#xA;      this._super(...arguments);&#xA;       // show additional annoyance&#xA;      window.alert(...);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; ## Bubbling&#xA; By default, an action will stop bubbling once a handler defined&#xA;on the `actions` hash handles it. To continue bubbling the action,&#xA;you must return `true` from the handler:&#xA; ```js&#xA;App.Router.map(function() {&#xA;  this.route(&quot;album&quot;, function() {&#xA;    this.route(&quot;song&quot;);&#xA;  });&#xA;});&#xA; App.AlbumRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    startPlaying: function() {&#xA;    }&#xA;  }&#xA;});&#xA; App.AlbumSongRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    startPlaying: function() {&#xA;      // ...&#xA;       if (actionShouldAlsoBeTriggeredOnParentRoute) {&#xA;        return true;&#xA;      }&#xA;    }&#xA;  }&#xA;});&#xA;```" name="ActionHandler" />
          <scope attributes="public" doc="Triggers a named action on the `ActionHandler`. Any parameters&#xA;supplied after the `actionName` string will be passed as arguments&#xA;to the action target function.&#xA; If the `ActionHandler` has its `target` property set, actions may&#xA;bubble to the `target`. Bubbling happens when an `actionName` can&#xA;not be found in the `ActionHandler`&apos;s `actions` hash or if the&#xA;action target function returns `true`.&#xA; Example&#xA; ```js&#xA;App.WelcomeRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    playTheme: function() {&#xA;       this.send(&apos;playMusic&apos;, &apos;theme.mp3&apos;);&#xA;    },&#xA;    playMusic: function(track) {&#xA;      // ...&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="send" signature="send(actionName,context)">
            <variable citdl="String" doc="The action to trigger" ilk="argument" name="actionName" />
            <variable citdl="*" doc="a context to send with the action" ilk="argument" name="context" />
          </scope>
        </scope>
        <scope classrefs="Ember.Engine" doc="An instance of `Ember.Application` is the starting point for every Ember&#xA;application. It helps to instantiate, initialize and coordinate the many&#xA;objects that make up your app.&#xA;  &#xA;Each Ember app has one and only one `Ember.Application` object. In fact, the&#xA;very first thing you should do in your application is create the instance:&#xA;  &#xA;```javascript&#xA;window.App = Ember.Application.create();&#xA;```&#xA;  &#xA;Typically, the application object is the only global variable. All other&#xA;classes in your app should be properties on the `Ember.Application` instance,&#xA;which highlights its first role: a global namespace.&#xA;  &#xA;For example, if you define a view class, it might look like this:&#xA;  &#xA;```javascript&#xA;App.MyView = Ember.View.extend();&#xA;```&#xA;  &#xA;By default, calling `Ember.Application.create()` will automatically initialize&#xA;your application by calling the `Ember.Application.initialize()` method. If&#xA;you need to delay initialization, you can call your app&apos;s `deferReadiness()`&#xA;method. When you are ready for your app to be initialized, call its&#xA;`advanceReadiness()` method.&#xA;  &#xA;You can define a `ready` method on the `Ember.Application` instance, which&#xA;will be run by Ember when the application is initialized.&#xA;  &#xA;Because `Ember.Application` inherits from `Ember.Namespace`, any classes&#xA;you create will have useful string representations when calling `toString()`.&#xA;See the `Ember.Namespace` documentation for more information.&#xA;  &#xA;While you can think of your `Ember.Application` as a container that holds the&#xA;other classes in your application, there are several other responsibilities&#xA;going on under-the-hood that you may want to understand.&#xA;  &#xA;### Event Delegation&#xA;  &#xA;Ember uses a technique called _event delegation_. This allows the framework&#xA;to set up a global, shared event listener instead of requiring each view to&#xA;do it manually. For example, instead of each view registering its own&#xA;`mousedown` listener on its associated element, Ember sets up a `mousedown`&#xA;listener on the `body`.&#xA;  &#xA;If a `mousedown` event occurs, Ember will look at the target of the event and&#xA;start walking up the DOM node tree, finding corresponding views and invoking&#xA;their `mouseDown` method as it goes.&#xA;  &#xA;`Ember.Application` has a number of default events that it listens for, as&#xA;well as a mapping from lowercase events to camel-cased view method names. For&#xA;example, the `keypress` event causes the `keyPress` method on the view to be&#xA;called, the `dblclick` event causes `doubleClick` to be called, and so on.&#xA;  &#xA;If there is a bubbling browser event that Ember does not listen for by&#xA;default, you can specify custom events and their corresponding view method&#xA;names by setting the application&apos;s `customEvents` property:&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create({&#xA;  customEvents: {&#xA;    // add support for the paste event&#xA;    paste: &apos;paste&apos;&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;To prevent Ember from setting up a listener for a default event,&#xA;specify the event name with a `null` value in the `customEvents`&#xA;property:&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create({&#xA;  customEvents: {&#xA;    // prevent listeners for mouseenter/mouseleave events&#xA;    mouseenter: null,&#xA;    mouseleave: null&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;By default, the application sets up these event listeners on the document&#xA;body. However, in cases where you are embedding an Ember application inside&#xA;an existing page, you may want it to set up the listeners on an element&#xA;inside the body.&#xA;  &#xA;For example, if only events inside a DOM element with the ID of `ember-app`&#xA;should be delegated, set your application&apos;s `rootElement` property:&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create({&#xA;  rootElement: &apos;#ember-app&apos;&#xA;});&#xA;```&#xA;  &#xA;The `rootElement` can be either a DOM element or a jQuery-compatible selector&#xA;string. Note that *views appended to the DOM outside the root element will&#xA;not receive events.* If you specify a custom root element, make sure you only&#xA;append views inside it!&#xA;  &#xA;To learn more about the advantages of event delegation and the Ember view&#xA;layer, and a list of the event listeners that are setup by default, visit the&#xA;[Ember View Layer guide](http://emberjs.com/guides/understanding-ember/the-view-layer/#toc_event-delegation).&#xA;  &#xA;### Initializers&#xA;  &#xA;Libraries on top of Ember can add initializers, like so:&#xA;  &#xA;```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;api-adapter&apos;,&#xA;  &#xA;  initialize: function(application) {&#xA;    application.register(&apos;api-adapter:main&apos;, ApiAdapter);&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;Initializers provide an opportunity to access the internal registry, which&#xA;organizes the different components of an Ember application. Additionally&#xA;they provide a chance to access the instantiated application. Beyond&#xA;being used for libraries, initializers are also a great way to organize&#xA;dependency injection or setup in your own application.&#xA;  &#xA;### Routing&#xA;  &#xA;In addition to creating your application&apos;s router, `Ember.Application` is&#xA;also responsible for telling the router when to start routing. Transitions&#xA;between routes can be logged with the `LOG_TRANSITIONS` flag, and more&#xA;detailed intra-transition logging can be logged with&#xA;the `LOG_TRANSITIONS_INTERNAL` flag:&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create({&#xA;  LOG_TRANSITIONS: true, // basic logging of successful transitions&#xA;  LOG_TRANSITIONS_INTERNAL: true // detailed logging of all routing steps&#xA;});&#xA;```&#xA;  &#xA;By default, the router will begin trying to translate the current URL into&#xA;application state once the browser emits the `DOMContentReady` event. If you&#xA;need to defer routing, you can call the application&apos;s `deferReadiness()`&#xA;method. Once routing can begin, call the `advanceReadiness()` method.&#xA;  &#xA;If there is any setup required before routing begins, you can implement a&#xA;`ready()` method on your app that will be invoked immediately before routing&#xA;begins." ilk="class" name="Application">
          <variable attributes="property public" citdl="DOMElement" doc="The root DOM element of the Application. This can be specified as an&#xA;element or a&#xA;[jQuery-compatible selector string](http://api.jquery.com/category/selectors/).&#xA; This is the element that will be passed to the Application&apos;s,&#xA;`eventDispatcher`, which sets up the listeners for event delegation. Every&#xA;view in your application should be a child of the element you specify here." name="Application" />
          <variable attributes="property public" citdl="Ember.EventDispatcher" doc="The `Ember.EventDispatcher` responsible for delegating events to this&#xA;application&apos;s views.&#xA; The event dispatcher is created by the application at initialization time&#xA;and sets up event listeners on the DOM element described by the&#xA;application&apos;s `rootElement` property.&#xA; See the documentation for `Ember.EventDispatcher` for more information." name="Application" />
          <variable attributes="property public" citdl="Object" doc="The DOM events for which the event dispatcher should listen.&#xA; By default, the application&apos;s `Ember.EventDispatcher` listens&#xA;for a set of standard DOM events, such as `mousedown` and&#xA;`keyup`, and delegates them to your application&apos;s `Ember.View`&#xA;instances.&#xA; If you would like additional bubbling events to be delegated to your&#xA;views, set your `Ember.Application`&apos;s `customEvents` property&#xA;to a hash containing the DOM event name as the key and the&#xA;corresponding view method name as the value. Setting an event to&#xA;a value of `null` will prevent a default event listener from being&#xA;added for that event.&#xA; To add new events to be listened to:&#xA; ```javascript&#xA;var App = Ember.Application.create({&#xA;  customEvents: {&#xA;    // add support for the paste event&#xA;    paste: &apos;paste&apos;&#xA;  }&#xA;});&#xA;```&#xA; To prevent default events from being listened to:&#xA; ```javascript&#xA;var App = Ember.Application.create({&#xA;  customEvents: {&#xA;    // remove support for mouseenter / mouseleave events&#xA;    mouseenter: null,&#xA;    mouseleave: null&#xA;  }&#xA;});&#xA;```" name="Application" />
          <variable attributes="property private" citdl="Boolean" doc="Whether the application should automatically start routing and render&#xA;templates to the `rootElement` on DOM ready. While default by true,&#xA;other environments such as FastBoot or a testing harness can set this&#xA;property to `false` and control the precise timing and behavior of the boot&#xA;process." name="Application" />
          <variable attributes="property private" citdl="Boolean" doc="Whether the application should be configured for the legacy &quot;globals mode&quot;.&#xA;Under this mode, the Application object serves as a global namespace for all&#xA;classes.&#xA; ```javascript&#xA;var App = Ember.Application.create({&#xA;  ...&#xA;});&#xA; App.Router.reopen({&#xA;  location: 'none'&#xA;});&#xA; App.Router.map({&#xA;  ...&#xA;});&#xA; App.MyComponent = Ember.Component.extend({&#xA;  ...&#xA;});&#xA;```&#xA; This flag also exposes other internal APIs that assumes the existence of&#xA;a special &quot;default instance&quot;, like `App.__container__.lookup(...)`.&#xA; This option is currently not configurable, its value is derived from&#xA;the `autoboot` flag &#8211; disabling `autoboot` also implies opting-out of&#xA;globals mode support, although they are ultimately orthogonal concerns.&#xA; Some of the global modes features are already deprecated in 1.x. The&#xA;existence of this flag is to untangle the globals mode code paths from&#xA;the autoboot code paths, so that these legacy features can be reviewed&#xA;for deprecation/removal separately.&#xA; Forcing the (autoboot=true, _globalsMode=false) here and running the tests&#xA;would reveal all the places where we are still relying on these legacy&#xA;behavior internally (mostly just tests)." name="Application" />
          <scope attributes="private" doc="Create an ApplicationInstance for this application." ilk="function" name="buildInstance" returns="Ember.ApplicationInstance" signature="buildInstance() =&gt; Ember.ApplicationInstance" />
          <scope attributes="private" doc="Enable the legacy globals mode by allowing this application to act&#xA;as a global namespace. See the docs on the `_globalsMode` property&#xA;for details.&#xA; Most of these features are already deprecated in 1.x, so we can&#xA;stop using them internally and try to remove them." ilk="function" name="_prepareForGlobalsMode" signature="_prepareForGlobalsMode()" />
          <scope attributes="private" doc="Automatically kick-off the boot process for the application once the&#xA;DOM has become ready.&#xA; The initialization itself is scheduled on the actions queue which&#xA;ensures that code-loading finishes before booting.&#xA; If you are asynchronously loading code, you should call `deferReadiness()`&#xA;to defer booting, and then call `advanceReadiness()` once all of your code&#xA;has finished loading." ilk="function" name="waitForDOMReady" signature="waitForDOMReady()" />
          <scope attributes="private" doc="This is the autoboot flow:&#xA; 1. Boot the app by calling `this.boot()`&#xA;2. Create an instance (or use the `__deprecatedInstance__` in globals mode)&#xA;3. Boot the instance by calling `instance.boot()`&#xA;4. Invoke the `App.ready()` callback&#xA;5. Kick-off routing on the instance&#xA; Ideally, this is all we would need to do:&#xA; ```javascript&#xA;_autoBoot() {&#xA;  this.boot().then(() =&gt; {&#xA;    let instance = (this._globalsMode) ? this.__deprecatedInstance__ : this.buildInstance();&#xA;    return instance.boot();&#xA;  }).then((instance) =&gt; {&#xA;    App.ready();&#xA;    instance.startRouting();&#xA;  });&#xA;}&#xA;```&#xA; Unfortunately, we cannot actually write this because we need to participate&#xA;in the &quot;synchronous&quot; boot process. While the code above would work fine on&#xA;the initial boot (i.e. DOM ready), when `App.reset()` is called, we need to&#xA;boot a new instance synchronously (see the documentation on `_bootSync()`&#xA;for details).&#xA; Because of this restriction, the actual logic of this method is located&#xA;inside `didBecomeReady()`." ilk="function" name="domReady" signature="domReady()" />
          <scope attributes="public" doc="Use this to defer readiness until some condition is true.&#xA; Example:&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA; App.deferReadiness();&#xA; // Ember.$ is a reference to the jQuery object/function&#xA;Ember.$.getJSON(&apos;/auth-token&apos;, function(token) {&#xA;  App.token = token;&#xA;  App.advanceReadiness();&#xA;});&#xA;```&#xA; This allows you to perform asynchronous setup logic and defer&#xA;booting your application until the setup has finished.&#xA; However, if the setup requires a loading UI, it might be better&#xA;to use the router for this purpose." ilk="function" name="deferReadiness" signature="deferReadiness()" />
          <scope attributes="public" doc="Call `advanceReadiness` after any asynchronous setup logic has completed.&#xA;Each call to `deferReadiness` must be matched by a call to `advanceReadiness`&#xA;or the application will never become ready and routing will not begin." ilk="function" name="advanceReadiness" signature="advanceReadiness()" />
          <scope attributes="private" doc="Initialize the application and return a promise that resolves with the `Ember.Application`&#xA;object when the boot process is complete.&#xA; Run any application initializers and run the application load hook. These hooks may&#xA;choose to defer readiness. For example, an authentication hook might want to defer&#xA;readiness until the auth token has been retrieved.&#xA; By default, this method is called automatically on &quot;DOM ready&quot;; however, if autoboot&#xA;is disabled, this is automatically called when the first application instance is&#xA;created via `visit`." ilk="function" name="boot" returns="Promise&lt;Ember.Application,Error&gt;" signature="boot() =&gt; Promise&lt;Ember.Application,Error&gt;" />
          <scope attributes="public" doc="Reset the application. This is typically used only in tests. It cleans up&#xA;the application in the following order:&#xA; 1. Deactivate existing routes&#xA;2. Destroy all objects in the container&#xA;3. Create a new application container&#xA;4. Re-route to the existing url&#xA; Typical Example:&#xA; ```javascript&#xA;var App;&#xA; run(function() {&#xA;  App = Ember.Application.create();&#xA;});&#xA; module(&apos;acceptance test&apos;, {&#xA;  setup: function() {&#xA;    App.reset();&#xA;  }&#xA;});&#xA; test(&apos;first test&apos;, function() {&#xA;  // App is freshly reset&#xA;});&#xA; test(&apos;second test&apos;, function() {&#xA;  // App is again freshly reset&#xA;});&#xA;```&#xA; Advanced Example:&#xA; Occasionally you may want to prevent the app from initializing during&#xA;setup. This could enable extra configuration, or enable asserting prior&#xA;to the app becoming ready.&#xA; ```javascript&#xA;var App;&#xA; run(function() {&#xA;  App = Ember.Application.create();&#xA;});&#xA; module(&apos;acceptance test&apos;, {&#xA;  setup: function() {&#xA;    run(function() {&#xA;      App.reset();&#xA;      App.deferReadiness();&#xA;    });&#xA;  }&#xA;});&#xA; test(&apos;first test&apos;, function() {&#xA;  ok(true, &apos;something before app is initialized&apos;);&#xA;   run(function() {&#xA;    App.advanceReadiness();&#xA;  });&#xA;   ok(true, &apos;something after app is initialized&apos;);&#xA;});&#xA;```" ilk="function" name="reset" signature="reset()" />
          <scope attributes="private" ilk="function" name="didBecomeReady" signature="didBecomeReady()" />
          <variable attributes="event public" doc="Called when the Application has become ready, immediately before routing&#xA;begins. The call will be delayed until the DOM has become ready." name="Application" />
          <scope doc="Boot a new instance of `Ember.ApplicationInstance` for the current&#xA;application and navigate it to the given `url`. Returns a `Promise` that&#xA;resolves with the instance when the initial routing and rendering is&#xA;complete, or rejects with any error that occured during the boot process.&#xA; When `autoboot` is disabled, calling `visit` would first cause the&#xA;application to boot, which runs the application initializers.&#xA; This method also takes a hash of boot-time configuration options for&#xA;customizing the instance&apos;s behavior. See the documentation on&#xA;`Ember.ApplicationInstance.BootOptions` for details.&#xA; `Ember.ApplicationInstance.BootOptions` is an interface class that exists&#xA;purely to document the available options; you do not need to construct it&#xA;manually. Simply pass a regular JavaScript object containing of the&#xA;desired options:&#xA; ```javascript&#xA;MyApp.visit(&quot;/&quot;, { location: &quot;none&quot;, rootElement: &quot;#container&quot; });&#xA;```&#xA; ### Supported Scenarios&#xA; While the `BootOptions` class exposes a large number of knobs, not all&#xA;combinations of them are valid; certain incompatible combinations might&#xA;result in unexpected behavior.&#xA; For example, booting the instance in the full browser environment&#xA;while specifying a foriegn `document` object (e.g. `{ isBrowser: true,&#xA;document: iframe.contentDocument }`) does not work correctly today,&#xA;largely due to Ember&apos;s jQuery dependency.&#xA; Currently, there are three officially supported scenarios/configurations.&#xA;Usages outside of these scenarios are not guaranteed to work, but please&#xA;feel free to file bug reports documenting your experience and any issues&#xA;you encountered to help expand support.&#xA; #### Browser Applications (Manual Boot)&#xA; The setup is largely similar to how Ember works out-of-the-box. Normally,&#xA;Ember will boot a default instance for your Application on &quot;DOM ready&quot;.&#xA;However, you can customize this behavior by disabling `autoboot`.&#xA; For example, this allows you to render a miniture demo of your application&#xA;into a specific area on your marketing website:&#xA; ```javascript&#xA;import MyApp from &apos;my-app&apos;;&#xA; $(function() {&#xA;  let App = MyApp.create({ autoboot: false });&#xA;   let options = {&#xA;    // Override the router&apos;s location adapter to prevent it from updating&#xA;    // the URL in the address bar&#xA;    location: &apos;none&apos;,&#xA;     // Override the default `rootElement` on the app to render into a&#xA;    // specific `div` on the page&#xA;    rootElement: &apos;#demo&apos;&#xA;  };&#xA;   // Start the app at the special demo URL&#xA;  App.visit(&apos;/demo&apos;, options);&#xA;});&#xA;````&#xA; Or perhaps you might want to boot two instances of your app on the same&#xA;page for a split-screen multiplayer experience:&#xA; ```javascript&#xA;import MyApp from &apos;my-app&apos;;&#xA; $(function() {&#xA;  let App = MyApp.create({ autoboot: false });&#xA;   let sessionId = MyApp.generateSessionID();&#xA;   let player1 = App.visit(`/matches/join?name=Player+1&amp;session=${sessionId}`, { rootElement: &apos;#left&apos;, location: &apos;none&apos; });&#xA;  let player2 = App.visit(`/matches/join?name=Player+2&amp;session=${sessionId}`, { rootElement: &apos;#right&apos;, location: &apos;none&apos; });&#xA;   Promise.all([player1, player2]).then(() =&gt; {&#xA;    // Both apps have completed the initial render&#xA;    $(&apos;#loading&apos;).fadeOut();&#xA;  });&#xA;});&#xA;```&#xA; Do note that each app instance maintains their own registry/container, so&#xA;they will run in complete isolation by default.&#xA; #### Server-Side Rendering (also known as FastBoot)&#xA; This setup allows you to run your Ember app in a server environment using&#xA;Node.js and render its content into static HTML for SEO purposes.&#xA; ```javascript&#xA;const HTMLSerializer = new SimpleDOM.HTMLSerializer(SimpleDOM.voidMap);&#xA; function renderURL(url) {&#xA;  let dom = new SimpleDOM.Document();&#xA;  let rootElement = dom.body;&#xA;  let options = { isBrowser: false, document: dom, rootElement: rootElement };&#xA;   return MyApp.visit(options).then(instance =&gt; {&#xA;    try {&#xA;      return HTMLSerializer.serialize(rootElement.firstChild);&#xA;    } finally {&#xA;      instance.destroy();&#xA;    }&#xA;  });&#xA;}&#xA;```&#xA; In this scenario, because Ember does not have access to a global `document`&#xA;object in the Node.js environment, you must provide one explicitly. In practice,&#xA;in the non-browser environment, the stand-in `document` object only need to&#xA;implement a limited subset of the full DOM API. The `SimpleDOM` library is known&#xA;to work.&#xA; Since there is no access to jQuery in the non-browser environment, you must also&#xA;specify a DOM `Element` object in the same `document` for the `rootElement` option&#xA;(as opposed to a selector string like `&quot;body&quot;`).&#xA; See the documentation on the `isBrowser`, `document` and `rootElement` properties&#xA;on `Ember.ApplicationInstance.BootOptions` for details.&#xA; #### Server-Side Resource Discovery&#xA; This setup allows you to run the routing layer of your Ember app in a server&#xA;environment using Node.js and completely disable rendering. This allows you&#xA;to simulate and discover the resources (i.e. AJAX requests) needed to fufill&#xA;a given request and eagerly &quot;push&quot; these resources to the client.&#xA; ```app/initializers/network-service.js&#xA;import BrowserNetworkService from &apos;app/services/network/browser&apos;;&#xA;import NodeNetworkService from &apos;app/services/network/node&apos;;&#xA; // Inject a (hypothetical) service for abstracting all AJAX calls and use&#xA;// the appropiate implementaion on the client/server. This also allows the&#xA;// server to log all the AJAX calls made during a particular request and use&#xA;// that for resource-discovery purpose.&#xA; export function initialize(application) {&#xA;  if (window) { // browser&#xA;    application.register(&apos;service:network&apos;, BrowserNetworkService);&#xA;  } else { // node&#xA;    application.register(&apos;service:network&apos;, NodeNetworkService);&#xA;  }&#xA;   application.inject(&apos;route&apos;, &apos;network&apos;, &apos;service:network&apos;);&#xA;};&#xA; export default {&#xA;  name: &apos;network-service&apos;,&#xA;  initialize: initialize&#xA;};&#xA;```&#xA; ```app/routes/post.js&#xA;import Ember from &apos;ember&apos;;&#xA; // An example of how the (hypothetical) service is used in routes.&#xA; export default Ember.Route.extend({&#xA;  model(params) {&#xA;    return this.network.fetch(`/api/posts/${params.post_id}.json`);&#xA;  },&#xA;   afterModel(post) {&#xA;    if (post.isExternalContent) {&#xA;      return this.network.fetch(`/api/external/?url=${post.externalURL}`);&#xA;    } else {&#xA;      return post;&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; ```javascript&#xA;// Finally, put all the pieces together&#xA; function discoverResourcesFor(url) {&#xA;  return MyApp.visit(url, { isBrowser: false, shouldRender: false }).then(instance =&gt; {&#xA;    let networkService = instance.lookup(&apos;service:network&apos;);&#xA;    return networkService.requests; // =&gt; { &quot;/api/posts/123.json&quot;: &quot;...&quot; }&#xA;  });&#xA;}&#xA;```" ilk="function" name="visit" returns="Promise&lt;Ember.ApplicationInstance, Error&gt;" signature="visit(url,options) =&gt; Promise&lt;Ember.ApplicationInstance, Error&gt;">
            <variable citdl="String" doc="The initial URL to navigate to" ilk="argument" name="url" />
            <variable citdl="Ember.ApplicationInstance.BootOptions" ilk="argument" name="options" />
          </scope>
          <scope attributes="public" doc="This creates a registry with the default Ember naming conventions.&#xA; It also configures the registry:&#xA; * registered views are created every time they are looked up (they are&#xA;  not singletons)&#xA;* registered templates are not factories; the registered value is&#xA;  returned directly.&#xA;* the router receives the application as its `namespace` property&#xA;* all controllers receive the router as their `target` and `controllers`&#xA;  properties&#xA;* all controllers receive the application as their `namespace` property&#xA;* the application view receives the application controller as its&#xA;  `controller` property&#xA;* the application view receives the application template as its&#xA;  `defaultTemplate` property" ilk="function" name="buildRegistry" returns="Ember.Registry" signature="buildRegistry(namespace) =&gt; Ember.Registry">
            <variable citdl="Ember.Application" doc="the application for which to&#xA;  build the registry" ilk="argument" name="namespace" />
          </scope>
        </scope>
        <scope classrefs="Ember.EngineInstance" doc="The `ApplicationInstance` encapsulates all of the stateful aspects of a&#xA;running `Application`.&#xA;  &#xA;At a high-level, we break application boot into two distinct phases:&#xA;  &#xA;* Definition time, where all of the classes, templates, and other&#xA;  dependencies are loaded (typically in the browser).&#xA;* Run time, where we begin executing the application once everything&#xA;  has loaded.&#xA;  &#xA;Definition time can be expensive and only needs to happen once since it is&#xA;an idempotent operation. For example, between test runs and FastBoot&#xA;requests, the application stays the same. It is only the state that we want&#xA;to reset.&#xA;  &#xA;That state is what the `ApplicationInstance` manages: it is responsible for&#xA;creating the container that contains all application state, and disposing of&#xA;it once the particular test run or FastBoot request has finished." ilk="class" name="ApplicationInstance">
          <scope doc="A list of boot-time configuration options for customizing the behavior of&#xA;an `Ember.ApplicationInstance`.&#xA; This is an interface class that exists purely to document the available&#xA;options; you do not need to construct it manually. Simply pass a regular&#xA;JavaScript object containing the desired options into methods that require&#xA;one of these options object:&#xA; ```javascript&#xA;MyApp.visit(&quot;/&quot;, { location: &quot;none&quot;, rootElement: &quot;#container&quot; });&#xA;```&#xA; Not all combinations of the supported options are valid. See the documentation&#xA;on `Ember.Application#visit` for the supported configurations.&#xA; Internal, experimental or otherwise unstable flags are marked as private." ilk="class" name="BootOptions">
            <variable attributes="property private" citdl="Object" doc="Provide a specific instance of jQuery. This is useful in conjunction with&#xA;the `document` option, as it allows you to use a copy of `jQuery` that is&#xA;appropriately bound to the foreign `document` (e.g. a jsdom).&#xA; This is highly experimental and support very incomplete at the moment." name="BootOptions" />
            <variable attributes="property private" citdl="boolean" doc="Interactive mode: whether we need to set up event delegation and invoke&#xA;lifecycle callbacks on Components." name="BootOptions" />
            <variable attributes="property public" citdl="boolean" doc="Run in a full browser environment.&#xA; When this flag is set to `false`, it will disable most browser-specific&#xA;and interactive features. Specifically:&#xA; * It does not use `jQuery` to append the root view; the `rootElement`&#xA;  (either specified as a subsequent option or on the application itself)&#xA;  must already be an `Element` in the given `document` (as opposed to a&#xA;  string selector).&#xA; * It does not set up an `EventDispatcher`.&#xA; * It does not run any `Component` lifecycle hooks (such as `didInsertElement`).&#xA; * It sets the `location` option to `&quot;none&quot;`. (If you would like to use&#xA;  the location adapter specified in the app&apos;s router instead, you can also&#xA;  specify `{ location: null }` to specifically opt-out.)" name="BootOptions" />
            <variable attributes="property public" citdl="boolean" doc="Disable rendering completely.&#xA; When this flag is set to `true`, it will disable the entire rendering&#xA;pipeline. Essentially, this puts the app into &quot;routing-only&quot; mode. No&#xA;templates will be rendered, and no Components will be created." name="BootOptions" />
            <variable attributes="property public" citdl="Document" doc="If present, render into the given `Document` object instead of the&#xA;global `window.document` object.&#xA; In practice, this is only useful in non-browser environment or in&#xA;non-interactive mode, because Ember&apos;s `jQuery` dependency is&#xA;implicitly bound to the current document, causing event delegation&#xA;to not work properly when the app is rendered into a foreign&#xA;document object (such as an iframe&apos;s `contentDocument`).&#xA; In non-browser mode, this could be a &quot;`Document`-like&quot; object as&#xA;Ember only interact with a small subset of the DOM API in non-&#xA;interactive mode. While the exact requirements have not yet been&#xA;formalized, the `SimpleDOM` library&apos;s implementation is known to&#xA;work." name="BootOptions" />
            <variable attributes="property public" citdl="String|Element" doc="If present, overrides the application&apos;s `rootElement` property on&#xA;the instance. This is useful for testing environment, where you&#xA;might want to append the root view to a fixture area.&#xA; In non-browser mode, because Ember does not have access to jQuery,&#xA;this options must be specified as a DOM `Element` object instead of&#xA;a selector string.&#xA; See the documentation on `Ember.Applications`&apos;s `rootElement` for&#xA;details." name="BootOptions" />
            <variable attributes="property public" citdl="string" doc="If present, overrides the router&apos;s `location` property with this&#xA;value. This is useful for environments where trying to modify the&#xA;URL would be inappropriate." name="BootOptions" />
          </scope>
          <variable attributes="property private" citdl="Ember.Application" doc="The `Application` for which this is an instance." name="ApplicationInstance" />
          <variable attributes="property private" citdl="Object" doc="The DOM events for which the event dispatcher should listen.&#xA; By default, the application&apos;s `Ember.EventDispatcher` listens&#xA;for a set of standard DOM events, such as `mousedown` and&#xA;`keyup`, and delegates them to your application&apos;s `Ember.View`&#xA;instances." name="ApplicationInstance" />
          <variable attributes="property private" citdl="String|DOMElement" doc="The root DOM element of the Application as an element or a&#xA;[jQuery-compatible selector&#xA;string](http://api.jquery.com/category/selectors/)." name="ApplicationInstance" />
          <scope attributes="private" doc="Initialize the `Ember.ApplicationInstance` and return a promise that resolves&#xA;with the instance itself when the boot process is complete.&#xA; The primary task here is to run any registered instance initializers.&#xA; See the documentation on `BootOptions` for the options it takes." ilk="function" name="boot" returns="Promise&lt;Ember.ApplicationInstance,Error&gt;" signature="boot(options) =&gt; Promise&lt;Ember.ApplicationInstance,Error&gt;">
            <variable ilk="argument" name="options" />
          </scope>
        </scope>
        <scope ilk="class" name="AriaRoleSupport">
          <variable attributes="property public" citdl="String" doc="The WAI-ARIA role of the control represented by this view. For example, a&#xA;button may have a role of type &apos;button&apos;, or a pane may have a role of&#xA;type &apos;alertdialog&apos;. This property is used by assistive software to help&#xA;visually challenged users navigate rich web applications.&#xA; The full list of valid WAI-ARIA roles is available at:&#xA;[http://www.w3.org/TR/wai-aria/roles#roles_categorization](http://www.w3.org/TR/wai-aria/roles#roles_categorization)" name="AriaRoleSupport" />
        </scope>
        <scope doc="This mixin implements Observer-friendly Array-like behavior. It is not a&#xA;concrete implementation, but it can be used up by other classes that want&#xA;to appear like arrays.&#xA;  &#xA;For example, ArrayProxy is a concrete classes that can&#xA;be instantiated to implement array-like behavior. Both of these classes use&#xA;the Array Mixin by way of the MutableArray mixin, which allows observable&#xA;changes to be made to the underlying array.&#xA;  &#xA;Unlike `Ember.Enumerable,` this mixin defines methods specifically for&#xA;collections that provide index-ordered access to their contents. When you&#xA;are designing code that needs to accept any kind of Array-like object, you&#xA;should use these methods instead of Array primitives because these will&#xA;properly notify observers of changes to the array.&#xA;  &#xA;Although these methods are efficient, they do add a layer of indirection to&#xA;your application so it is a good idea to use them only when you need the&#xA;flexibility of using both true JavaScript arrays and &quot;virtual&quot; arrays such&#xA;as controllers and collections.&#xA;  &#xA;You can use the methods defined in this module to access and modify array&#xA;contents in a KVO-friendly way. You can also be notified whenever the&#xA;membership of an array changes by using `.observes(&apos;myArray.[]&apos;)`.&#xA;  &#xA;To support `Ember.Array` in your own class, you must override two&#xA;primitives to use it: `length()` and `objectAt()`.&#xA;  &#xA;Note that the Ember.Array mixin also incorporates the `Ember.Enumerable`&#xA;mixin. All `Ember.Array`-like objects are also enumerable." ilk="class" name="Array">
          <variable attributes="property public" citdl="Number" doc="__Required.__ You must implement this method to apply this mixin.&#xA; Your array must support the `length` property. Your replace methods should&#xA;set this property whenever it changes." name="Array" />
          <scope attributes="public" doc="Returns the object at the given `index`. If the given `index` is negative&#xA;or is greater or equal than the array length, returns `undefined`.&#xA; This is one of the primitives you must implement to support `Ember.Array`.&#xA;If your object supports retrieving the value of an array item using `get()`&#xA;(i.e. `myArray.get(0)`), then you do not need to implement this method&#xA;yourself.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;];&#xA; arr.objectAt(0);   // &apos;a&apos;&#xA;arr.objectAt(3);   // &apos;d&apos;&#xA;arr.objectAt(-1);  // undefined&#xA;arr.objectAt(4);   // undefined&#xA;arr.objectAt(5);   // undefined&#xA;```" ilk="function" name="objectAt" returns="*" signature="objectAt(idx) =&gt; *">
            <variable citdl="Number" doc="The index of the item to return." ilk="argument" name="idx" />
          </scope>
          <scope attributes="public" doc="This returns the objects at the specified indexes, using `objectAt`.&#xA; ```javascript&#xA;var arr =&#160;['a', 'b', 'c', 'd'];&#xA; arr.objectsAt([0, 1, 2]);  // ['a', 'b', 'c']&#xA;arr.objectsAt([2, 3, 4]);  // ['c', 'd', undefined]&#xA;```" ilk="function" name="objectsAt" returns="Array" signature="objectsAt(indexes) =&gt; Array">
            <variable citdl="Array" doc="An array of indexes of items to return." ilk="argument" name="indexes" />
          </scope>
          <variable attributes="property public" doc="This is the handler for the special array content property. If you get&#xA;this property, it will return this. If you set this property to a new&#xA;array, it will replace the current content.&#xA; This property overrides the default property defined in `Ember.Enumerable`." name="Array" />
          <scope attributes="public" doc="Returns a new array that is a slice of the receiver. This implementation&#xA;uses the observable array methods to retrieve the objects for the new&#xA;slice.&#xA; ```javascript&#xA;var arr = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];&#xA; arr.slice(0);       // [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]&#xA;arr.slice(0, 2);    // [&apos;red&apos;, &apos;green&apos;]&#xA;arr.slice(1, 100);  // [&apos;green&apos;, &apos;blue&apos;]&#xA;```" ilk="function" name="slice" returns="Array" signature="slice(beginIndex,endIndex) =&gt; Array">
            <variable citdl="Number" doc="(Optional) index to begin slicing from." ilk="argument" name="beginIndex" />
            <variable citdl="Number" doc="(Optional) index to end the slice at (but not included)." ilk="argument" name="endIndex" />
          </scope>
          <scope attributes="public" doc="Returns the index of the given object&apos;s first occurrence.&#xA;If no `startAt` argument is given, the starting location to&#xA;search is 0. If it&apos;s negative, will count backward from&#xA;the end of the array. Returns -1 if no match is found.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;a&apos;];&#xA; arr.indexOf(&apos;a&apos;);       //  0&#xA;arr.indexOf(&apos;z&apos;);       // -1&#xA;arr.indexOf(&apos;a&apos;, 2);    //  4&#xA;arr.indexOf(&apos;a&apos;, -1);   //  4&#xA;arr.indexOf(&apos;b&apos;, 3);    // -1&#xA;arr.indexOf(&apos;a&apos;, 100);  // -1&#xA;```" ilk="function" name="indexOf" returns="Number" signature="indexOf(object,startAt) =&gt; Number">
            <variable citdl="Object" doc="the item to search for" ilk="argument" name="object" />
            <variable citdl="Number" doc="optional starting location to search, default 0" ilk="argument" name="startAt" />
          </scope>
          <scope attributes="public" doc="Returns the index of the given object&apos;s last occurrence.&#xA;If no `startAt` argument is given, the search starts from&#xA;the last position. If it&apos;s negative, will count backward&#xA;from the end of the array. Returns -1 if no match is found.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;a&apos;];&#xA; arr.lastIndexOf(&apos;a&apos;);       //  4&#xA;arr.lastIndexOf(&apos;z&apos;);       // -1&#xA;arr.lastIndexOf(&apos;a&apos;, 2);    //  0&#xA;arr.lastIndexOf(&apos;a&apos;, -1);   //  4&#xA;arr.lastIndexOf(&apos;b&apos;, 3);    //  1&#xA;arr.lastIndexOf(&apos;a&apos;, 100);  //  4&#xA;```" ilk="function" name="lastIndexOf" returns="Number" signature="lastIndexOf(object,startAt) =&gt; Number">
            <variable citdl="Object" doc="the item to search for" ilk="argument" name="object" />
            <variable citdl="Number" doc="optional starting location to search, default 0" ilk="argument" name="startAt" />
          </scope>
          <scope attributes="public" doc="Adds an array observer to the receiving array. The array observer object&#xA;normally must implement two methods:&#xA; * `arrayWillChange(observedObj, start, removeCount, addCount)` - This method will be&#xA;  called just before the array is modified.&#xA;* `arrayDidChange(observedObj, start, removeCount, addCount)` - This method will be&#xA;  called just after the array is modified.&#xA; Both callbacks will be passed the observed object, starting index of the&#xA;change as well as a count of the items to be removed and added. You can use&#xA;these callbacks to optionally inspect the array during the change, clear&#xA;caches, or do any other bookkeeping necessary.&#xA; In addition to passing a target, you can also include an options hash&#xA;which you can use to override the method names that will be invoked on the&#xA;target." ilk="function" name="addArrayObserver" returns="Ember.Array" signature="addArrayObserver(target,opts) =&gt; Ember.Array">
            <variable citdl="Object" doc="The observer object." ilk="argument" name="target" />
            <variable citdl="Object" doc="Optional hash of configuration options including&#xA;  `willChange` and `didChange` option." ilk="argument" name="opts" />
          </scope>
          <scope attributes="public" doc="Removes an array observer from the object if the observer is current&#xA;registered. Calling this method multiple times with the same object will&#xA;have no effect." ilk="function" name="removeArrayObserver" returns="Ember.Array" signature="removeArrayObserver(target,opts) =&gt; Ember.Array">
            <variable citdl="Object" doc="The object observing the array." ilk="argument" name="target" />
            <variable citdl="Object" doc="Optional hash of configuration options including&#xA;  `willChange` and `didChange` option." ilk="argument" name="opts" />
          </scope>
          <variable attributes="property public" citdl="Boolean" doc="Becomes true whenever the array currently has observers watching changes&#xA;on the array." name="Array" />
          <scope attributes="public" doc="If you are implementing an object that supports `Ember.Array`, call this&#xA;method just before the array content changes to notify any observers and&#xA;invalidate any related properties. Pass the starting index of the change&#xA;as well as a delta of the amounts to change." ilk="function" name="arrayContentWillChange" returns="Ember.Array" signature="arrayContentWillChange(startIdx,removeAmt,addAmt) =&gt; Ember.Array">
            <variable citdl="Number" doc="The starting index in the array that will change." ilk="argument" name="startIdx" />
            <variable citdl="Number" doc="The number of items that will be removed. If you&#xA;  pass `null` assumes 0" ilk="argument" name="removeAmt" />
            <variable citdl="Number" doc="The number of items that will be added. If you&#xA;  pass `null` assumes 0." ilk="argument" name="addAmt" />
          </scope>
          <scope attributes="public" doc="If you are implementing an object that supports `Ember.Array`, call this&#xA;method just after the array content changes to notify any observers and&#xA;invalidate any related properties. Pass the starting index of the change&#xA;as well as a delta of the amounts to change." ilk="function" name="arrayContentDidChange" returns="Ember.Array" signature="arrayContentDidChange(startIdx,removeAmt,addAmt) =&gt; Ember.Array">
            <variable citdl="Number" doc="The starting index in the array that did change." ilk="argument" name="startIdx" />
            <variable citdl="Number" doc="The number of items that were removed. If you&#xA;  pass `null` assumes 0" ilk="argument" name="removeAmt" />
            <variable citdl="Number" doc="The number of items that were added. If you&#xA;  pass `null` assumes 0." ilk="argument" name="addAmt" />
          </scope>
          <variable attributes="property public" doc="Returns a special object that can be used to observe individual properties&#xA;on the array. Just get an equivalent property on this object and it will&#xA;return an enumerable that maps automatically to the named key on the&#xA;member objects.&#xA; If you merely want to watch for any items being added or removed to the array,&#xA;use the `[]` property instead of `@each`." name="Array" />
        </scope>
        <scope classrefs="Ember.Object" doc="An ArrayProxy wraps any other object that implements `Ember.Array` and/or&#xA;`Ember.MutableArray,` forwarding all requests. This makes it very useful for&#xA;a number of binding use cases or other cases where being able to swap&#xA;out the underlying array is useful.&#xA;  &#xA;A simple example of usage:&#xA;  &#xA;```javascript&#xA;var pets = [&apos;dog&apos;, &apos;cat&apos;, &apos;fish&apos;];&#xA;var ap = Ember.ArrayProxy.create({ content: Ember.A(pets) });&#xA;  &#xA;ap.get(&apos;firstObject&apos;);                        // &apos;dog&apos;&#xA;ap.set(&apos;content&apos;, [&apos;amoeba&apos;, &apos;paramecium&apos;]);&#xA;ap.get(&apos;firstObject&apos;);                        // &apos;amoeba&apos;&#xA;```&#xA;  &#xA;This class can also be useful as a layer to transform the contents of&#xA;an array, as they are accessed. This can be done by overriding&#xA;`objectAtContent`:&#xA;  &#xA;```javascript&#xA;var pets = [&apos;dog&apos;, &apos;cat&apos;, &apos;fish&apos;];&#xA;var ap = Ember.ArrayProxy.create({&#xA;    content: Ember.A(pets),&#xA;    objectAtContent: function(idx) {&#xA;        return this.get(&apos;content&apos;).objectAt(idx).toUpperCase();&#xA;    }&#xA;});&#xA;  &#xA;ap.get(&apos;firstObject&apos;); // . &apos;DOG&apos;&#xA;```" ilk="class" name="ArrayProxy">
          <variable attributes="property private" citdl="Ember.Array" doc="The content array. Must be an object that implements `Ember.Array` and/or&#xA;`Ember.MutableArray.`" name="ArrayProxy" />
          <variable attributes="property private" doc="The array that the proxy pretends to be. In the default `ArrayProxy`&#xA;implementation, this and `content` are the same. Subclasses of `ArrayProxy`&#xA;can override this property to provide things like sorting and filtering." name="ArrayProxy" />
          <scope attributes="private" doc="Should actually retrieve the object at the specified index from the&#xA;content. You can override this method in subclasses to transform the&#xA;content item to something new.&#xA; This method will only be called if content is non-`null`." ilk="function" name="objectAtContent" returns="Object" signature="objectAtContent(idx) =&gt; Object">
            <variable citdl="Number" doc="The index to retrieve." ilk="argument" name="idx" />
          </scope>
          <scope attributes="private" doc="Should actually replace the specified objects on the content array.&#xA;You can override this method in subclasses to transform the content item&#xA;into something new.&#xA; This method will only be called if content is non-`null`." ilk="function" name="replaceContent" returns="Void" signature="replaceContent(idx,amt,objects) =&gt; Void">
            <variable citdl="Number" doc="The starting index" ilk="argument" name="idx" />
            <variable citdl="Number" doc="The number of items to remove from the content." ilk="argument" name="amt" />
            <variable citdl="Array" doc="Optional array of objects to insert or null if no&#xA;  objects." ilk="argument" name="objects" />
          </scope>
          <scope attributes="private" doc="Invoked when the content property is about to change. Notifies observers that the&#xA;entire array content will change." ilk="function" name="_contentWillChange" signature="_contentWillChange()" />
          <scope attributes="private" doc="Override to implement content array `willChange` observer." ilk="function" name="contentArrayWillChange" signature="contentArrayWillChange(contentArray,start,removeCount,addCount)">
            <variable citdl="Ember.Array" doc="the content array" ilk="argument" name="contentArray" />
            <variable citdl="Number" doc="starting index of the change" ilk="argument" name="start" />
            <variable citdl="Number" doc="count of items removed" ilk="argument" name="removeCount" />
            <variable citdl="Number" doc="count of items added" ilk="argument" name="addCount" />
          </scope>
          <scope attributes="private" doc="Override to implement content array `didChange` observer." ilk="function" name="contentArrayDidChange" signature="contentArrayDidChange(contentArray,start,removeCount,addCount)">
            <variable citdl="Ember.Array" doc="the content array" ilk="argument" name="contentArray" />
            <variable citdl="Number" doc="starting index of the change" ilk="argument" name="start" />
            <variable citdl="Number" doc="count of items removed" ilk="argument" name="removeCount" />
            <variable citdl="Number" doc="count of items added" ilk="argument" name="addCount" />
          </scope>
          <scope attributes="private" doc="Invoked when the content property changes. Notifies observers that the&#xA;entire array content has changed." ilk="function" name="_contentDidChange" signature="_contentDidChange()" />
        </scope>
        <scope doc="Ember.AutoLocation will select the best location option based off browser&#xA;support with the priority order: history, hash, none.&#xA;  &#xA;Clean pushState paths accessed by hashchange-only browsers will be redirected&#xA;to the hash-equivalent and vice versa so future transitions are consistent.&#xA;  &#xA;Keep in mind that since some of your users will use `HistoryLocation`, your&#xA;server must serve the Ember app at all the routes you define." ilk="class" name="AutoLocation">
          <variable attributes="property private" name="AutoLocation" />
          <variable attributes="property private" name="AutoLocation" />
          <variable attributes="property private" name="AutoLocation" />
          <variable attributes="property private" name="AutoLocation" />
          <variable attributes="property private" name="AutoLocation" />
          <variable attributes="property private" name="AutoLocation" />
          <scope attributes="private" ilk="function" name="_getHashPath" signature="_getHashPath()" />
        </scope>
        <scope doc="An `Ember.Binding` connects the properties of two objects so that whenever&#xA;the value of one property changes, the other property will be changed also.&#xA;  &#xA;## Automatic Creation of Bindings with `/^*Binding/`-named Properties&#xA;  &#xA;You do not usually create Binding objects directly but instead describe&#xA;bindings in your class or object definition using automatic binding&#xA;detection.&#xA;  &#xA;Properties ending in a `Binding` suffix will be converted to `Ember.Binding`&#xA;instances. The value of this property should be a string representing a path&#xA;to another object or a custom binding instance created using Binding helpers&#xA;(see &quot;One Way Bindings&quot;):&#xA;  &#xA;```&#xA;valueBinding: &quot;MyApp.someController.title&quot;&#xA;```&#xA;  &#xA;This will create a binding from `MyApp.someController.title` to the `value`&#xA;property of your object instance automatically. Now the two values will be&#xA;kept in sync.&#xA;  &#xA;## One Way Bindings&#xA;  &#xA;One especially useful binding customization you can use is the `oneWay()`&#xA;helper. This helper tells Ember that you are only interested in&#xA;receiving changes on the object you are binding from. For example, if you&#xA;are binding to a preference and you want to be notified if the preference&#xA;has changed, but your object will not be changing the preference itself, you&#xA;could do:&#xA;  &#xA;```&#xA;bigTitlesBinding: Ember.Binding.oneWay(&quot;MyApp.preferencesController.bigTitles&quot;)&#xA;```&#xA;  &#xA;This way if the value of `MyApp.preferencesController.bigTitles` changes the&#xA;`bigTitles` property of your object will change also. However, if you&#xA;change the value of your `bigTitles` property, it will not update the&#xA;`preferencesController`.&#xA;  &#xA;One way bindings are almost twice as fast to setup and twice as fast to&#xA;execute because the binding only has to worry about changes to one side.&#xA;  &#xA;You should consider using one way bindings anytime you have an object that&#xA;may be created frequently and you do not intend to change a property; only&#xA;to monitor it for changes (such as in the example above).&#xA;  &#xA;## Adding Bindings Manually&#xA;  &#xA;All of the examples above show you how to configure a custom binding, but the&#xA;result of these customizations will be a binding template, not a fully active&#xA;Binding instance. The binding will actually become active only when you&#xA;instantiate the object the binding belongs to. It is useful however, to&#xA;understand what actually happens when the binding is activated.&#xA;  &#xA;For a binding to function it must have at least a `from` property and a `to`&#xA;property. The `from` property path points to the object/key that you want to&#xA;bind from while the `to` path points to the object/key you want to bind to.&#xA;  &#xA;When you define a custom binding, you are usually describing the property&#xA;you want to bind from (such as `MyApp.someController.value` in the examples&#xA;above). When your object is created, it will automatically assign the value&#xA;you want to bind `to` based on the name of your binding key. In the&#xA;examples above, during init, Ember objects will effectively call&#xA;something like this on your binding:&#xA;  &#xA;```javascript&#xA;binding = Ember.Binding.from(&quot;valueBinding&quot;).to(&quot;value&quot;);&#xA;```&#xA;  &#xA;This creates a new binding instance based on the template you provide, and&#xA;sets the to path to the `value` property of the new object. Now that the&#xA;binding is fully configured with a `from` and a `to`, it simply needs to be&#xA;connected to become active. This is done through the `connect()` method:&#xA;  &#xA;```javascript&#xA;binding.connect(this);&#xA;```&#xA;  &#xA;Note that when you connect a binding you pass the object you want it to be&#xA;connected to. This object will be used as the root for both the from and&#xA;to side of the binding when inspecting relative paths. This allows the&#xA;binding to be automatically inherited by subclassed objects as well.&#xA;  &#xA;This also allows you to bind between objects using the paths you declare in&#xA;`from` and `to`:&#xA;  &#xA;```javascript&#xA;// Example 1&#xA;binding = Ember.Binding.from(&quot;App.someObject.value&quot;).to(&quot;value&quot;);&#xA;binding.connect(this);&#xA;  &#xA;// Example 2&#xA;binding = Ember.Binding.from(&quot;parentView.value&quot;).to(&quot;App.someObject.value&quot;);&#xA;binding.connect(this);&#xA;```&#xA;  &#xA;Now that the binding is connected, it will observe both the from and to side&#xA;and relay changes.&#xA;  &#xA;If you ever needed to do so (you almost never will, but it is useful to&#xA;understand this anyway), you could manually create an active binding by&#xA;using the `Ember.bind()` helper method. (This is the same method used by&#xA;to setup your bindings on objects):&#xA;  &#xA;```javascript&#xA;Ember.bind(MyApp.anotherObject, &quot;value&quot;, &quot;MyApp.someController.value&quot;);&#xA;```&#xA;  &#xA;Both of these code fragments have the same effect as doing the most friendly&#xA;form of binding creation like so:&#xA;  &#xA;```javascript&#xA;MyApp.anotherObject = Ember.Object.create({&#xA;  valueBinding: &quot;MyApp.someController.value&quot;,&#xA;  &#xA;  // OTHER CODE FOR THIS OBJECT...&#xA;});&#xA;```&#xA;  &#xA;Ember&apos;s built in binding creation method makes it easy to automatically&#xA;create bindings for you. You should always use the highest-level APIs&#xA;available, even if you understand how it works underneath." ilk="class" name="Binding">
          <scope attributes="public" doc="This copies the Binding so it can be connected to another object." ilk="function" name="copy" returns="Ember.Binding" signature="copy() =&gt; Ember.Binding" />
          <scope attributes="public" doc="This will set `from` property path to the specified value. It will not&#xA;attempt to resolve this property path to an actual object until you&#xA;connect the binding.&#xA; The binding will search for the property path starting at the root object&#xA;you pass when you `connect()` the binding. It follows the same rules as&#xA;`get()` - see that method for more information." ilk="function" name="from" returns="Ember.Binding" signature="from(path) =&gt; Ember.Binding">
            <variable citdl="String" doc="the property path to connect to" ilk="argument" name="path" />
          </scope>
          <scope attributes="public" doc="This will set the `to` property path to the specified value. It will not&#xA;attempt to resolve this property path to an actual object until you&#xA;connect the binding.&#xA; The binding will search for the property path starting at the root object&#xA;you pass when you `connect()` the binding. It follows the same rules as&#xA;`get()` - see that method for more information." ilk="function" name="to" returns="Ember.Binding" signature="to(path) =&gt; Ember.Binding">
            <variable citdl="String|Tuple" doc="A property path or tuple" ilk="argument" name="path" />
          </scope>
          <scope attributes="public" doc="Configures the binding as one way. A one-way binding will relay changes&#xA;on the `from` side to the `to` side, but not the other way around. This&#xA;means that if you change the `to` side directly, the `from` side may have&#xA;a different value." ilk="function" name="oneWay" returns="Ember.Binding" signature="oneWay() =&gt; Ember.Binding" />
          <scope attributes="public" ilk="function" name="toString" returns="String" signature="toString() =&gt; String" />
          <scope attributes="public" doc="Attempts to connect this binding instance so that it can receive and relay&#xA;changes. This method will raise an exception if you have not set the&#xA;from/to properties yet." ilk="function" name="connect" returns="Ember.Binding" signature="connect(obj) =&gt; Ember.Binding">
            <variable citdl="Object" doc="The root object for this binding." ilk="argument" name="obj" />
          </scope>
          <scope attributes="public" doc="Disconnects the binding instance. Changes will no longer be relayed. You&#xA;will not usually need to call this method." ilk="function" name="disconnect" returns="Ember.Binding" signature="disconnect(obj) =&gt; Ember.Binding">
            <variable citdl="Object" doc="The root object you passed when connecting the binding." ilk="argument" name="obj" />
          </scope>
        </scope>
        <scope classrefs="Ember.Component" doc="The internal class used to create text inputs when the `{{input}}`&#xA;helper is used with `type` of `checkbox`.&#xA;  &#xA;See [Ember.Templates.helpers.input](/api/classes/Ember.Templates.helpers.html#method_input)  for usage details.&#xA;  &#xA;## Direct manipulation of `checked`&#xA;  &#xA;The `checked` attribute of an `Ember.Checkbox` object should always be set&#xA;through the Ember object or by interacting with its rendered element&#xA;representation via the mouse, keyboard, or touch. Updating the value of the&#xA;checkbox via jQuery will result in the checked value of the object and its&#xA;element losing synchronization.&#xA;  &#xA;## Layout and LayoutName properties&#xA;  &#xA;Because HTML `input` elements are self closing `layout` and `layoutName`&#xA;properties will not be applied. See [Ember.View](/api/classes/Ember.View.html)&apos;s&#xA;layout section for more information." ilk="class" name="Checkbox" />
        <scope ilk="class" name="ClassNamesSupport">
          <variable attributes="property public" citdl="Array" doc="Standard CSS class names to apply to the view&apos;s outer element. This&#xA;property automatically inherits any class names defined by the view&apos;s&#xA;superclasses as well." name="ClassNamesSupport" />
          <variable attributes="property public" citdl="Array" doc="A list of properties of the view to apply as class names. If the property&#xA;is a string value, the value of that string will be applied as a class&#xA;name.&#xA; ```javascript&#xA;// Applies the &apos;high&apos; class to the view element&#xA;Ember.View.extend({&#xA;  classNameBindings: [&apos;priority&apos;],&#xA;  priority: &apos;high&apos;&#xA;});&#xA;```&#xA; If the value of the property is a Boolean, the name of that property is&#xA;added as a dasherized class name.&#xA; ```javascript&#xA;// Applies the &apos;is-urgent&apos; class to the view element&#xA;Ember.View.extend({&#xA;  classNameBindings: [&apos;isUrgent&apos;],&#xA;  isUrgent: true&#xA;});&#xA;```&#xA; If you would prefer to use a custom value instead of the dasherized&#xA;property name, you can pass a binding like this:&#xA; ```javascript&#xA;// Applies the &apos;urgent&apos; class to the view element&#xA;Ember.View.extend({&#xA;  classNameBindings: [&apos;isUrgent:urgent&apos;],&#xA;  isUrgent: true&#xA;});&#xA;```&#xA; This list of properties is inherited from the view&apos;s superclasses as well." name="ClassNamesSupport" />
        </scope>
        <scope classrefs="Ember.ContainerView" doc="`Ember.CollectionView` is an `Ember.View` descendent responsible for managing&#xA;a collection (an array or array-like object) by maintaining a child view object&#xA;and associated DOM representation for each item in the array and ensuring&#xA;that child views and their associated rendered HTML are updated when items in&#xA;the array are added, removed, or replaced.&#xA;  &#xA;## Setting content&#xA;  &#xA;The managed collection of objects is referenced as the `Ember.CollectionView`&#xA;instance&apos;s `content` property.&#xA;  &#xA;```javascript&#xA;someItemsView = Ember.CollectionView.create({&#xA;  content: [&apos;A&apos;, &apos;B&apos;,&apos;C&apos;]&#xA;})&#xA;```&#xA;  &#xA;The view for each item in the collection will have its `content` property set&#xA;to the item.&#xA;  &#xA;## Specifying `itemViewClass`&#xA;  &#xA;By default the view class for each item in the managed collection will be an&#xA;instance of `Ember.View`. You can supply a different class by setting the&#xA;`CollectionView`&apos;s `itemViewClass` property.&#xA;  &#xA;Given the following application code:&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create();&#xA;App.ItemListView = Ember.CollectionView.extend({&#xA;  classNames: [&apos;a-collection&apos;],&#xA;  content: [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;],&#xA;  itemViewClass: Ember.View.extend({&#xA;    template: Ember.HTMLBars.compile(&quot;the letter: {{view.content}}&quot;)&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;And a simple application template:&#xA;  &#xA;```handlebars&#xA;{{view &apos;item-list&apos;}}&#xA;```&#xA;  &#xA;The following HTML will result:&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view a-collection&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;the letter: A&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;the letter: B&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;the letter: C&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;## Automatic matching of parent/child tagNames&#xA;  &#xA;Setting the `tagName` property of a `CollectionView` to any of&#xA;&quot;ul&quot;, &quot;ol&quot;, &quot;table&quot;, &quot;thead&quot;, &quot;tbody&quot;, &quot;tfoot&quot;, &quot;tr&quot;, or &quot;select&quot; will result&#xA;in the item views receiving an appropriately matched `tagName` property.&#xA;  &#xA;Given the following application code:&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create();&#xA;App.UnorderedListView = Ember.CollectionView.create({&#xA;  tagName: &apos;ul&apos;,&#xA;  content: [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;],&#xA;  itemViewClass: Ember.View.extend({&#xA;    template: Ember.HTMLBars.compile(&quot;the letter: {{view.content}}&quot;)&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;And a simple application template:&#xA;  &#xA;```handlebars&#xA;{{view &apos;unordered-list-view&apos;}}&#xA;```&#xA;  &#xA;The following HTML will result:&#xA;  &#xA;```html&#xA;&lt;ul class=&quot;ember-view a-collection&quot;&gt;&#xA;  &lt;li class=&quot;ember-view&quot;&gt;the letter: A&lt;/li&gt;&#xA;  &lt;li class=&quot;ember-view&quot;&gt;the letter: B&lt;/li&gt;&#xA;  &lt;li class=&quot;ember-view&quot;&gt;the letter: C&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;```&#xA;  &#xA;Additional `tagName` pairs can be provided by adding to&#xA;`Ember.CollectionView.CONTAINER_MAP`. For example:&#xA;  &#xA;```javascript&#xA;Ember.CollectionView.CONTAINER_MAP[&apos;article&apos;] = &apos;section&apos;&#xA;```&#xA;  &#xA;## Programmatic creation of child views&#xA;  &#xA;For cases where additional customization beyond the use of a single&#xA;`itemViewClass` or `tagName` matching is required CollectionView&apos;s&#xA;`createChildView` method can be overridden:&#xA;  &#xA;```javascript&#xA;App.CustomCollectionView = Ember.CollectionView.extend({&#xA;  createChildView: function(viewClass, attrs) {&#xA;    if (attrs.content.kind == &apos;album&apos;) {&#xA;      viewClass = App.AlbumView;&#xA;    } else {&#xA;      viewClass = App.SongView;&#xA;    }&#xA;    return this._super(viewClass, attrs);&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;## Empty View&#xA;  &#xA;You can provide an `Ember.View` subclass to the `Ember.CollectionView`&#xA;instance as its `emptyView` property. If the `content` property of a&#xA;`CollectionView` is set to `null` or an empty array, an instance of this view&#xA;will be the `CollectionView`s only child.&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create();&#xA;App.ListWithNothing = Ember.CollectionView.create({&#xA;  classNames: [&apos;nothing&apos;],&#xA;  content: null,&#xA;  emptyView: Ember.View.extend({&#xA;    template: Ember.HTMLBars.compile(&quot;The collection is empty&quot;)&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;And a simple application template:&#xA;  &#xA;```handlebars&#xA;{{view &apos;list-with-nothing&apos;}}&#xA;```&#xA;  &#xA;The following HTML will result:&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view nothing&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;&#xA;    The collection is empty&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;## Adding and Removing items&#xA;  &#xA;The `childViews` property of a `CollectionView` should not be directly&#xA;manipulated. Instead, add, remove, replace items from its `content` property.&#xA;This will trigger appropriate changes to its rendered HTML." ilk="class" name="CollectionView">
          <variable attributes="property private" citdl="Ember.Array" doc="A list of items to be displayed by the `Ember.CollectionView`." name="CollectionView" />
          <variable attributes="property private" citdl="Ember.View" name="CollectionView" />
          <scope attributes="private" doc="Setup a CollectionView" ilk="function" name="init" signature="init()" />
          <scope attributes="private" doc="Check to make sure that the content has changed, and if so,&#xA;update the children directly. This is always scheduled&#xA;asynchronously, to allow the element to be created before&#xA;bindings have synchronized and vice versa." ilk="function" name="_contentDidChange" signature="_contentDidChange()" />
          <scope attributes="private" doc="Ensure that the content implements Ember.Array" ilk="function" name="_assertArrayLike" signature="_assertArrayLike()" />
          <scope attributes="private" doc="Removes the content and content observers." ilk="function" name="destroy" signature="destroy()" />
          <scope attributes="private" doc="Called when a mutation to the underlying content array will occur.&#xA; This method will remove any views that are no longer in the underlying&#xA;content array.&#xA; Invokes whenever the content array itself will change." ilk="function" name="arrayWillChange" signature="arrayWillChange(content,start,removed)">
            <variable citdl="Array" doc="the managed collection of objects" ilk="argument" name="content" />
            <variable citdl="Number" doc="the index at which the changes will occur" ilk="argument" name="start" />
            <variable citdl="Number" doc="number of object to be removed from content" ilk="argument" name="removed" />
          </scope>
          <scope attributes="private" doc="Called when a mutation to the underlying content array occurs.&#xA; This method will replay that mutation against the views that compose the&#xA;`Ember.CollectionView`, ensuring that the view reflects the model.&#xA; This array observer is added in `contentDidChange`." ilk="function" name="arrayDidChange" signature="arrayDidChange(content,start,removed,added)">
            <variable citdl="Array" doc="the managed collection of objects" ilk="argument" name="content" />
            <variable citdl="Number" doc="the index at which the changes occurred" ilk="argument" name="start" />
            <variable citdl="Number" doc="number of object removed from content" ilk="argument" name="removed" />
            <variable citdl="Number" doc="number of object added to content" ilk="argument" name="added" />
          </scope>
          <scope attributes="private" doc="Instantiates a view to be added to the childViews array during view&#xA;initialization. You generally will not call this method directly unless&#xA;you are overriding `createChildViews()`. Note that this method will&#xA;automatically configure the correct settings on the new view instance to&#xA;act as a child of the parent.&#xA; The tag name for the view will be set to the tagName of the viewClass&#xA;passed in." ilk="function" name="createChildView" returns="Ember.View" signature="createChildView(viewClass,attrs) =&gt; Ember.View">
            <variable citdl="Class" ilk="argument" name="viewClass" />
            <variable citdl="Object" doc="Attributes to add" ilk="argument" name="attrs" />
          </scope>
          <variable attributes="property private" citdl="Object" doc="A map of parent tags to their default child tags. You can add&#xA;additional parent tags if you want collection views that use&#xA;a particular parent tag to default to a child tag." name="CollectionView" />
        </scope>
        <scope doc="Implements some standard methods for comparing objects. Add this mixin to&#xA;any class you create that can compare its instances.&#xA;  &#xA;You should implement the `compare()` method." ilk="class" name="Comparable">
          <scope attributes="private" doc="__Required.__ You must implement this method to apply this mixin.&#xA; Override to return the result of the comparison of the two parameters. The&#xA;compare method should return:&#xA; - `-1` if `a &lt; b`&#xA;- `0` if `a == b`&#xA;- `1` if `a &gt; b`&#xA; Default implementation raises an exception." ilk="function" name="compare" returns="Number" signature="compare(a,b) =&gt; Number">
            <variable citdl="Object" doc="the first object to compare" ilk="argument" name="a" />
            <variable citdl="Object" doc="the second object to compare" ilk="argument" name="b" />
          </scope>
        </scope>
        <scope classrefs="Ember.View" doc="An `Ember.Component` is a view that is completely&#xA;isolated. Properties accessed in its templates go&#xA;to the view object and actions are targeted at&#xA;the view object. There is no access to the&#xA;surrounding context or outer controller; all&#xA;contextual information must be passed in.&#xA;  &#xA;The easiest way to create an `Ember.Component` is via&#xA;a template. If you name a template&#xA;`components/my-foo`, you will be able to use&#xA;`{{my-foo}}` in other templates, which will make&#xA;an instance of the isolated component.&#xA;  &#xA;```handlebars&#xA;{{app-profile person=currentUser}}&#xA;```&#xA;  &#xA;```handlebars&#xA;&lt;!-- app-profile template --&gt;&#xA;&lt;h1&gt;{{person.title}}&lt;/h1&gt;&#xA;&lt;img src={{person.avatar}}&gt;&#xA;&lt;p class=&apos;signature&apos;&gt;{{person.signature}}&lt;/p&gt;&#xA;```&#xA;  &#xA;You can use `yield` inside a template to&#xA;include the **contents** of any block attached to&#xA;the component. The block will be executed in the&#xA;context of the surrounding context or outer controller:&#xA;  &#xA;```handlebars&#xA;{{#app-profile person=currentUser}}&#xA;  &lt;p&gt;Admin mode&lt;/p&gt;&#xA;  {{! Executed in the controller&apos;s context. }}&#xA;{{/app-profile}}&#xA;```&#xA;  &#xA;```handlebars&#xA;&lt;!-- app-profile template --&gt;&#xA;&lt;h1&gt;{{person.title}}&lt;/h1&gt;&#xA;{{! Executed in the components context. }}&#xA;{{yield}} {{! block contents }}&#xA;```&#xA;  &#xA;If you want to customize the component, in order to&#xA;handle events or actions, you implement a subclass&#xA;of `Ember.Component` named after the name of the&#xA;component. Note that `Component` needs to be appended to the name of&#xA;your subclass like `AppProfileComponent`.&#xA;  &#xA;For example, you could implement the action&#xA;`hello` for the `app-profile` component:&#xA;  &#xA;```javascript&#xA;App.AppProfileComponent = Ember.Component.extend({&#xA;  actions: {&#xA;    hello: function(name) {&#xA;      console.log(&quot;Hello&quot;, name);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;And then use it in the component&apos;s template:&#xA;  &#xA;```handlebars&#xA;&lt;!-- app-profile template --&gt;&#xA;  &#xA;&lt;h1&gt;{{person.title}}&lt;/h1&gt;&#xA;{{yield}} &lt;!-- block contents --&gt;&#xA;  &#xA;&lt;button {{action &apos;hello&apos; person.name}}&gt;&#xA;  Say Hello to {{person.name}}&#xA;&lt;/button&gt;&#xA;```&#xA;  &#xA;Components must have a `-` in their name to avoid&#xA;conflicts with built-in controls that wrap HTML&#xA;elements. This is consistent with the same&#xA;requirement in web components." ilk="class" name="Component">
          <variable attributes="property private" citdl="Ember.Controller" doc="If the component is currently inserted into the DOM of a parent view, this&#xA;property will point to the controller of the parent view." name="Component" />
          <scope attributes="public" doc="Calls a action passed to a component.&#xA; For example a component for playing or pausing music may translate click events&#xA;into action notifications of &quot;play&quot; or &quot;stop&quot; depending on some internal state&#xA;of the component:&#xA; ```javascript&#xA;// app/components/play-button.js&#xA;export default Ember.Component.extend({&#xA;  click() {&#xA;    if (this.get(&apos;isPlaying&apos;)) {&#xA;      this.sendAction(&apos;play&apos;);&#xA;    } else {&#xA;      this.sendAction(&apos;stop&apos;);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; The actions &quot;play&quot; and &quot;stop&quot; must be passed to this `play-button` component:&#xA; ```handlebars&#xA;{{! app/templates/application.hbs }}&#xA;{{play-button play=(action &quot;musicStarted&quot;) stop=(action &quot;musicStopped&quot;)}}&#xA;```&#xA; When the component receives a browser `click` event it translate this&#xA;interaction into application-specific semantics (&quot;play&quot; or &quot;stop&quot;) and&#xA;calls the specified action.&#xA; ```javascript&#xA;// app/controller/application.js&#xA;export default Ember.Controller.extend({&#xA;  actions: {&#xA;    musicStarted() {&#xA;      // called when the play button is clicked&#xA;      // and the music started playing&#xA;    },&#xA;    musicStopped() {&#xA;      // called when the play button is clicked&#xA;      // and the music stopped playing&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; If no action is passed to `sendAction` a default name of &quot;action&quot;&#xA;is assumed.&#xA; ```javascript&#xA;// app/components/next-button.js&#xA;export default Ember.Component.extend({&#xA;  click() {&#xA;    this.sendAction();&#xA;  }&#xA;});&#xA;```&#xA; ```handlebars&#xA;{{! app/templates/application.hbs }}&#xA;{{next-button action=(action &quot;playNextSongInAlbum&quot;)}}&#xA;```&#xA; ```javascript&#xA;// app/controllers/application.js&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  actions: {&#xA;    playNextSongInAlbum() {&#xA;      ...&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="sendAction" signature="sendAction(action,params)">
            <variable citdl="String" doc="the action to call" ilk="argument" name="action" />
            <variable citdl="*" doc="arguments for the action" ilk="argument" name="params" />
          </scope>
          <variable attributes="property public" doc="Returns true when the component was invoked with a block template.&#xA; Example (`hasBlock` will be `false`):&#xA; ```hbs&#xA;{{! templates/application.hbs }}&#xA; {{foo-bar}}&#xA; {{! templates/components/foo-bar.hbs }}&#xA;{{#if hasBlock}}&#xA;  This will not be printed, because no block was provided&#xA;{{/if}}&#xA;```&#xA; Example (`hasBlock` will be `true`):&#xA; ```hbs&#xA;{{! templates/application.hbs }}&#xA; {{#foo-bar}}&#xA;  Hi!&#xA;{{/foo-bar}}&#xA; {{! templates/components/foo-bar.hbs }}&#xA;{{#if hasBlock}}&#xA;  This will be printed because a block was provided&#xA;  {{yield}}&#xA;{{/if}}&#xA;```&#xA; This helper accepts an argument with the name of the block we want to check the presence of.&#xA;This is useful for checking for the presence of the optional inverse block in components.&#xA; ```hbs&#xA;{{! templates/application.hbs }}&#xA; {{#foo-bar}}&#xA;  Hi!&#xA;{{else}}&#xA;  What&apos;s up?&#xA;{{/foo-bar}}&#xA; {{! templates/components/foo-bar.hbs }}&#xA;{{yield}}&#xA;{{#if (hasBlock &quot;inverse&quot;)}}&#xA;  {{yield to=&quot;inverse&quot;}}&#xA;{{else}}&#xA;  How are you?&#xA;{{/if}}&#xA;```" name="Component" />
          <variable attributes="property public" doc="Returns true when the component was invoked with a block parameter&#xA;supplied.&#xA; Example (`hasBlockParams` will be `false`):&#xA; ```hbs&#xA;{{! templates/application.hbs }}&#xA; {{#foo-bar}}&#xA;  No block parameter.&#xA;{{/foo-bar}}&#xA; {{! templates/components/foo-bar.hbs }}&#xA;{{#if hasBlockParams}}&#xA;  This will not be printed, because no block was provided&#xA;  {{yield this}}&#xA;{{/if}}&#xA;```&#xA; Example (`hasBlockParams` will be `true`):&#xA; ```hbs&#xA;{{! templates/application.hbs }}&#xA; {{#foo-bar as |foo|}}&#xA;  Hi!&#xA;{{/foo-bar}}&#xA; {{! templates/components/foo-bar.hbs }}&#xA;{{#if hasBlockParams}}&#xA;  This will be printed because a block was provided&#xA;  {{yield this}}&#xA;{{/if}}&#xA;```" name="Component" />
          <variable attributes="property public" doc="Enables components to take a list of parameters as arguments&#xA; For example a component that takes two parameters with the names&#xA;`name` and `age`:&#xA; ```javascript&#xA;let MyComponent = Ember.Component.extend;&#xA;MyComponent.reopenClass({&#xA;  positionalParams: [&apos;name&apos;, &apos;age&apos;]&#xA;});&#xA;```&#xA; It can then be invoked like this:&#xA; ```hbs&#xA;{{my-component &quot;John&quot; 38}}&#xA;```&#xA; The parameters can be refered to just like named parameters:&#xA; ```hbs&#xA;Name: {{attrs.name}}, Age: {{attrs.age}}.&#xA;```&#xA; Using a string instead of an array allows for an arbitrary number of&#xA;parameters:&#xA; ```javascript&#xA;let MyComponent = Ember.Component.extend;&#xA;MyComponent.reopenClass({&#xA;  positionalParams: &apos;names&apos;&#xA;});&#xA;```&#xA; It can then be invoked like this:&#xA; ```hbs&#xA;{{my-component &quot;John&quot; &quot;Michael&quot; &quot;Scott&quot;}}&#xA;```&#xA; The parameters can then be refered to by enumerating over the list:&#xA; ```hbs&#xA;{{#each attrs.names as |name|}}{{name}}{{/each}}&#xA;```" name="Component" />
        </scope>
        <scope doc="A computed property transforms an object literal with object&apos;s accessor function(s) into a property.&#xA;  &#xA;By default the function backing the computed property will only be called&#xA;once and the result will be cached. You can specify various properties&#xA;that your computed property depends on. This will force the cached&#xA;result to be recomputed if the dependencies are modified.&#xA;  &#xA;In the following example we declare a computed property - `fullName` - by calling&#xA;`.Ember.computed()` with property dependencies (`firstName` and `lastName`) as leading arguments and getter accessor function. The `fullName` getter function&#xA;will be called once (regardless of how many times it is accessed) as long&#xA;as its dependencies have not changed. Once `firstName` or `lastName` are updated&#xA;any future calls (or anything bound) to `fullName` will incorporate the new&#xA;values.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  // these will be supplied by `create`&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  &#xA;  fullName: Ember.computed(&apos;firstName&apos;, &apos;lastName&apos;, function() {&#xA;    let firstName = this.get(&apos;firstName&apos;),&#xA;        lastName  = this.get(&apos;lastName&apos;);&#xA;  &#xA;    return firstName + &apos; &apos; + lastName;&#xA;  })&#xA;});&#xA;  &#xA;let tom = Person.create({&#xA;  firstName: &apos;Tom&apos;,&#xA;  lastName: &apos;Dale&apos;&#xA;});&#xA;  &#xA;tom.get(&apos;fullName&apos;) // &apos;Tom Dale&apos;&#xA;```&#xA;  &#xA;You can also define what Ember should do when setting a computed property by providing additional function (`set`) in hash argument.&#xA;If you try to set a computed property, it will try to invoke setter accessor function with the key and&#xA;value you want to set it to as arguments.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  // these will be supplied by `create`&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  &#xA;  fullName: Ember.computed(&apos;firstName&apos;, &apos;lastName&apos;, {&#xA;    get(key) {&#xA;      let firstName = this.get(&apos;firstName&apos;),&#xA;          lastName  = this.get(&apos;lastName&apos;);&#xA;  &#xA;      return firstName + &apos; &apos; + lastName;&#xA;    },&#xA;    set(key, value) {&#xA;      let [firstName, lastName] = value.split(&apos; &apos;);&#xA;  &#xA;      this.set(&apos;firstName&apos;, firstName);&#xA;      this.set(&apos;lastName&apos;, lastName);&#xA;  &#xA;      return value;&#xA;    }&#xA;  })&#xA;});&#xA;  &#xA;let person = Person.create();&#xA;  &#xA;person.set(&apos;fullName&apos;, &apos;Peter Wagenet&apos;);&#xA;person.get(&apos;firstName&apos;); // &apos;Peter&apos;&#xA;person.get(&apos;lastName&apos;);  // &apos;Wagenet&apos;&#xA;```&#xA;  &#xA;You can overwrite computed property with normal property (no longer computed), that won&apos;t change if dependencies change, if you set computed property and it won&apos;t have setter accessor function defined.&#xA;  &#xA;You can also mark computed property as `.readOnly()` and block all attempts to set it.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  // these will be supplied by `create`&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  &#xA;  fullName: Ember.computed(&apos;firstName&apos;, &apos;lastName&apos;, {&#xA;    get(key) {&#xA;      let firstName = this.get(&apos;firstName&apos;);&#xA;      let lastName  = this.get(&apos;lastName&apos;);&#xA;  &#xA;      return firstName + &apos; &apos; + lastName;&#xA;    }&#xA;  }).readOnly()&#xA;});&#xA;  &#xA;let person = Person.create();&#xA;person.set(&apos;fullName&apos;, &apos;Peter Wagenet&apos;); // Uncaught Error: Cannot set read-only property &quot;fullName&quot; on object: &lt;(...):emberXXX&gt;&#xA;```&#xA;  &#xA;Additional resources:&#xA;- [New CP syntax RFC](https://github.com/emberjs/rfcs/blob/master/text/0011-improved-cp-syntax.md)&#xA;- [New computed syntax explained in &quot;Ember 1.12 released&quot; ](http://emberjs.com/blog/2015/05/13/ember-1-12-released.html#toc_new-computed-syntax)" ilk="class" name="ComputedProperty">
          <scope attributes="public" doc="Call on a computed property to set it into non-cached mode. When in this&#xA;mode the computed property will not automatically cache the return value.&#xA;  &#xA;It also does not automatically fire any change events. You must manually notify&#xA;any changes if you want to observe this property.&#xA;  &#xA;Dependency keys have no effect on volatile properties as they are for cache&#xA;invalidation and notification when cached value is invalidated.&#xA;  &#xA;```javascript&#xA;let outsideService = Ember.Object.extend({&#xA;  value: Ember.computed(function() {&#xA;    return OutsideService.getValue();&#xA;  }).volatile()&#xA;}).create();&#xA;```" ilk="function" name="volatile" returns="Ember.ComputedProperty" signature="volatile() =&gt; Ember.ComputedProperty" />
          <scope attributes="public" doc="Call on a computed property to set it into read-only mode. When in this&#xA;mode the computed property will throw an error when set.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  guid: Ember.computed(function() {&#xA;    return &apos;guid-guid-guid&apos;;&#xA;  }).readOnly()&#xA;});&#xA;  &#xA;let person = Person.create();&#xA;  &#xA;person.set(&apos;guid&apos;, &apos;new-guid&apos;); // will throw an exception&#xA;```" ilk="function" name="readOnly" returns="Ember.ComputedProperty" signature="readOnly() =&gt; Ember.ComputedProperty" />
          <scope attributes="public" doc="Sets the dependent keys on this computed property. Pass any number of&#xA;arguments containing key paths that this computed property depends on.&#xA;  &#xA;```javascript&#xA;let President = Ember.Object.extend({&#xA;  fullName: Ember.computed(function() {&#xA;    return this.get(&apos;firstName&apos;) + &apos; &apos; + this.get(&apos;lastName&apos;);&#xA;  &#xA;    // Tell Ember that this computed property depends on firstName&#xA;    // and lastName&#xA;  }).property(&apos;firstName&apos;, &apos;lastName&apos;)&#xA;});&#xA;  &#xA;let president = President.create({&#xA;  firstName: &apos;Barack&apos;,&#xA;  lastName: &apos;Obama&apos;&#xA;});&#xA;  &#xA;president.get(&apos;fullName&apos;); // &apos;Barack Obama&apos;&#xA;```" ilk="function" name="property" returns="Ember.ComputedProperty" signature="property(path) =&gt; Ember.ComputedProperty">
            <variable citdl="String" doc="zero or more property paths" ilk="argument" name="path" />
          </scope>
          <scope attributes="public" doc="In some cases, you may want to annotate computed properties with additional&#xA;metadata about how they function or what values they operate on. For example,&#xA;computed property functions may close over variables that are then no longer&#xA;available for introspection.&#xA;  &#xA;You can pass a hash of these values to a computed property like this:&#xA;  &#xA;```&#xA;person: Ember.computed(function() {&#xA;  let personId = this.get(&apos;personId&apos;);&#xA;  return App.Person.create({ id: personId });&#xA;}).meta({ type: App.Person })&#xA;```&#xA;  &#xA;The hash that you pass to the `meta()` function will be saved on the&#xA;computed property descriptor under the `_meta` key. Ember runtime&#xA;exposes a public API for retrieving these values from classes,&#xA;via the `metaForProperty()` function." ilk="function" name="meta" signature="meta(meta)">
            <variable citdl="Object" ilk="argument" name="meta" />
          </scope>
          <scope attributes="public" doc="Access the value of the function backing the computed property.&#xA;If this property has already been cached, return the cached result.&#xA;Otherwise, call the function passing the property name as an argument.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  fullName: Ember.computed(&apos;firstName&apos;, &apos;lastName&apos;, function(keyName) {&#xA;    // the keyName parameter is &apos;fullName&apos; in this case.&#xA;    return this.get(&apos;firstName&apos;) + &apos; &apos; + this.get(&apos;lastName&apos;);&#xA;  })&#xA;});&#xA;  &#xA;  &#xA;let tom = Person.create({&#xA;  firstName: &apos;Tom&apos;,&#xA;  lastName: &apos;Dale&apos;&#xA;});&#xA;  &#xA;tom.get(&apos;fullName&apos;) // &apos;Tom Dale&apos;&#xA;```" ilk="function" name="get" returns="Object" signature="get(keyName) =&gt; Object">
            <variable citdl="String" doc="The key being accessed." ilk="argument" name="keyName" />
          </scope>
          <scope attributes="public" doc="Set the value of a computed property. If the function that backs your&#xA;computed property does not accept arguments then the default action for&#xA;setting would be to define the property on the current object, and set&#xA;the value of the property to the value being set.&#xA;  &#xA;Generally speaking if you intend for your computed property to be set&#xA;you should pass `set(key, value)` function in hash as argument to `Ember.computed()` along with `get(key)` function.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  // these will be supplied by `create`&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  &#xA;  fullName: Ember.computed(&apos;firstName&apos;, &apos;lastName&apos;, {&#xA;    // getter&#xA;    get() {&#xA;      let firstName = this.get(&apos;firstName&apos;);&#xA;      let lastName = this.get(&apos;lastName&apos;);&#xA;  &#xA;      return firstName + &apos; &apos; + lastName;&#xA;    },&#xA;    // setter&#xA;    set(key, value) {&#xA;      let [firstName, lastName] = value.split(&apos; &apos;);&#xA;  &#xA;      this.set(&apos;firstName&apos;, firstName);&#xA;      this.set(&apos;lastName&apos;, lastName);&#xA;  &#xA;      return value;&#xA;    }&#xA;  })&#xA;});&#xA;  &#xA;let person = Person.create();&#xA;  &#xA;person.set(&apos;fullName&apos;, &apos;Peter Wagenet&apos;);&#xA;person.get(&apos;firstName&apos;); // &apos;Peter&apos;&#xA;person.get(&apos;lastName&apos;);  // &apos;Wagenet&apos;&#xA;```" ilk="function" name="set" returns="Object" signature="set(keyName,newValue) =&gt; Object">
            <variable citdl="String" doc="The key being accessed." ilk="argument" name="keyName" />
            <variable citdl="Object" doc="The new value being assigned." ilk="argument" name="newValue" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="The `ContainerDebugAdapter` helps the container and resolver interface&#xA;with tools that debug Ember such as the&#xA;[Ember Extension](https://github.com/tildeio/ember-extension)&#xA;for Chrome and Firefox.&#xA;  &#xA;This class can be extended by a custom resolver implementer&#xA;to override some of the methods with library-specific code.&#xA;  &#xA;The methods likely to be overridden are:&#xA;  &#xA;* `canCatalogEntriesByType`&#xA;* `catalogEntriesByType`&#xA;  &#xA;The adapter will need to be registered&#xA;in the application&apos;s container as `container-debug-adapter:main`&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;Application.initializer({&#xA;  name: &quot;containerDebugAdapter&quot;,&#xA;  &#xA;  initialize: function(application) {&#xA;    application.register(&apos;container-debug-adapter:main&apos;, require(&apos;app/container-debug-adapter&apos;));&#xA;  }&#xA;});&#xA;```" ilk="class" name="ContainerDebugAdapter">
          <variable attributes="property public" doc="The resolver instance of the application&#xA;being debugged. This property will be injected&#xA;on creation." name="ContainerDebugAdapter" />
          <scope attributes="public" doc="Returns true if it is possible to catalog a list of available&#xA;classes in the resolver for a given type." ilk="function" name="canCatalogEntriesByType" returns="Boolean" signature="canCatalogEntriesByType(type) =&gt; Boolean">
            <variable citdl="String" doc="The type. e.g. &quot;model&quot;, &quot;controller&quot;, &quot;route&quot;" ilk="argument" name="type" />
          </scope>
          <scope attributes="public" doc="Returns the available classes a given type." ilk="function" name="catalogEntriesByType" returns="Array" signature="catalogEntriesByType(type) =&gt; Array">
            <variable citdl="String" doc="The type. e.g. &quot;model&quot;, &quot;controller&quot;, &quot;route&quot;" ilk="argument" name="type" />
          </scope>
        </scope>
        <scope classrefs="Ember.View" doc="A `ContainerView` is an `Ember.View` subclass that implements `Ember.MutableArray`&#xA;allowing programmatic management of its child views.&#xA;  &#xA;## Setting Initial Child Views&#xA;  &#xA;The initial array of child views can be set in one of two ways. You can&#xA;provide a `childViews` property at creation time that contains instance of&#xA;`Ember.View`:&#xA;  &#xA;```javascript&#xA;aContainer = Ember.ContainerView.create({&#xA;  childViews: [Ember.View.create(), Ember.View.create()]&#xA;});&#xA;```&#xA;  &#xA;You can also provide a list of property names whose values are instances of&#xA;`Ember.View`:&#xA;  &#xA;```javascript&#xA;aContainer = Ember.ContainerView.create({&#xA;  childViews: [&apos;aView&apos;, &apos;bView&apos;, &apos;cView&apos;],&#xA;  aView: Ember.View.create(),&#xA;  bView: Ember.View.create(),&#xA;  cView: Ember.View.create()&#xA;});&#xA;```&#xA;  &#xA;The two strategies can be combined:&#xA;  &#xA;```javascript&#xA;aContainer = Ember.ContainerView.create({&#xA;  childViews: [&apos;aView&apos;, Ember.View.create()],&#xA;  aView: Ember.View.create()&#xA;});&#xA;```&#xA;  &#xA;Each child view&apos;s rendering will be inserted into the container&apos;s rendered&#xA;HTML in the same order as its position in the `childViews` property.&#xA;  &#xA;## Adding and Removing Child Views&#xA;  &#xA;The container view implements `Ember.MutableArray` allowing programmatic management of its child views.&#xA;  &#xA;To remove a view, pass that view into a `removeObject` call on the container view.&#xA;  &#xA;Given an empty `&lt;body&gt;` the following code&#xA;  &#xA;```javascript&#xA;aContainer = Ember.ContainerView.create({&#xA;  classNames: [&apos;the-container&apos;],&#xA;  childViews: [&apos;aView&apos;, &apos;bView&apos;],&#xA;  aView: Ember.View.create({&#xA;    template: Ember.HTMLBars.compile(&quot;A&quot;)&#xA;  }),&#xA;  bView: Ember.View.create({&#xA;    template: Ember.HTMLBars.compile(&quot;B&quot;)&#xA;  })&#xA;});&#xA;  &#xA;aContainer.appendTo(&apos;body&apos;);&#xA;```&#xA;  &#xA;Results in the HTML&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view the-container&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;A&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;B&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;Removing a view&#xA;  &#xA;```javascript&#xA;aContainer.toArray();  // [aContainer.aView, aContainer.bView]&#xA;aContainer.removeObject(aContainer.get(&apos;bView&apos;));&#xA;aContainer.toArray();  // [aContainer.aView]&#xA;```&#xA;  &#xA;Will result in the following HTML&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view the-container&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;A&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;Similarly, adding a child view is accomplished by adding `Ember.View` instances to the&#xA;container view.&#xA;  &#xA;Given an empty `&lt;body&gt;` the following code&#xA;  &#xA;```javascript&#xA;aContainer = Ember.ContainerView.create({&#xA;  classNames: [&apos;the-container&apos;],&#xA;  childViews: [&apos;aView&apos;, &apos;bView&apos;],&#xA;  aView: Ember.View.create({&#xA;    template: Ember.HTMLBars.compile(&quot;A&quot;)&#xA;  }),&#xA;  bView: Ember.View.create({&#xA;    template: Ember.HTMLBars.compile(&quot;B&quot;)&#xA;  })&#xA;});&#xA;  &#xA;aContainer.appendTo(&apos;body&apos;);&#xA;```&#xA;  &#xA;Results in the HTML&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view the-container&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;A&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;B&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;Adding a view&#xA;  &#xA;```javascript&#xA;AnotherViewClass = Ember.View.extend({&#xA;  template: Ember.HTMLBars.compile(&quot;Another view&quot;)&#xA;});&#xA;  &#xA;aContainer.toArray();  // [aContainer.aView, aContainer.bView]&#xA;aContainer.pushObject(AnotherViewClass.create());&#xA;aContainer.toArray(); // [aContainer.aView, aContainer.bView, &lt;AnotherViewClass instance&gt;]&#xA;```&#xA;  &#xA;Will result in the following HTML&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view the-container&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;A&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;B&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Another view&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;## Templates and Layout&#xA;  &#xA;A `template`, `templateName`, `defaultTemplate`, `layout`, `layoutName` or&#xA;`defaultLayout` property on a container view will not result in the template&#xA;or layout being rendered. The HTML contents of a `Ember.ContainerView`&apos;s DOM&#xA;representation will only be the rendered HTML of its child views." ilk="class" name="ContainerView" />
        <scope classrefs="Ember.Object" ilk="class" name="Controller" />
        <scope ilk="class" name="ControllerMixin">
          <scope attributes="public" doc="Transition the application into another route. The route may&#xA;be either a single route or route path:&#xA; ```javascript&#xA;aController.transitionToRoute(&apos;blogPosts&apos;);&#xA;aController.transitionToRoute(&apos;blogPosts.recentEntries&apos;);&#xA;```&#xA; Optionally supply a model for the route in question. The model&#xA;will be serialized into the URL using the `serialize` hook of&#xA;the route:&#xA; ```javascript&#xA;aController.transitionToRoute(&apos;blogPost&apos;, aPost);&#xA;```&#xA; If a literal is passed (such as a number or a string), it will&#xA;be treated as an identifier instead. In this case, the `model`&#xA;hook of the route will be triggered:&#xA; ```javascript&#xA;aController.transitionToRoute(&apos;blogPost&apos;, 1);&#xA;```&#xA; Multiple models will be applied last to first recursively up the&#xA;route tree.&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;blogPost&apos;, { path: &apos;:blogPostId&apos; }, function() {&#xA;    this.route(&apos;blogComment&apos;, { path: &apos;:blogCommentId&apos;, resetNamespace: true });&#xA;  });&#xA;});&#xA; aController.transitionToRoute(&apos;blogComment&apos;, aPost, aComment);&#xA;aController.transitionToRoute(&apos;blogComment&apos;, 1, 13);&#xA;```&#xA; It is also possible to pass a URL (a string that starts with a&#xA;`/`). This is intended for testing and debugging purposes and&#xA;should rarely be used in production code.&#xA; ```javascript&#xA;aController.transitionToRoute(&apos;/&apos;);&#xA;aController.transitionToRoute(&apos;/blog/post/1/comment/13&apos;);&#xA;aController.transitionToRoute(&apos;/blog/posts?sort=title&apos;);&#xA;```&#xA; An options hash with a `queryParams` property may be provided as&#xA;the final argument to add query parameters to the destination URL.&#xA; ```javascript&#xA;aController.transitionToRoute(&apos;blogPost&apos;, 1, {&#xA;  queryParams: {showComments: &apos;true&apos;}&#xA;});&#xA; // if you just want to transition the query parameters without changing the route&#xA;aController.transitionToRoute({queryParams: {sort: &apos;date&apos;}});&#xA;```&#xA; See also [replaceRoute](/api/classes/Ember.ControllerMixin.html#method_replaceRoute)." ilk="function" name="transitionToRoute" signature="transitionToRoute(name,models,options)">
            <variable citdl="String" doc="the name of the route or a URL" ilk="argument" name="name" />
            <variable citdl="...Object" doc="the model(s) or identifier(s) to be used&#xA;  while transitioning to the route." ilk="argument" name="models" />
            <variable citdl="Object" doc="optional hash with a queryParams property&#xA;  containing a mapping of query parameters" ilk="argument" name="options" />
          </scope>
          <scope attributes="private" doc="Transition into another route while replacing the current URL, if possible.&#xA;This will replace the current history entry instead of adding a new one.&#xA;Beside that, it is identical to `transitionToRoute` in all other respects.&#xA; ```javascript&#xA;aController.replaceRoute(&apos;blogPosts&apos;);&#xA;aController.replaceRoute(&apos;blogPosts.recentEntries&apos;);&#xA;```&#xA; Optionally supply a model for the route in question. The model&#xA;will be serialized into the URL using the `serialize` hook of&#xA;the route:&#xA; ```javascript&#xA;aController.replaceRoute(&apos;blogPost&apos;, aPost);&#xA;```&#xA; If a literal is passed (such as a number or a string), it will&#xA;be treated as an identifier instead. In this case, the `model`&#xA;hook of the route will be triggered:&#xA; ```javascript&#xA;aController.replaceRoute(&apos;blogPost&apos;, 1);&#xA;```&#xA; Multiple models will be applied last to first recursively up the&#xA;route tree.&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;blogPost&apos;, { path: &apos;:blogPostId&apos; }, function() {&#xA;    this.route(&apos;blogComment&apos;, { path: &apos;:blogCommentId&apos;, resetNamespace: true });&#xA;  });&#xA;});&#xA; aController.replaceRoute(&apos;blogComment&apos;, aPost, aComment);&#xA;aController.replaceRoute(&apos;blogComment&apos;, 1, 13);&#xA;```&#xA; It is also possible to pass a URL (a string that starts with a&#xA;`/`). This is intended for testing and debugging purposes and&#xA;should rarely be used in production code.&#xA; ```javascript&#xA;aController.replaceRoute(&apos;/&apos;);&#xA;aController.replaceRoute(&apos;/blog/post/1/comment/13&apos;);&#xA;```" ilk="function" name="replaceRoute" signature="replaceRoute(name,models)">
            <variable citdl="String" doc="the name of the route or a URL" ilk="argument" name="name" />
            <variable citdl="...Object" doc="the model(s) or identifier(s) to be used&#xA;while transitioning to the route." ilk="argument" name="models" />
          </scope>
          <variable attributes="property public" doc="The object to which actions from the view should be sent.&#xA; For example, when a Handlebars template uses the `{{action}}` helper,&#xA;it will attempt to send the action to the view&apos;s controller&apos;s `target`.&#xA; By default, the value of the target property is set to the router, and&#xA;is injected when a controller is instantiated. This injection is applied&#xA;as part of the application&apos;s initialization process. In most cases the&#xA;`target` property will automatically be set to the logical consumer of&#xA;actions for the controller." name="ControllerMixin" />
          <variable attributes="property public" doc="The controller&apos;s current model. When retrieving or modifying a controller&apos;s&#xA;model, this property should be used instead of the `content` property." name="ControllerMixin" />
          <scope attributes="private" ilk="function" name="willMergeMixin" signature="willMergeMixin()" />
        </scope>
        <scope doc="Implements some standard methods for copying an object. Add this mixin to&#xA;any object you create that can create a copy of itself. This mixin is&#xA;added automatically to the built-in array.&#xA;  &#xA;You should generally implement the `copy()` method to return a copy of the&#xA;receiver.&#xA;  &#xA;Note that `frozenCopy()` will only work if you also implement&#xA;`Ember.Freezable`." ilk="class" name="Copyable">
          <scope attributes="private" doc="__Required.__ You must implement this method to apply this mixin.&#xA; Override to return a copy of the receiver. Default implementation raises&#xA;an exception." ilk="function" name="copy" returns="Object" signature="copy(deep) =&gt; Object">
            <variable citdl="Boolean" doc="if `true`, a deep copy of the object should be made" ilk="argument" name="deep" />
          </scope>
          <scope attributes="private" doc="If the object implements `Ember.Freezable`, then this will return a new&#xA;copy if the object is not frozen and the receiver if the object is frozen.&#xA; Raises an exception if you try to call this method on a object that does&#xA;not support freezing.&#xA; You should use this method whenever you want a copy of a freezable object&#xA;since a freezable object can simply return itself without actually&#xA;consuming more memory." ilk="function" name="frozenCopy" returns="Object" signature="frozenCopy() =&gt; Object" />
        </scope>
        <scope ilk="class" name="CoreObject">
          <scope attributes="public" doc="An overridable method called when objects are instantiated. By default,&#xA;does nothing unless it is overridden during class definition.&#xA; Example:&#xA; ```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  init: function() {&#xA;    alert(&apos;Name is &apos; + this.get(&apos;name&apos;));&#xA;  }&#xA;});&#xA; var steve = App.Person.create({&#xA;  name: &quot;Steve&quot;&#xA;});&#xA; // alerts &apos;Name is Steve&apos;.&#xA;```&#xA; NOTE: If you do override `init` for a framework class like `Ember.View`,&#xA;be sure to call `this._super(...arguments)` in your&#xA;`init` declaration! If you don&apos;t, Ember may not have an opportunity to&#xA;do important setup work, and you&apos;ll see strange behavior in your&#xA;application." ilk="function" name="init" signature="init()" />
          <scope attributes="public" doc="Creates a new subclass.&#xA; ```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  say: function(thing) {&#xA;    alert(thing);&#xA;   }&#xA;});&#xA;```&#xA; This defines a new subclass of Ember.Object: `App.Person`. It contains one method: `say()`.&#xA; You can also create a subclass from any existing class by calling its `extend()` method.&#xA;For example, you might want to create a subclass of Ember&apos;s built-in `Ember.View` class:&#xA; ```javascript&#xA;App.PersonView = Ember.View.extend({&#xA;  tagName: &apos;li&apos;,&#xA;  classNameBindings: [&apos;isAdministrator&apos;]&#xA;});&#xA;```&#xA; When defining a subclass, you can override methods but still access the&#xA;implementation of your parent class by calling the special `_super()` method:&#xA; ```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  say: function(thing) {&#xA;    var name = this.get(&apos;name&apos;);&#xA;    alert(name + &apos; says: &apos; + thing);&#xA;  }&#xA;});&#xA; App.Soldier = App.Person.extend({&#xA;  say: function(thing) {&#xA;    this._super(thing + &quot;, sir!&quot;);&#xA;  },&#xA;  march: function(numberOfHours) {&#xA;    alert(this.get(&apos;name&apos;) + &apos; marches for &apos; + numberOfHours + &apos; hours.&apos;);&#xA;  }&#xA;});&#xA; var yehuda = App.Soldier.create({&#xA;  name: &quot;Yehuda Katz&quot;&#xA;});&#xA; yehuda.say(&quot;Yes&quot;);  // alerts &quot;Yehuda Katz says: Yes, sir!&quot;&#xA;```&#xA; The `create()` on line #17 creates an *instance* of the `App.Soldier` class.&#xA;The `extend()` on line #8 creates a *subclass* of `App.Person`. Any instance&#xA;of the `App.Person` class will *not* have the `march()` method.&#xA; You can also pass `Mixin` classes to add additional properties to the subclass.&#xA; ```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  say: function(thing) {&#xA;    alert(this.get(&apos;name&apos;) + &apos; says: &apos; + thing);&#xA;  }&#xA;});&#xA; App.SingingMixin = Mixin.create({&#xA;  sing: function(thing){&#xA;    alert(this.get(&apos;name&apos;) + &apos; sings: la la la &apos; + thing);&#xA;  }&#xA;});&#xA; App.BroadwayStar = App.Person.extend(App.SingingMixin, {&#xA;  dance: function() {&#xA;    alert(this.get(&apos;name&apos;) + &apos; dances: tap tap tap tap &apos;);&#xA;  }&#xA;});&#xA;```&#xA; The `App.BroadwayStar` class contains three methods: `say()`, `sing()`, and `dance()`." ilk="function" name="extend" signature="extend(mixins,arguments)">
            <variable citdl="Mixin" doc="One or more Mixin classes" ilk="argument" name="mixins" />
            <variable citdl="Object" doc="Object containing values to use within the new class" ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="Creates an instance of a class. Accepts either no arguments, or an object&#xA;containing values to initialize the newly instantiated object with.&#xA; ```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  helloWorld: function() {&#xA;    alert(&quot;Hi, my name is &quot; + this.get(&apos;name&apos;));&#xA;  }&#xA;});&#xA; var tom = App.Person.create({&#xA;  name: &apos;Tom Dale&apos;&#xA;});&#xA; tom.helloWorld(); // alerts &quot;Hi, my name is Tom Dale&quot;.&#xA;```&#xA; `create` will call the `init` function if defined during&#xA;`Ember.AnyObject.extend`&#xA; If no arguments are passed to `create`, it will not set values to the new&#xA;instance during initialization:&#xA; ```javascript&#xA;var noName = App.Person.create();&#xA;noName.helloWorld(); // alerts undefined&#xA;```&#xA; NOTE: For performance reasons, you cannot declare methods or computed&#xA;properties during `create`. You should instead declare methods and computed&#xA;properties when using `extend`." ilk="function" name="create" signature="create(arguments)">
            <variable ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="Augments a constructor&apos;s prototype with additional&#xA;properties and functions:&#xA; ```javascript&#xA;MyObject = Ember.Object.extend({&#xA;  name: &apos;an object&apos;&#xA;});&#xA; o = MyObject.create();&#xA;o.get(&apos;name&apos;); // &apos;an object&apos;&#xA; MyObject.reopen({&#xA;  say: function(msg){&#xA;    console.log(msg);&#xA;  }&#xA;})&#xA; o2 = MyObject.create();&#xA;o2.say(&quot;hello&quot;); // logs &quot;hello&quot;&#xA; o.say(&quot;goodbye&quot;); // logs &quot;goodbye&quot;&#xA;```&#xA; To add functions and properties to the constructor itself,&#xA;see `reopenClass`" ilk="function" name="reopen" signature="reopen()" />
          <scope attributes="public" doc="Augments a constructor&apos;s own properties and functions:&#xA; ```javascript&#xA;MyObject = Ember.Object.extend({&#xA;  name: &apos;an object&apos;&#xA;});&#xA; MyObject.reopenClass({&#xA;  canBuild: false&#xA;});&#xA; MyObject.canBuild; // false&#xA;o = MyObject.create();&#xA;```&#xA; In other words, this creates static properties and functions for the class.&#xA;These are only available on the class and not on any instance of that class.&#xA; ```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  name : &quot;&quot;,&#xA;  sayHello : function() {&#xA;    alert(&quot;Hello. My name is &quot; + this.get(&apos;name&apos;));&#xA;  }&#xA;});&#xA; App.Person.reopenClass({&#xA;  species : &quot;Homo sapiens&quot;,&#xA;  createPerson: function(newPersonsName){&#xA;    return App.Person.create({&#xA;      name:newPersonsName&#xA;    });&#xA;  }&#xA;});&#xA; var tom = App.Person.create({&#xA;  name : &quot;Tom Dale&quot;&#xA;});&#xA;var yehuda = App.Person.createPerson(&quot;Yehuda Katz&quot;);&#xA; tom.sayHello(); // &quot;Hello. My name is Tom Dale&quot;&#xA;yehuda.sayHello(); // &quot;Hello. My name is Yehuda Katz&quot;&#xA;alert(App.Person.species); // &quot;Homo sapiens&quot;&#xA;```&#xA; Note that `species` and `createPerson` are *not* valid on the `tom` and `yehuda`&#xA;variables. They are only valid on `App.Person`.&#xA; To add functions and properties to instances of&#xA;a constructor by extending the constructor&apos;s prototype&#xA;see `reopen`" ilk="function" name="reopenClass" signature="reopenClass()" />
          <scope attributes="private" doc="In some cases, you may want to annotate computed properties with additional&#xA;metadata about how they function or what values they operate on. For&#xA;example, computed property functions may close over variables that are then&#xA;no longer available for introspection.&#xA; You can pass a hash of these values to a computed property like this:&#xA; ```javascript&#xA;person: function() {&#xA;  var personId = this.get(&apos;personId&apos;);&#xA;  return App.Person.create({ id: personId });&#xA;}.property().meta({ type: App.Person })&#xA;```&#xA; Once you&apos;ve done this, you can retrieve the values saved to the computed&#xA;property from your class like this:&#xA; ```javascript&#xA;MyClass.metaForProperty(&apos;person&apos;);&#xA;```&#xA; This will return the original hash that was passed to `meta()`." ilk="function" name="metaForProperty" signature="metaForProperty(key)">
            <variable citdl="String" doc="property name" ilk="argument" name="key" />
          </scope>
          <scope attributes="private" doc="Iterate over each computed property for the class, passing its name&#xA;and any associated metadata (see `metaForProperty`) to the callback." ilk="function" name="eachComputedProperty" signature="eachComputedProperty(callback,binding)">
            <variable citdl="Function" ilk="argument" name="callback" />
            <variable citdl="Object" ilk="argument" name="binding" />
          </scope>
          <scope attributes="private" doc="Returns a hash of property names and container names that injected&#xA;properties will lookup on the container lazily." ilk="function" name="_lazyInjections" returns="Object" signature="_lazyInjections() =&gt; Object" />
          <variable attributes="property public" citdl="Array" doc="Defines the properties that will be concatenated from the superclass&#xA;(instead of overridden).&#xA; By default, when you extend an Ember class a property defined in&#xA;the subclass overrides a property with the same name that is defined&#xA;in the superclass. However, there are some cases where it is preferable&#xA;to build up a property&apos;s value by combining the superclass&apos; property&#xA;value with the subclass&apos; value. An example of this in use within Ember&#xA;is the `classNames` property of `Ember.View`.&#xA; Here is some sample code showing the difference between a concatenated&#xA;property and a normal one:&#xA; ```javascript&#xA;App.BarView = Ember.View.extend({&#xA;  someNonConcatenatedProperty: [&apos;bar&apos;],&#xA;  classNames: [&apos;bar&apos;]&#xA;});&#xA; App.FooBarView = App.BarView.extend({&#xA;  someNonConcatenatedProperty: [&apos;foo&apos;],&#xA;  classNames: [&apos;foo&apos;]&#xA;});&#xA; var fooBarView = App.FooBarView.create();&#xA;fooBarView.get(&apos;someNonConcatenatedProperty&apos;); // [&apos;foo&apos;]&#xA;fooBarView.get(&apos;classNames&apos;); // [&apos;ember-view&apos;, &apos;bar&apos;, &apos;foo&apos;]&#xA;```&#xA; This behavior extends to object creation as well. Continuing the&#xA;above example:&#xA; ```javascript&#xA;var view = App.FooBarView.create({&#xA;  someNonConcatenatedProperty: [&apos;baz&apos;],&#xA;  classNames: [&apos;baz&apos;]&#xA;})&#xA;view.get(&apos;someNonConcatenatedProperty&apos;); // [&apos;baz&apos;]&#xA;view.get(&apos;classNames&apos;); // [&apos;ember-view&apos;, &apos;bar&apos;, &apos;foo&apos;, &apos;baz&apos;]&#xA;```&#xA;Adding a single property that is not an array will just add it in the array:&#xA; ```javascript&#xA;var view = App.FooBarView.create({&#xA;  classNames: &apos;baz&apos;&#xA;})&#xA;view.get(&apos;classNames&apos;); // [&apos;ember-view&apos;, &apos;bar&apos;, &apos;foo&apos;, &apos;baz&apos;]&#xA;```&#xA; Using the `concatenatedProperties` property, we can tell Ember to mix the&#xA;content of the properties.&#xA; In `Ember.View` the `classNameBindings` and `attributeBindings` properties&#xA;are also concatenated, in addition to `classNames`.&#xA; This feature is available for you to use throughout the Ember object model,&#xA;although typical app developers are likely to use it infrequently. Since&#xA;it changes expectations about behavior of properties, you should properly&#xA;document its usage in each individual concatenated property (to not&#xA;mislead your users to think they can override the property in a subclass)." name="CoreObject" />
          <variable attributes="property public" citdl="Array" doc="Defines the properties that will be merged from the superclass&#xA;(instead of overridden).&#xA; By default, when you extend an Ember class a property defined in&#xA;the subclass overrides a property with the same name that is defined&#xA;in the superclass. However, there are some cases where it is preferable&#xA;to build up a property&apos;s value by merging the superclass property value&#xA;with the subclass property&apos;s value. An example of this in use within Ember&#xA;is the `queryParams` property of routes.&#xA; Here is some sample code showing the difference between a merged&#xA;property and a normal one:&#xA; ```javascript&#xA;App.BarRoute = Ember.Route.extend({&#xA;  someNonMergedProperty: {&#xA;    nonMerged: &apos;superclass value of nonMerged&apos;&#xA;  },&#xA;  queryParams: {&#xA;    page: {replace: false},&#xA;    limit: {replace: true}&#xA;  }&#xA;});&#xA; App.FooBarRoute = App.BarRoute.extend({&#xA;  someNonMergedProperty: {&#xA;    completelyNonMerged: &apos;subclass value of nonMerged&apos;&#xA;  },&#xA;  queryParams: {&#xA;    limit: {replace: false}&#xA;  }&#xA;});&#xA; var fooBarRoute = App.FooBarRoute.create();&#xA; fooBarRoute.get(&apos;someNonMergedProperty&apos;);&#xA;// =&gt; { completelyNonMerged: &apos;subclass value of nonMerged&apos; }&#xA;//&#xA;// Note the entire object, including the nonMerged property of&#xA;// the superclass object, has been replaced&#xA; fooBarRoute.get(&apos;queryParams&apos;);&#xA;// =&gt; {&#xA;//   page: {replace: false},&#xA;//   limit: {replace: false}&#xA;// }&#xA;//&#xA;// Note the page remains from the superclass, and the&#xA;// `limit` property&apos;s value of `false` has been merged from&#xA;// the subclass.&#xA;```&#xA; This behavior is not available during object `create` calls. It is only&#xA;available at `extend` time.&#xA; This feature is available for you to use throughout the Ember object model,&#xA;although typical app developers are likely to use it infrequently. Since&#xA;it changes expectations about behavior of properties, you should properly&#xA;document its usage in each individual merged property (to not&#xA;mislead your users to think they can override the property in a subclass)." name="CoreObject" />
          <variable attributes="property public" doc="Destroyed object property flag.&#xA; if this property is `true` the observers and bindings were already&#xA;removed by the effect of calling the `destroy()` method." name="CoreObject" />
          <variable attributes="property public" doc="Destruction scheduled flag. The `destroy()` method has been called.&#xA; The object stays intact until the end of the run loop at which point&#xA;the `isDestroyed` flag is set." name="CoreObject" />
          <scope attributes="public" doc="Destroys an object by setting the `isDestroyed` flag and removing its&#xA;metadata, which effectively destroys observers and bindings.&#xA; If you try to set a property on a destroyed object, an exception will be&#xA;raised.&#xA; Note that destruction is scheduled for the end of the run loop and does not&#xA;happen immediately.  It will set an isDestroying flag immediately." ilk="function" name="destroy" returns="Ember.Object" signature="destroy() =&gt; Ember.Object" />
          <scope attributes="public" doc="Override to implement teardown." ilk="function" name="willDestroy" signature="willDestroy()" />
          <scope attributes="private" doc="Invoked by the run loop to actually destroy the object. This is&#xA;scheduled for execution by the `destroy` method." ilk="function" name="_scheduledDestroy" signature="_scheduledDestroy()" />
          <scope attributes="public" doc="Returns a string representation which attempts to provide more information&#xA;than Javascript&apos;s `toString` typically does, in a generic way for all Ember&#xA;objects.&#xA; ```javascript&#xA;App.Person = Em.Object.extend()&#xA;person = App.Person.create()&#xA;person.toString() //=&gt; &quot;&lt;App.Person:ember1024&gt;&quot;&#xA;```&#xA; If the object&apos;s class is not defined on an Ember namespace, it will&#xA;indicate it is a subclass of the registered superclass:&#xA;```javascript&#xA;Student = App.Person.extend()&#xA;student = Student.create()&#xA;student.toString() //=&gt; &quot;&lt;(subclass of App.Person):ember1025&gt;&quot;&#xA;```&#xA; If the method `toStringExtension` is defined, its return value will be&#xA;included in the output.&#xA; ```javascript&#xA;App.Teacher = App.Person.extend({&#xA;  toStringExtension: function() {&#xA;    return this.get(&apos;fullName&apos;);&#xA;  }&#xA;});&#xA;teacher = App.Teacher.create()&#xA;teacher.toString(); //=&gt; &quot;&lt;App.Teacher:ember1026:Tom Dale&gt;&quot;&#xA;```" ilk="function" name="toString" returns="String" signature="toString() =&gt; String" />
          <scope attributes="private" doc="Provides lookup-time type validation for injected properties." ilk="function" name="_onLookup" signature="_onLookup()" />
        </scope>
        <scope classrefs="Ember.Object" doc="`Ember.CoreView` is an abstract class that exists to give view-like behavior&#xA;to both Ember&apos;s main view class `Ember.View` and other classes that don&apos;t need&#xA;the fully functionaltiy of `Ember.View`.&#xA;  &#xA;Unless you have specific needs for `CoreView`, you will use `Ember.View`&#xA;in your applications." ilk="class" name="CoreView">
          <variable attributes="property private" citdl="Ember.View" doc="If the view is currently inserted into the DOM of a parent view, this&#xA;property will point to the parent of the view." name="CoreView" />
          <scope attributes="private" doc="Override the default event firing from `Ember.Evented` to&#xA;also call methods with the given name." ilk="function" name="trigger" signature="trigger(name)">
            <variable citdl="String" ilk="argument" name="name" />
          </scope>
        </scope>
        <scope classrefs="EmberObject" doc="The `DataAdapter` helps a data persistence library&#xA;interface with tools that debug Ember such&#xA;as the [Ember Extension](https://github.com/tildeio/ember-extension)&#xA;for Chrome and Firefox.&#xA;  &#xA;This class will be extended by a persistence library&#xA;which will override some of the methods with&#xA;library-specific code.&#xA;  &#xA;The methods likely to be overridden are:&#xA;  &#xA;* `getFilters`&#xA;* `detect`&#xA;* `columnsForType`&#xA;* `getRecords`&#xA;* `getRecordColumnValues`&#xA;* `getRecordKeywords`&#xA;* `getRecordFilterValues`&#xA;* `getRecordColor`&#xA;* `observeRecord`&#xA;  &#xA;The adapter will need to be registered&#xA;in the application&apos;s container as `dataAdapter:main`&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;Application.initializer({&#xA;  name: &quot;data-adapter&quot;,&#xA;  &#xA;  initialize: function(application) {&#xA;    application.register(&apos;data-adapter:main&apos;, DS.DataAdapter);&#xA;  }&#xA;});&#xA;```" ilk="class" name="DataAdapter">
          <variable attributes="property public" doc="The container-debug-adapter which is used&#xA;to list all models." name="DataAdapter" />
          <variable attributes="property private" doc="Number of attributes to send&#xA;as columns. (Enough to make the record&#xA;identifiable)." name="DataAdapter" />
          <variable attributes="property public" doc="Ember Data &gt; v1.0.0-beta.18&#xA;requires string model names to be passed&#xA;around instead of the actual factories.&#xA; This is a stamp for the Ember Inspector&#xA;to differentiate between the versions&#xA;to be able to support older versions too." name="DataAdapter" />
          <variable attributes="property private" doc="Stores all methods that clear observers.&#xA;These methods will be called on destruction." name="DataAdapter" />
          <scope attributes="public" doc="Specifies how records can be filtered.&#xA;Records returned will need to have a `filterValues`&#xA;property with a key for every name in the returned array." ilk="function" name="getFilters" returns="Array" signature="getFilters() =&gt; Array" />
          <scope attributes="public" doc="Fetch the model types and observe them for changes." ilk="function" name="watchModelTypes" returns="Function" signature="watchModelTypes(typesAdded,typesUpdated) =&gt; Function">
            <variable citdl="Function" doc="Callback to call to add types.&#xA;Takes an array of objects containing wrapped types (returned from `wrapModelType`)." ilk="argument" name="typesAdded" />
            <variable citdl="Function" doc="Callback to call when a type has changed.&#xA;Takes an array of objects containing wrapped types." ilk="argument" name="typesUpdated" />
          </scope>
          <scope attributes="public" doc="Fetch the records of a given type and observe them for changes." ilk="function" name="watchRecords" returns="Function" signature="watchRecords(modelName,recordsAdded,recordsUpdated,recordsRemoved) =&gt; Function">
            <variable citdl="String" doc="The model name" ilk="argument" name="modelName" />
            <variable citdl="Function" doc="Callback to call to add records.&#xA;Takes an array of objects containing wrapped records.&#xA;The object should have the following properties:&#xA;  columnValues: {Object} key and value of a table cell&#xA;  object: {Object} the actual record object" ilk="argument" name="recordsAdded" />
            <variable citdl="Function" doc="Callback to call when a record has changed.&#xA;Takes an array of objects containing wrapped records." ilk="argument" name="recordsUpdated" />
            <variable citdl="Function" doc="Callback to call when a record has removed.&#xA;Takes the following parameters:&#xA;  index: the array index where the records were removed&#xA;  count: the number of records removed" ilk="argument" name="recordsRemoved" />
          </scope>
          <scope attributes="private" doc="Clear all observers before destruction" ilk="function" name="willDestroy" signature="willDestroy()" />
          <scope attributes="private" doc="Detect whether a class is a model.&#xA; Test that against the model class&#xA;of your persistence library" ilk="function" name="detect" signature="detect(klass)">
            <variable citdl="Class" doc="The class to test" ilk="argument" name="klass" />
          </scope>
          <scope attributes="private" doc="Get the columns for a given model type." ilk="function" name="columnsForType" returns="Array" signature="columnsForType(type) =&gt; Array">
            <variable citdl="Class" doc="The model type" ilk="argument" name="type" />
          </scope>
          <scope attributes="private" doc="Adds observers to a model type class." ilk="function" name="observeModelType" returns="Function" signature="observeModelType(modelName,typesUpdated) =&gt; Function">
            <variable citdl="String" doc="The model type name" ilk="argument" name="modelName" />
            <variable citdl="Function" doc="Called when a type is modified." ilk="argument" name="typesUpdated" />
          </scope>
          <scope attributes="private" doc="Wraps a given model type and observes changes to it." ilk="function" name="wrapModelType" returns="Object" signature="wrapModelType(klass,modelName) =&gt; Object">
            <variable citdl="Class" doc="A model class" ilk="argument" name="klass" />
            <variable citdl="String" doc="Name of the class" ilk="argument" name="modelName" />
          </scope>
          <scope attributes="private" doc="Fetches all models defined in the application." ilk="function" name="getModelTypes" returns="Array" signature="getModelTypes() =&gt; Array" />
          <scope attributes="private" doc="Loops over all namespaces and all objects&#xA;attached to them" ilk="function" name="_getObjectsOnNamespaces" returns="Array" signature="_getObjectsOnNamespaces() =&gt; Array" />
          <scope attributes="private" doc="Fetches all loaded records for a given type." ilk="function" name="getRecords" returns="Array" signature="getRecords() =&gt; Array" />
          <scope attributes="private" doc="Wraps a record and observers changes to it." ilk="function" name="wrapRecord" returns="Object" signature="wrapRecord(record) =&gt; Object">
            <variable citdl="Object" doc="The record instance." ilk="argument" name="record" />
          </scope>
          <scope attributes="private" doc="Gets the values for each column." ilk="function" name="getRecordColumnValues" returns="Object" signature="getRecordColumnValues() =&gt; Object" />
          <scope attributes="private" doc="Returns keywords to match when searching records." ilk="function" name="getRecordKeywords" returns="Array" signature="getRecordKeywords() =&gt; Array" />
          <scope attributes="private" doc="Returns the values of filters defined by `getFilters`." ilk="function" name="getRecordFilterValues" returns="Object" signature="getRecordFilterValues(record) =&gt; Object">
            <variable citdl="Object" doc="The record instance" ilk="argument" name="record" />
          </scope>
          <scope attributes="private" doc="Each record can have a color that represents its state." ilk="function" name="getRecordColor" returns="String" signature="getRecordColor(record) =&gt; String">
            <variable citdl="Object" doc="The record instance" ilk="argument" name="record" />
          </scope>
          <scope attributes="private" doc="Observes all relevant properties and re-sends the wrapped record&#xA;when a change occurs." ilk="function" name="observerRecord" returns="Function" signature="observerRecord(record,recordUpdated) =&gt; Function">
            <variable citdl="Object" doc="The record instance" ilk="argument" name="record" />
            <variable citdl="Function" doc="The callback to call when a record is updated." ilk="argument" name="recordUpdated" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="The DefaultResolver defines the default lookup rules to resolve&#xA;container lookups before consulting the container for registered&#xA;items:&#xA;  &#xA;* templates are looked up on `Ember.TEMPLATES`&#xA;* other names are looked up on the application after converting&#xA;  the name. For example, `controller:post` looks up&#xA;  `App.PostController` by default.&#xA;* there are some nuances (see examples below)&#xA;  &#xA;### How Resolving Works&#xA;  &#xA;The container calls this object&apos;s `resolve` method with the&#xA;`fullName` argument.&#xA;  &#xA;It first parses the fullName into an object using `parseName`.&#xA;  &#xA;Then it checks for the presence of a type-specific instance&#xA;method of the form `resolve[Type]` and calls it if it exists.&#xA;For example if it was resolving &apos;template:post&apos;, it would call&#xA;the `resolveTemplate` method.&#xA;  &#xA;Its last resort is to call the `resolveOther` method.&#xA;  &#xA;The methods of this object are designed to be easy to override&#xA;in a subclass. For example, you could enhance how a template&#xA;is resolved like so:&#xA;  &#xA;```javascript&#xA;App = Ember.Application.create({&#xA;  Resolver: Ember.DefaultResolver.extend({&#xA;    resolveTemplate: function(parsedName) {&#xA;      var resolvedTemplate = this._super(parsedName);&#xA;      if (resolvedTemplate) { return resolvedTemplate; }&#xA;      return Ember.TEMPLATES[&apos;not_found&apos;];&#xA;    }&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Some examples of how names are resolved:&#xA;  &#xA;```&#xA;&apos;template:post&apos;           //=&gt; Ember.TEMPLATES[&apos;post&apos;]&#xA;&apos;template:posts/byline&apos;   //=&gt; Ember.TEMPLATES[&apos;posts/byline&apos;]&#xA;&apos;template:posts.byline&apos;   //=&gt; Ember.TEMPLATES[&apos;posts/byline&apos;]&#xA;&apos;template:blogPost&apos;       //=&gt; Ember.TEMPLATES[&apos;blogPost&apos;]&#xA;                          //   OR&#xA;                          //   Ember.TEMPLATES[&apos;blog_post&apos;]&#xA;&apos;controller:post&apos;         //=&gt; App.PostController&#xA;&apos;controller:posts.index&apos;  //=&gt; App.PostsIndexController&#xA;&apos;controller:blog/post&apos;    //=&gt; Blog.PostController&#xA;&apos;controller:basic&apos;        //=&gt; Ember.Controller&#xA;&apos;route:post&apos;              //=&gt; App.PostRoute&#xA;&apos;route:posts.index&apos;       //=&gt; App.PostsIndexRoute&#xA;&apos;route:blog/post&apos;         //=&gt; Blog.PostRoute&#xA;&apos;route:basic&apos;             //=&gt; Ember.Route&#xA;&apos;view:post&apos;               //=&gt; App.PostView&#xA;&apos;view:posts.index&apos;        //=&gt; App.PostsIndexView&#xA;&apos;view:blog/post&apos;          //=&gt; Blog.PostView&#xA;&apos;view:basic&apos;              //=&gt; Ember.View&#xA;&apos;foo:post&apos;                //=&gt; App.PostFoo&#xA;&apos;model:post&apos;              //=&gt; App.Post&#xA;```" ilk="class" name="DefaultResolver">
          <variable attributes="property public" doc="This will be set to the Application instance when it is&#xA;created." name="DefaultResolver" />
          <scope attributes="public" doc="This method is called via the container&apos;s resolver method.&#xA;It parses the provided `fullName` and then looks up and&#xA;returns the appropriate template or class." ilk="function" name="resolve" returns="Object" signature="resolve(fullName) =&gt; Object">
            <variable citdl="String" doc="the lookup string" ilk="argument" name="fullName" />
          </scope>
          <scope attributes="public" doc="Convert the string name of the form &apos;type:name&apos; to&#xA;a Javascript object with the parsed aspects of the name&#xA;broken out." ilk="function" name="parseName" signature="parseName(fullName)">
            <variable citdl="String" doc="the lookup string" ilk="argument" name="fullName" />
          </scope>
          <scope attributes="public" doc="Returns a human-readable description for a fullName. Used by the&#xA;Application namespace in assertions to describe the&#xA;precise name of the class that Ember is looking for, rather than&#xA;container keys." ilk="function" name="lookupDescription" signature="lookupDescription(fullName)">
            <variable citdl="String" doc="the lookup string" ilk="argument" name="fullName" />
          </scope>
          <scope attributes="public" doc="Given a parseName object (output from `parseName`), apply&#xA;the conventions expected by `Ember.Router`" ilk="function" name="useRouterNaming" signature="useRouterNaming(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Look up the template in Ember.TEMPLATES" ilk="function" name="resolveTemplate" signature="resolveTemplate(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Lookup the view using `resolveOther`" ilk="function" name="resolveView" signature="resolveView(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Lookup the controller using `resolveOther`" ilk="function" name="resolveController" signature="resolveController(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Lookup the route using `resolveOther`" ilk="function" name="resolveRoute" signature="resolveRoute(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Lookup the model on the Application namespace" ilk="function" name="resolveModel" signature="resolveModel(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Look up the specified object (from parsedName) on the appropriate&#xA;namespace (usually on the Application)" ilk="function" name="resolveHelper" signature="resolveHelper(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="public" doc="Look up the specified object (from parsedName) on the appropriate&#xA;namespace (usually on the Application)" ilk="function" name="resolveOther" signature="resolveOther(parsedName)">
            <variable citdl="Object" doc="a parseName object with the parsed&#xA;  fullName lookup string" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="private" ilk="function" name="_logLookup" signature="_logLookup(found,parsedName)">
            <variable citdl="Boolean" ilk="argument" name="found" />
            <variable citdl="Object" ilk="argument" name="parsedName" />
          </scope>
          <scope attributes="private" doc="Used to iterate all items of a given type." ilk="function" name="knownForType" signature="knownForType(type)">
            <variable citdl="String" doc="the type to search for" ilk="argument" name="type" />
          </scope>
          <scope attributes="private" doc="Converts provided name from the backing namespace into a container lookup name.&#xA; Examples:&#xA; App.FooBarHelper -&gt; helper:foo-bar&#xA;App.THelper -&gt; helper:t" ilk="function" name="translateToContainerFullname" signature="translateToContainerFullname(type,name)">
            <variable citdl="String" ilk="argument" name="type" />
            <variable citdl="String" ilk="argument" name="name" />
          </scope>
        </scope>
        <scope doc="This is the object instance returned when you get the `@each` property on an&#xA;array. It uses the unknownProperty handler to automatically create&#xA;EachArray instances for property names." ilk="class" name="EachProxy" />
        <scope ilk="class" name="EmptyViewSupport">
          <variable attributes="property private" doc="This provides metadata about what kind of empty view class this&#xA;collection would like if it is being instantiated from another&#xA;system (like Handlebars)" name="EmptyViewSupport" />
          <variable attributes="property private" citdl="Ember.View" doc="An optional view to display if content is set to an empty array." name="EmptyViewSupport" />
        </scope>
        <scope classrefs="Ember.Namespace" doc="The `Engine` class contains core functionality for both applications and&#xA;engines.&#xA;  &#xA;Each engine manages a registry that&apos;s used for dependency injection and&#xA;exposed through `RegistryProxy`.&#xA;  &#xA;Engines also manage initializers and instance initializers.&#xA;  &#xA;Engines can spawn `EngineInstance` instances via `buildInstance()`." ilk="class" name="Engine">
          <scope attributes="private" doc="Create an EngineInstance for this application." ilk="function" name="buildInstance" returns="Ember.EngineInstance" signature="buildInstance() =&gt; Ember.EngineInstance" />
          <scope attributes="private" doc="Build and configure the registry for the current application." ilk="function" name="buildRegistry" returns="Ember.Registry" signature="buildRegistry() =&gt; Ember.Registry" />
          <scope attributes="private" ilk="function" name="initializer" signature="initializer()" />
          <scope attributes="private" ilk="function" name="instanceInitializer" signature="instanceInitializer()" />
          <scope attributes="private" ilk="function" name="runInitializers" signature="runInitializers()" />
          <scope attributes="private" ilk="function" name="runInstanceInitializers" signature="runInstanceInitializers()" />
          <scope attributes="public" doc="The goal of initializers should be to register dependencies and injections.&#xA;This phase runs once. Because these initializers may load code, they are&#xA;allowed to defer application readiness and advance it. If you need to access&#xA;the container or store you should use an InstanceInitializer that will be run&#xA;after all initializers and therefore after all code is loaded and the app is&#xA;ready.&#xA; Initializer receives an object which has the following attributes:&#xA;`name`, `before`, `after`, `initialize`. The only required attribute is&#xA;`initialize`, all others are optional.&#xA; * `name` allows you to specify under which name the initializer is registered.&#xA;This must be a unique name, as trying to register two initializers with the&#xA;same name will result in an error.&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;namedInitializer&apos;,&#xA;   initialize: function(application) {&#xA;    Ember.debug(&apos;Running namedInitializer!&apos;);&#xA;  }&#xA;});&#xA;```&#xA; * `before` and `after` are used to ensure that this initializer is ran prior&#xA;or after the one identified by the value. This value can be a single string&#xA;or an array of strings, referencing the `name` of other initializers.&#xA; An example of ordering initializers, we create an initializer named `first`:&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;first&apos;,&#xA;   initialize: function(application) {&#xA;    Ember.debug(&apos;First initializer!&apos;);&#xA;  }&#xA;});&#xA; // DEBUG: First initializer!&#xA;```&#xA; We add another initializer named `second`, specifying that it should run&#xA;after the initializer named `first`:&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;second&apos;,&#xA;  after: &apos;first&apos;,&#xA;   initialize: function(application) {&#xA;    Ember.debug(&apos;Second initializer!&apos;);&#xA;  }&#xA;});&#xA; // DEBUG: First initializer!&#xA;// DEBUG: Second initializer!&#xA;```&#xA; Afterwards we add a further initializer named `pre`, this time specifying&#xA;that it should run before the initializer named `first`:&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;pre&apos;,&#xA;  before: &apos;first&apos;,&#xA;   initialize: function(application) {&#xA;    Ember.debug(&apos;Pre initializer!&apos;);&#xA;  }&#xA;});&#xA; // DEBUG: Pre initializer!&#xA;// DEBUG: First initializer!&#xA;// DEBUG: Second initializer!&#xA;```&#xA; Finally we add an initializer named `post`, specifying it should run after&#xA;both the `first` and the `second` initializers:&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;post&apos;,&#xA;  after: [&apos;first&apos;, &apos;second&apos;],&#xA;   initialize: function(application) {&#xA;    Ember.debug(&apos;Post initializer!&apos;);&#xA;  }&#xA;});&#xA; // DEBUG: Pre initializer!&#xA;// DEBUG: First initializer!&#xA;// DEBUG: Second initializer!&#xA;// DEBUG: Post initializer!&#xA;```&#xA; * `initialize` is a callback function that receives one argument,&#xA;  `application`, on which you can operate.&#xA; Example of using `application` to register an adapter:&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;api-adapter&apos;,&#xA;   initialize: function(application) {&#xA;    application.register(&apos;api-adapter:main&apos;, ApiAdapter);&#xA;  }&#xA;});&#xA;```" ilk="function" name="initializer" signature="initializer(initializer)">
            <variable citdl="Object" ilk="argument" name="initializer" />
          </scope>
          <scope attributes="public" doc="Instance initializers run after all initializers have run. Because&#xA;instance initializers run after the app is fully set up. We have access&#xA;to the store, container, and other items. However, these initializers run&#xA;after code has loaded and are not allowed to defer readiness.&#xA; Instance initializer receives an object which has the following attributes:&#xA;`name`, `before`, `after`, `initialize`. The only required attribute is&#xA;`initialize`, all others are optional.&#xA; * `name` allows you to specify under which name the instanceInitializer is&#xA;registered. This must be a unique name, as trying to register two&#xA;instanceInitializer with the same name will result in an error.&#xA; ```javascript&#xA;Ember.Application.instanceInitializer({&#xA;  name: &apos;namedinstanceInitializer&apos;,&#xA;   initialize: function(application) {&#xA;    Ember.debug(&apos;Running namedInitializer!&apos;);&#xA;  }&#xA;});&#xA;```&#xA; * `before` and `after` are used to ensure that this initializer is ran prior&#xA;or after the one identified by the value. This value can be a single string&#xA;or an array of strings, referencing the `name` of other initializers.&#xA; * See Ember.Application.initializer for discussion on the usage of before&#xA;and after.&#xA; Example instanceInitializer to preload data into the store.&#xA; ```javascript&#xA;Ember.Application.initializer({&#xA;  name: &apos;preload-data&apos;,&#xA;   initialize: function(application) {&#xA;    var userConfig, userConfigEncoded, store;&#xA;    // We have a HTML escaped JSON representation of the user&apos;s basic&#xA;    // configuration generated server side and stored in the DOM of the main&#xA;    // index.html file. This allows the app to have access to a set of data&#xA;    // without making any additional remote calls. Good for basic data that is&#xA;    // needed for immediate rendering of the page. Keep in mind, this data,&#xA;    // like all local models and data can be manipulated by the user, so it&#xA;    // should not be relied upon for security or authorization.&#xA;    //&#xA;    // Grab the encoded data from the meta tag&#xA;    userConfigEncoded = Ember.$(&apos;head meta[name=app-user-config]&apos;).attr(&apos;content&apos;);&#xA;    // Unescape the text, then parse the resulting JSON into a real object&#xA;    userConfig = JSON.parse(unescape(userConfigEncoded));&#xA;    // Lookup the store&#xA;    store = application.lookup(&apos;service:store&apos;);&#xA;    // Push the encoded JSON into the store&#xA;    store.pushPayload(userConfig);&#xA;  }&#xA;});&#xA;```" ilk="function" name="instanceInitializer" signature="instanceInitializer(instanceInitializer)">
            <variable ilk="argument" name="instanceInitializer" />
          </scope>
          <scope attributes="public" doc="This creates a registry with the default Ember naming conventions.&#xA; It also configures the registry:&#xA; * registered views are created every time they are looked up (they are&#xA;  not singletons)&#xA;* registered templates are not factories; the registered value is&#xA;  returned directly.&#xA;* the router receives the application as its `namespace` property&#xA;* all controllers receive the router as their `target` and `controllers`&#xA;  properties&#xA;* all controllers receive the application as their `namespace` property&#xA;* the application view receives the application controller as its&#xA;  `controller` property&#xA;* the application view receives the application template as its&#xA;  `defaultTemplate` property" ilk="function" name="buildRegistry" returns="Ember.Registry" signature="buildRegistry(namespace) =&gt; Ember.Registry">
            <variable citdl="Ember.Application" doc="the application for which to&#xA;  build the registry" ilk="argument" name="namespace" />
          </scope>
          <variable attributes="property public" doc="Set this to provide an alternate class to `Ember.DefaultResolver`" name="Engine" />
          <variable attributes="property public" doc="Set this to provide an alternate class to `Ember.DefaultResolver`" name="Engine" />
          <scope attributes="private" doc="This function defines the default lookup rules for container lookups:&#xA;  &#xA;* templates are looked up on `Ember.TEMPLATES`&#xA;* other names are looked up on the application after classifying the name.&#xA;  For example, `controller:post` looks up `App.PostController` by default.&#xA;* if the default lookup fails, look for registered classes on the container&#xA;  &#xA;This allows the application to register default injections in the container&#xA;that could be overridden by the normal naming convention." ilk="function" name="resolverFor" returns="*" signature="resolverFor(namespace) =&gt; *">
            <variable citdl="Ember.Namespace" doc="the namespace to look for classes" ilk="argument" name="namespace" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="The `EngineInstance` encapsulates all of the stateful aspects of a&#xA;running `Engine`." ilk="class" name="EngineInstance">
          <variable attributes="property private" citdl="Ember.Engine" doc="The base `Engine` for which this is an instance." name="EngineInstance" />
          <scope attributes="public" doc="Unregister a factory.&#xA; Overrides `RegistryProxy#unregister` in order to clear any cached instances&#xA;of the unregistered factory." ilk="function" name="unregister" signature="unregister(fullName)">
            <variable citdl="String" ilk="argument" name="fullName" />
          </scope>
        </scope>
        <scope doc="This mixin defines the common interface implemented by enumerable objects&#xA;in Ember. Most of these methods follow the standard Array iteration&#xA;API defined up to JavaScript 1.8 (excluding language-specific features that&#xA;cannot be emulated in older versions of JavaScript).&#xA;  &#xA;This mixin is applied automatically to the Array class on page load, so you&#xA;can use any of these methods on simple arrays. If Array already implements&#xA;one of these methods, the mixin will not override them.&#xA;  &#xA;## Writing Your Own Enumerable&#xA;  &#xA;To make your own custom class enumerable, you need two items:&#xA;  &#xA;1. You must have a length property. This property should change whenever&#xA;   the number of items in your enumerable object changes. If you use this&#xA;   with an `Ember.Object` subclass, you should be sure to change the length&#xA;   property using `set().`&#xA;  &#xA;2. You must implement `nextObject().` See documentation.&#xA;  &#xA;Once you have these two methods implemented, apply the `Ember.Enumerable` mixin&#xA;to your class and you will be able to enumerate the contents of your object&#xA;like any other collection.&#xA;  &#xA;## Using Ember Enumeration with Other Libraries&#xA;  &#xA;Many other libraries provide some kind of iterator or enumeration like&#xA;facility. This is often where the most common API conflicts occur.&#xA;Ember&apos;s API is designed to be as friendly as possible with other&#xA;libraries by implementing only methods that mostly correspond to the&#xA;JavaScript 1.8 API." ilk="class" name="Enumerable">
          <scope attributes="private" doc="__Required.__ You must implement this method to apply this mixin.&#xA; Implement this method to make your class enumerable.&#xA; This method will be called repeatedly during enumeration. The index value&#xA;will always begin with 0 and increment monotonically. You don&apos;t have to&#xA;rely on the index value to determine what object to return, but you should&#xA;always check the value and start from the beginning when you see the&#xA;requested index is 0.&#xA; The `previousObject` is the object that was returned from the last call&#xA;to `nextObject` for the current iteration. This is a useful way to&#xA;manage iteration if you are tracing a linked list, for example.&#xA; Finally the context parameter will always contain a hash you can use as&#xA;a &quot;scratchpad&quot; to maintain any other state you need in order to iterate&#xA;properly. The context object is reused and is not reset between&#xA;iterations so make sure you setup the context with a fresh state whenever&#xA;the index parameter is 0.&#xA; Generally iterators will continue to call `nextObject` until the index&#xA;reaches the current length-1. If you run out of data before this&#xA;time for some reason, you should simply return undefined.&#xA; The default implementation of this method simply looks up the index.&#xA;This works great on any Array-like objects." ilk="function" name="nextObject" returns="Object" signature="nextObject(index,previousObject,context) =&gt; Object">
            <variable citdl="Number" doc="the current index of the iteration" ilk="argument" name="index" />
            <variable citdl="Object" doc="the value returned by the last call to&#xA;  `nextObject`." ilk="argument" name="previousObject" />
            <variable citdl="Object" doc="a context object you can use to maintain state." ilk="argument" name="context" />
          </scope>
          <variable attributes="property public" doc="Helper method returns the first object from a collection. This is usually&#xA;used by bindings and other parts of the framework to extract a single&#xA;object if the enumerable contains only one item.&#xA; If you override this method, you should implement it so that it will&#xA;always return the same value each time it is called. If your enumerable&#xA;contains only one object, this method should always return that object.&#xA;If your enumerable is empty, this method should return `undefined`.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];&#xA;arr.get(&apos;firstObject&apos;);  // &apos;a&apos;&#xA; var arr = [];&#xA;arr.get(&apos;firstObject&apos;);  // undefined&#xA;```" name="Enumerable" />
          <variable attributes="property public" doc="Helper method returns the last object from a collection. If your enumerable&#xA;contains only one object, this method should always return that object.&#xA;If your enumerable is empty, this method should return `undefined`.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];&#xA;arr.get(&apos;lastObject&apos;);  // &apos;c&apos;&#xA; var arr = [];&#xA;arr.get(&apos;lastObject&apos;);  // undefined&#xA;```" name="Enumerable" />
          <scope attributes="public" doc="Returns `true` if the passed object can be found in the receiver. The&#xA;default version will iterate through the enumerable until the object&#xA;is found. You may want to override this with a more efficient version.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];&#xA; arr.contains(&apos;a&apos;); // true&#xA;arr.contains(&apos;z&apos;); // false&#xA;```" ilk="function" name="contains" returns="Boolean" signature="contains(obj) =&gt; Boolean">
            <variable citdl="Object" doc="The object to search for." ilk="argument" name="obj" />
          </scope>
          <scope attributes="public" doc="Iterates through the enumerable, calling the passed function on each&#xA;item. This method corresponds to the `forEach()` method defined in&#xA;JavaScript 1.6.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as `this` on the context. This is a good way&#xA;to give your iterator function access to the current object." ilk="function" name="forEach" returns="Object" signature="forEach(callback,target) =&gt; Object">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Alias for `mapBy`" ilk="function" name="getEach" returns="Array" signature="getEach(key) =&gt; Array">
            <variable citdl="String" doc="name of the property" ilk="argument" name="key" />
          </scope>
          <scope attributes="public" doc="Sets the value on the named property for each member. This is more&#xA;efficient than using other methods defined on this helper. If the object&#xA;implements Ember.Observable, the value will be changed to `set(),` otherwise&#xA;it will be set directly. `null` objects are skipped." ilk="function" name="setEach" returns="Object" signature="setEach(key,value) =&gt; Object">
            <variable citdl="String" doc="The key to set" ilk="argument" name="key" />
            <variable citdl="Object" doc="The object to set" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Maps all of the items in the enumeration to another value, returning&#xA;a new array. This method corresponds to `map()` defined in JavaScript 1.6.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; It should return the mapped value.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as `this` on the context. This is a good way&#xA;to give your iterator function access to the current object." ilk="function" name="map" returns="Array" signature="map(callback,target) =&gt; Array">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Similar to map, this specialized function returns the value of the named&#xA;property on all items in the enumeration." ilk="function" name="mapBy" returns="Array" signature="mapBy(key) =&gt; Array">
            <variable citdl="String" doc="name of the property" ilk="argument" name="key" />
          </scope>
          <scope attributes="public" doc="Returns an array with all of the items in the enumeration that the passed&#xA;function returns true for. This method corresponds to `filter()` defined in&#xA;JavaScript 1.6.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; It should return `true` to include the item in the results, `false`&#xA;otherwise.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as `this` on the context. This is a good way&#xA;to give your iterator function access to the current object." ilk="function" name="filter" returns="Array" signature="filter(callback,target) =&gt; Array">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Returns an array with all of the items in the enumeration where the passed&#xA;function returns false. This method is the inverse of filter().&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - *item* is the current item in the iteration.&#xA;- *index* is the current index in the iteration&#xA;- *enumerable* is the enumerable object itself.&#xA; It should return a falsey value to include the item in the results.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as &quot;this&quot; on the context. This is a good way&#xA;to give your iterator function access to the current object." ilk="function" name="reject" returns="Array" signature="reject(callback,target) =&gt; Array">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Returns an array with just the items with the matched property. You&#xA;can pass an optional second argument with the target value. Otherwise&#xA;this will match any property that evaluates to `true`." ilk="function" name="filterBy" returns="Array" signature="filterBy(key,value) =&gt; Array">
            <variable citdl="String" doc="the property to test" ilk="argument" name="key" />
            <variable citdl="*" doc="optional value to test against." ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Returns an array with the items that do not have truthy values for&#xA;key.  You can pass an optional second argument with the target value.  Otherwise&#xA;this will match any property that evaluates to false." ilk="function" name="rejectBy" returns="Array" signature="rejectBy(key,value) =&gt; Array">
            <variable citdl="String" doc="the property to test" ilk="argument" name="key" />
            <variable citdl="String" doc="optional value to test against." ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Returns the first item in the array for which the callback returns true.&#xA;This method works similar to the `filter()` method defined in JavaScript 1.6&#xA;except that it will stop working on the array once a match is found.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; It should return the `true` to include the item in the results, `false`&#xA;otherwise.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as `this` on the context. This is a good way&#xA;to give your iterator function access to the current object." ilk="function" name="find" returns="Object" signature="find(callback,target) =&gt; Object">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Returns the first item with a property matching the passed value. You&#xA;can pass an optional second argument with the target value. Otherwise&#xA;this will match any property that evaluates to `true`.&#xA; This method works much like the more generic `find()` method." ilk="function" name="findBy" returns="Object" signature="findBy(key,value) =&gt; Object">
            <variable citdl="String" doc="the property to test" ilk="argument" name="key" />
            <variable citdl="String" doc="optional value to test against." ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Returns `true` if the passed function returns true for every item in the&#xA;enumeration. This corresponds with the `every()` method in JavaScript 1.6.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; It should return the `true` or `false`.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as `this` on the context. This is a good way&#xA;to give your iterator function access to the current object.&#xA; Example Usage:&#xA; ```javascript&#xA;if (people.every(isEngineer)) {&#xA;  Paychecks.addBigBonus();&#xA;}&#xA;```" ilk="function" name="every" returns="Boolean" signature="every(callback,target) =&gt; Boolean">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Returns `true` if the passed property resolves to the value of the second&#xA;argument for all items in the enumerable. This method is often simpler/faster&#xA;than using a callback." ilk="function" name="isEvery" returns="Boolean" signature="isEvery(key,value) =&gt; Boolean">
            <variable citdl="String" doc="the property to test" ilk="argument" name="key" />
            <variable citdl="String" doc="optional value to test against. Defaults to `true`" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Returns `true` if the passed function returns true for any item in the&#xA;enumeration. This corresponds with the `some()` method in JavaScript 1.6.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(item, index, enumerable);&#xA;```&#xA; - `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; It should return the `true` to include the item in the results, `false`&#xA;otherwise.&#xA; Note that in addition to a callback, you can also pass an optional target&#xA;object that will be set as `this` on the context. This is a good way&#xA;to give your iterator function access to the current object.&#xA; Usage Example:&#xA; ```javascript&#xA;if (people.any(isManager)) {&#xA;  Paychecks.addBiggerBonus();&#xA;}&#xA;```" ilk="function" name="any" returns="Boolean" signature="any(callback,target) =&gt; Boolean">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="The target object to use" ilk="argument" name="target" />
          </scope>
          <scope attributes="public" doc="Returns `true` if the passed property resolves to the value of the second&#xA;argument for any item in the enumerable. This method is often simpler/faster&#xA;than using a callback." ilk="function" name="isAny" returns="Boolean" signature="isAny(key,value) =&gt; Boolean">
            <variable citdl="String" doc="the property to test" ilk="argument" name="key" />
            <variable citdl="String" doc="optional value to test against. Defaults to `true`" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="This will combine the values of the enumerator into a single value. It&#xA;is a useful way to collect a summary value from an enumeration. This&#xA;corresponds to the `reduce()` method defined in JavaScript 1.8.&#xA; The callback method you provide should have the following signature (all&#xA;parameters are optional):&#xA; ```javascript&#xA;function(previousValue, item, index, enumerable);&#xA;```&#xA; - `previousValue` is the value returned by the last call to the iterator.&#xA;- `item` is the current item in the iteration.&#xA;- `index` is the current index in the iteration.&#xA;- `enumerable` is the enumerable object itself.&#xA; Return the new cumulative value.&#xA; In addition to the callback you can also pass an `initialValue`. An error&#xA;will be raised if you do not pass an initial value and the enumerator is&#xA;empty.&#xA; Note that unlike the other methods, this method does not allow you to&#xA;pass a target object to set as this for the callback. It&apos;s part of the&#xA;spec. Sorry." ilk="function" name="reduce" returns="Object" signature="reduce(callback,initialValue,reducerProperty) =&gt; Object">
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="callback" />
            <variable citdl="Object" doc="Initial value for the reduce" ilk="argument" name="initialValue" />
            <variable citdl="String" doc="internal use only." ilk="argument" name="reducerProperty" />
          </scope>
          <scope attributes="public" doc="Invokes the named method on every object in the receiver that&#xA;implements it. This method corresponds to the implementation in&#xA;Prototype 1.6." ilk="function" name="invoke" returns="Array" signature="invoke(methodName,args) =&gt; Array">
            <variable citdl="String" doc="the name of the method" ilk="argument" name="methodName" />
            <variable citdl="Object..." doc="optional arguments to pass as well." ilk="argument" name="args" />
          </scope>
          <scope attributes="public" doc="Simply converts the enumerable into a genuine array. The order is not&#xA;guaranteed. Corresponds to the method implemented by Prototype." ilk="function" name="toArray" returns="Array" signature="toArray() =&gt; Array" />
          <scope attributes="public" doc="Returns a copy of the array with all `null` and `undefined` elements removed.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, null, &apos;c&apos;, undefined];&#xA;arr.compact();  // [&apos;a&apos;, &apos;c&apos;]&#xA;```" ilk="function" name="compact" returns="Array" signature="compact() =&gt; Array" />
          <scope attributes="public" doc="Returns a new enumerable that excludes the passed value. The default&#xA;implementation returns an array regardless of the receiver type unless&#xA;the receiver does not contain the value.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;b&apos;, &apos;a&apos;, &apos;c&apos;];&#xA;arr.without(&apos;a&apos;);  // [&apos;b&apos;, &apos;c&apos;]&#xA;```" ilk="function" name="without" returns="Ember.Enumerable" signature="without(value) =&gt; Ember.Enumerable">
            <variable citdl="Object" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Returns a new enumerable that contains only unique values. The default&#xA;implementation returns an array regardless of the receiver type.&#xA; ```javascript&#xA;var arr = [&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;];&#xA;arr.uniq();  // [&apos;a&apos;, &apos;b&apos;]&#xA;```&#xA; This only works on primitive data types, e.g. Strings, Numbers, etc." ilk="function" name="uniq" returns="Ember.Enumerable" signature="uniq() =&gt; Ember.Enumerable" />
          <variable attributes="property private" citdl="Array" doc="This property will trigger anytime the enumerable&apos;s content changes.&#xA;You can observe this property to be notified of changes to the enumerable&apos;s&#xA;content.&#xA; For plain enumerables, this property is read only. `Array` overrides&#xA;this method." name="Enumerable" />
          <scope attributes="private" doc="Registers an enumerable observer. Must implement `Ember.EnumerableObserver`&#xA;mixin." ilk="function" name="addEnumerableObserver" signature="addEnumerableObserver(target,opts)">
            <variable citdl="Object" ilk="argument" name="target" />
            <variable citdl="Object" ilk="argument" name="opts" />
          </scope>
          <scope attributes="private" doc="Removes a registered enumerable observer." ilk="function" name="removeEnumerableObserver" signature="removeEnumerableObserver(target,opts)">
            <variable citdl="Object" ilk="argument" name="target" />
            <variable citdl="Object" ilk="argument" name="opts" />
          </scope>
          <variable attributes="property private" citdl="Boolean" doc="Becomes true whenever the array currently has observers watching changes&#xA;on the array." name="Enumerable" />
          <scope attributes="private" doc="Invoke this method just before the contents of your enumerable will&#xA;change. You can either omit the parameters completely or pass the objects&#xA;to be removed or added if available or just a count." ilk="function" name="enumerableContentWillChange" signature="enumerableContentWillChange(removing,adding)">
            <variable citdl="Ember.Enumerable|Number" doc="An enumerable of the objects to&#xA;  be removed or the number of items to be removed." ilk="argument" name="removing" />
            <variable citdl="Ember.Enumerable|Number" doc="An enumerable of the objects to be&#xA;  added or the number of items to be added." ilk="argument" name="adding" />
          </scope>
          <scope attributes="private" doc="Invoke this method when the contents of your enumerable has changed.&#xA;This will notify any observers watching for content changes. If you are&#xA;implementing an ordered enumerable (such as an array), also pass the&#xA;start and end values where the content changed so that it can be used to&#xA;notify range observers." ilk="function" name="enumerableContentDidChange" signature="enumerableContentDidChange(removing,adding)">
            <variable citdl="Ember.Enumerable|Number" doc="An enumerable of the objects to&#xA;  be removed or the number of items to be removed." ilk="argument" name="removing" />
            <variable citdl="Ember.Enumerable|Number" doc="An enumerable of the objects to&#xA;  be added or the number of items to be added." ilk="argument" name="adding" />
          </scope>
          <scope attributes="public" doc="Converts the enumerable into an array and sorts by the keys&#xA;specified in the argument.&#xA; You may provide multiple arguments to sort by multiple properties." ilk="function" name="sortBy" returns="Array" signature="sortBy(property) =&gt; Array">
            <variable citdl="String" doc="name(s) to sort on" ilk="argument" name="property" />
          </scope>
        </scope>
        <scope classrefs="Error" doc="A subclass of the JavaScript Error object for use in Ember." ilk="class" name="Error" />
        <scope classrefs="Ember.Object" doc="`Ember.EventDispatcher` handles delegating browser events to their&#xA;corresponding `Ember.Views.` For example, when you click on a view,&#xA;`Ember.EventDispatcher` ensures that that view&apos;s `mouseDown` method gets&#xA;called." ilk="class" name="EventDispatcher">
          <variable attributes="property private" citdl="Object" doc="The set of events names (and associated handler function names) to be setup&#xA;and dispatched by the `EventDispatcher`. Modifications to this list can be done&#xA;at setup time, generally via the `Ember.Application.customEvents` hash.&#xA; To add new events to be listened to:&#xA; ```javascript&#xA;var App = Ember.Application.create({&#xA;  customEvents: {&#xA;    paste: &apos;paste&apos;&#xA;  }&#xA;});&#xA;```&#xA; To prevent default events from being listened to:&#xA; ```javascript&#xA;var App = Ember.Application.create({&#xA;  customEvents: {&#xA;    mouseenter: null,&#xA;    mouseleave: null&#xA;  }&#xA;});&#xA;```" name="EventDispatcher" />
          <variable attributes="property private" citdl="DOMElement" doc="The root DOM element to which event listeners should be attached. Event&#xA;listeners will be attached to the document unless this is overridden.&#xA; Can be specified as a DOMElement or a selector string.&#xA; The default body is a string since this may be evaluated before document.body&#xA;exists in the DOM." name="EventDispatcher" />
          <variable attributes="property private" citdl="boolean" doc="It enables events to be dispatched to the view&apos;s `eventManager.` When present,&#xA;this object takes precedence over handling of events on the view itself.&#xA; Note that most Ember applications do not use this feature. If your app also&#xA;does not use it, consider setting this property to false to gain some performance&#xA;improvement by allowing the EventDispatcher to skip the search for the&#xA;`eventManager` on the view tree.&#xA; ```javascript&#xA;var EventDispatcher = Em.EventDispatcher.extend({&#xA;  events: {&#xA;      click       : &apos;click&apos;,&#xA;      focusin     : &apos;focusIn&apos;,&#xA;      focusout    : &apos;focusOut&apos;,&#xA;      change      : &apos;change&apos;&#xA;  },&#xA;  canDispatchToEventManager: false&#xA;});&#xA;container.register(&apos;event_dispatcher:main&apos;, EventDispatcher);&#xA;```" name="EventDispatcher" />
          <scope attributes="private" doc="Sets up event listeners for standard browser events.&#xA; This will be called after the browser sends a `DOMContentReady` event. By&#xA;default, it will set up all of the listeners on the document body. If you&#xA;would like to register the listeners on a different element, set the event&#xA;dispatcher&apos;s `root` property." ilk="function" name="setup" signature="setup(addedEvents)">
            <variable citdl="Object" ilk="argument" name="addedEvents" />
          </scope>
          <scope attributes="private" doc="Registers an event listener on the rootElement. If the given event is&#xA;triggered, the provided event handler will be triggered on the target view.&#xA; If the target view does not implement the event handler, or if the handler&#xA;returns `false`, the parent view will be called. The event will continue to&#xA;bubble to each successive parent view until it reaches the top." ilk="function" name="setupHandler" signature="setupHandler(rootElement,event,eventName)">
            <variable citdl="Element" ilk="argument" name="rootElement" />
            <variable citdl="String" doc="the browser-originated event to listen to" ilk="argument" name="event" />
            <variable citdl="String" doc="the name of the method to call on the view" ilk="argument" name="eventName" />
          </scope>
          <scope attributes="private" ilk="function" name="getViewRange" signature="getViewRange(view)">
            <variable citdl="Ember.View" ilk="argument" name="view" />
          </scope>
          <scope attributes="private" doc="`getViewClientRects` provides information about the position of the border&#xA;box edges of a view relative to the viewport.&#xA;  &#xA;It is only intended to be used by development tools like the Ember Inspector&#xA;and may not work on older browsers." ilk="function" name="getViewClientRects" signature="getViewClientRects(view)">
            <variable citdl="Ember.View" ilk="argument" name="view" />
          </scope>
          <scope attributes="private" doc="`getViewBoundingClientRect` provides information about the position of the&#xA;bounding border box edges of a view relative to the viewport.&#xA;  &#xA;It is only intended to be used by development tools like the Ember Inpsector&#xA;and may not work on older browsers." ilk="function" name="getViewBoundingClientRect" signature="getViewBoundingClientRect(view)">
            <variable citdl="Ember.View" ilk="argument" name="view" />
          </scope>
        </scope>
        <scope doc="This mixin allows for Ember objects to subscribe to and emit events.&#xA;  &#xA;```javascript&#xA;App.Person = Ember.Object.extend(Ember.Evented, {&#xA;  greet: function() {&#xA;    // ...&#xA;    this.trigger(&apos;greet&apos;);&#xA;  }&#xA;});&#xA;  &#xA;var person = App.Person.create();&#xA;  &#xA;person.on(&apos;greet&apos;, function() {&#xA;  console.log(&apos;Our person has greeted&apos;);&#xA;});&#xA;  &#xA;person.greet();&#xA;  &#xA;// outputs: &apos;Our person has greeted&apos;&#xA;```&#xA;  &#xA;You can also chain multiple event subscriptions:&#xA;  &#xA;```javascript&#xA;person.on(&apos;greet&apos;, function() {&#xA;  console.log(&apos;Our person has greeted&apos;);&#xA;}).one(&apos;greet&apos;, function() {&#xA;  console.log(&apos;Offer one-time special&apos;);&#xA;}).off(&apos;event&apos;, this, forgetThis);&#xA;```" ilk="class" name="Evented">
          <scope attributes="public" doc="Subscribes to a named event with given function.&#xA; ```javascript&#xA;person.on(&apos;didLoad&apos;, function() {&#xA;  // fired once the person has loaded&#xA;});&#xA;```&#xA; An optional target can be passed in as the 2nd argument that will&#xA;be set as the &quot;this&quot; for the callback. This is a good way to give your&#xA;function access to the object triggering the event. When the target&#xA;parameter is used the callback becomes the third argument." ilk="function" name="on" signature="on(name,target,method)">
            <variable citdl="String" doc="The name of the event" ilk="argument" name="name" />
            <variable citdl="Object" doc="The &quot;this&quot; binding for the callback" ilk="argument" name="target" />
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="method" />
          </scope>
          <scope attributes="public" doc="Subscribes a function to a named event and then cancels the subscription&#xA;after the first time the event is triggered. It is good to use ``one`` when&#xA;you only care about the first time an event has taken place.&#xA; This function takes an optional 2nd argument that will become the &quot;this&quot;&#xA;value for the callback. If this argument is passed then the 3rd argument&#xA;becomes the function." ilk="function" name="one" signature="one(name,target,method)">
            <variable citdl="String" doc="The name of the event" ilk="argument" name="name" />
            <variable citdl="Object" doc="The &quot;this&quot; binding for the callback" ilk="argument" name="target" />
            <variable citdl="Function" doc="The callback to execute" ilk="argument" name="method" />
          </scope>
          <scope attributes="public" doc="Triggers a named event for the object. Any additional arguments&#xA;will be passed as parameters to the functions that are subscribed to the&#xA;event.&#xA; ```javascript&#xA;person.on(&apos;didEat&apos;, function(food) {&#xA;  console.log(&apos;person ate some &apos; + food);&#xA;});&#xA; person.trigger(&apos;didEat&apos;, &apos;broccoli&apos;);&#xA; // outputs: person ate some broccoli&#xA;```" ilk="function" name="trigger" signature="trigger(name,args)">
            <variable citdl="String" doc="The name of the event" ilk="argument" name="name" />
            <variable citdl="Object..." doc="Optional arguments to pass on" ilk="argument" name="args" />
          </scope>
          <scope attributes="public" doc="Cancels subscription for given name, target, and method." ilk="function" name="off" signature="off(name,target,method)">
            <variable citdl="String" doc="The name of the event" ilk="argument" name="name" />
            <variable citdl="Object" doc="The target of the subscription" ilk="argument" name="target" />
            <variable citdl="Function" doc="The function of the subscription" ilk="argument" name="method" />
          </scope>
          <scope attributes="public" doc="Checks to see if object has any subscriptions for named event." ilk="function" name="has" returns="Boolean" signature="has(name) =&gt; Boolean">
            <variable citdl="String" doc="The name of the event" ilk="argument" name="name" />
          </scope>
        </scope>
        <scope doc="The hash of enabled Canary features. Add to this, any canary features&#xA;before creating your application.&#xA;  &#xA;Alternatively (and recommended), you can also define `EmberENV.FEATURES`&#xA;if you need to enable features flagged at runtime." ilk="class" name="FEATURES">
          <scope attributes="public" doc="Determine whether the specified `feature` is enabled. Used by Ember&apos;s&#xA;build tools to exclude experimental features from beta/stable builds.&#xA;  &#xA;You can define the following configuration options:&#xA;  &#xA;* `EmberENV.ENABLE_OPTIONAL_FEATURES` - enable any features that have not been explicitly&#xA;  enabled/disabled." ilk="function" name="isEnabled" returns="Boolean" signature="isEnabled(feature) =&gt; Boolean">
            <variable citdl="String" doc="The feature to check" ilk="argument" name="feature" />
          </scope>
        </scope>
        <scope doc="The `Ember.Freezable` mixin implements some basic methods for marking an&#xA;object as frozen. Once an object is frozen it should be read only. No changes&#xA;may be made the internal state of the object.&#xA;  &#xA;## Enforcement&#xA;  &#xA;To fully support freezing in your subclass, you must include this mixin and&#xA;override any method that might alter any property on the object to instead&#xA;raise an exception. You can check the state of an object by checking the&#xA;`isFrozen` property.&#xA;  &#xA;Although future versions of JavaScript may support language-level freezing&#xA;object objects, that is not the case today. Even if an object is freezable,&#xA;it is still technically possible to modify the object, even though it could&#xA;break other parts of your application that do not expect a frozen object to&#xA;change. It is, therefore, very important that you always respect the&#xA;`isFrozen` property on all freezable objects.&#xA;  &#xA;## Example Usage&#xA;  &#xA;The example below shows a simple object that implement the `Ember.Freezable`&#xA;protocol.&#xA;  &#xA;```javascript&#xA;Contact = Ember.Object.extend(Ember.Freezable, {&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  &#xA;  // swaps the names&#xA;  swapNames: function() {&#xA;    if (this.get(&apos;isFrozen&apos;)) throw Ember.FROZEN_ERROR;&#xA;    var tmp = this.get(&apos;firstName&apos;);&#xA;    this.set(&apos;firstName&apos;, this.get(&apos;lastName&apos;));&#xA;    this.set(&apos;lastName&apos;, tmp);&#xA;    return this;&#xA;  }&#xA;  &#xA;});&#xA;  &#xA;c = Contact.create({ firstName: &quot;John&quot;, lastName: &quot;Doe&quot; });&#xA;c.swapNames();  // returns c&#xA;c.freeze();&#xA;c.swapNames();  // EXCEPTION&#xA;```&#xA;  &#xA;## Copying&#xA;  &#xA;Usually the `Ember.Freezable` protocol is implemented in cooperation with the&#xA;`Ember.Copyable` protocol, which defines a `frozenCopy()` method that will&#xA;return a frozen object, if the object implements this method as well." ilk="class" name="Freezable">
          <variable attributes="property private" citdl="Boolean" doc="Set to `true` when the object is frozen. Use this property to detect&#xA;whether your object is frozen or not." name="Freezable" />
          <scope attributes="private" doc="Freezes the object. Once this method has been called the object should&#xA;no longer allow any properties to be edited." ilk="function" name="freeze" returns="Object" signature="freeze() =&gt; Object" />
        </scope>
        <scope ilk="class" name="HTMLBars">
          <scope attributes="private" ilk="function" name="_registerHelper" signature="_registerHelper(name,helperFunc)">
            <variable citdl="String" ilk="argument" name="name" />
            <variable citdl="Object|Function" doc="the helper function to add" ilk="argument" name="helperFunc" />
          </scope>
          <scope attributes="private" ilk="function" name="_registerHelper" signature="_registerHelper(name,keyword)">
            <variable citdl="String" ilk="argument" name="name" />
            <variable citdl="Object|Function" doc="the keyword to add" ilk="argument" name="keyword" />
          </scope>
          <scope attributes="private" doc="Find templates stored in the head tag as script tags and make them available&#xA;to `Ember.CoreView` in the global `Ember.TEMPLATES` object. This will be run&#xA;as a jQuery DOM-ready callback.&#xA;  &#xA;Script tags with `text/x-handlebars` will be compiled&#xA;with Ember&apos;s template compiler and are suitable for use as a view&apos;s template.&#xA;Those with type `text/x-raw-handlebars` will be compiled with regular&#xA;Handlebars and are suitable for use in views&apos; computed properties." ilk="function" name="bootstrap" signature="bootstrap(ctx)">
            <variable ilk="argument" name="ctx" />
          </scope>
          <scope attributes="private" doc="Used to lookup/resolve handlebars helpers. The lookup order is:&#xA;  &#xA;* Look for a registered helper&#xA;* If a dash exists in the name:&#xA;  * Look for a helper registed in the container&#xA;  * Use Ember.ComponentLookup to find an Ember.Component that resolves&#xA;    to the given name" ilk="function" name="resolveHelper" returns="Helper" signature="resolveHelper(name) =&gt; Helper">
            <variable citdl="String" doc="the name of the helper to lookup" ilk="argument" name="name" />
          </scope>
          <scope attributes="private" doc="Create a bound helper. Accepts a function that receives the ordered and hash parameters&#xA;from the template. If a bound property was provided in the template it will be resolved to its&#xA;value and any changes to the bound property cause the helper function to be re-run with the updated&#xA;values.&#xA;  &#xA;* `params` - An array of resolved ordered parameters.&#xA;* `hash` - An object containing the hash parameters.&#xA;  &#xA;For example:&#xA;  &#xA;* With an unquoted ordered parameter:&#xA;  &#xA;  ```javascript&#xA;  {{x-capitalize foo}}&#xA;  ```&#xA;  &#xA;  Assuming `foo` was set to `&quot;bar&quot;`, the bound helper would receive `[&quot;bar&quot;]` as its first argument, and&#xA;  an empty hash as its second.&#xA;  &#xA;* With a quoted ordered parameter:&#xA;  &#xA;  ```javascript&#xA;  {{x-capitalize &quot;foo&quot;}}&#xA;  ```&#xA;  &#xA;  The bound helper would receive `[&quot;foo&quot;]` as its first argument, and an empty hash as its second.&#xA;  &#xA;* With an unquoted hash parameter:&#xA;  &#xA;  ```javascript&#xA;  {{x-repeat &quot;foo&quot; count=repeatCount}}&#xA;  ```&#xA;  &#xA;  Assuming that `repeatCount` resolved to 2, the bound helper would receive `[&quot;foo&quot;]` as its first argument,&#xA;  and { count: 2 } as its second." ilk="function" name="makeBoundHelper" signature="makeBoundHelper(fn)">
            <variable citdl="Function" ilk="argument" name="fn" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="`Ember.HashLocation` implements the location API using the browser&apos;s&#xA;hash. At present, it relies on a `hashchange` event existing in the&#xA;browser." ilk="class" name="HashLocation">
          <scope attributes="private" ilk="function" name="getHash" signature="getHash()" />
          <scope attributes="private" doc="Returns the normalized URL, constructed from `location.hash`.&#xA; e.g. `#/foo` =&gt; `/foo` as well as `#/foo#bar` =&gt; `/foo#bar`.&#xA; By convention, hashed paths must begin with a forward slash, otherwise they&#xA;are not treated as a path so we can distinguish intent." ilk="function" name="getURL" signature="getURL()" />
          <scope attributes="private" doc="Set the `location.hash` and remembers what was set. This prevents&#xA;`onUpdateURL` callbacks from triggering when the hash was set by&#xA;`HashLocation`." ilk="function" name="setURL" signature="setURL(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Uses location.replace to update the url without a page reload&#xA;or history modification." ilk="function" name="replaceURL" signature="replaceURL(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Register a callback to be invoked when the hash changes. These&#xA;callbacks will execute when the user presses the back or forward&#xA;button, but not after `setURL` is invoked." ilk="function" name="onUpdateURL" signature="onUpdateURL(callback)">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="private" doc="Given a URL, formats it to be placed into the page as part&#xA;of an element&apos;s `href` attribute.&#xA; This is used, for example, when using the {{action}} helper&#xA;to generate a URL based on an event." ilk="function" name="formatURL" signature="formatURL(url)">
            <variable citdl="String" ilk="argument" name="url" />
          </scope>
          <scope attributes="private" doc="Cleans up the HashLocation event listener." ilk="function" name="willDestroy" signature="willDestroy()" />
        </scope>
        <scope doc="Ember Helpers are functions that can compute values, and are used in templates.&#xA;For example, this code calls a helper named `format-currency`:&#xA;  &#xA;```handlebars&#xA;&lt;div&gt;{{format-currency cents currency=&quot;$&quot;}}&lt;/div&gt;&#xA;```&#xA;  &#xA;Additionally a helper can be called as a nested helper (sometimes called a&#xA;subexpression). In this example, the computed value of a helper is passed&#xA;to a component named `show-money`:&#xA;  &#xA;```handlebars&#xA;{{show-money amount=(format-currency cents currency=&quot;$&quot;)}}&#xA;```&#xA;  &#xA;Helpers defined using a class must provide a `compute` function. For example:&#xA;  &#xA;```js&#xA;export default Ember.Helper.extend({&#xA;  compute(params, hash) {&#xA;    let cents = params[0];&#xA;    let currency = hash.currency;&#xA;    return `${currency}${cents * 0.01}`;&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;Each time the input to a helper changes, the `compute` function will be&#xA;called again.&#xA;  &#xA;As instances, these helpers also have access to the container an will accept&#xA;injected dependencies.&#xA;  &#xA;Additionally, class helpers can call `recompute` to force a new computation." ilk="class" name="Helper">
          <scope attributes="public" doc="On a class-based helper, it may be useful to force a recomputation of that&#xA;helpers value. This is akin to `rerender` on a component.&#xA; For example, this component will rerender when the `currentUser` on a&#xA;session service changes:&#xA; ```js&#xA;// app/helpers/current-user-email.js&#xA;export default Ember.Helper.extend({&#xA;  session: Ember.inject.service(),&#xA;  onNewUser: Ember.observer(&apos;session.currentUser&apos;, function() {&#xA;    this.recompute();&#xA;  }),&#xA;  compute() {&#xA;    return this.get(&apos;session.currentUser.email&apos;);&#xA;  }&#xA;});&#xA;```" ilk="function" name="recompute" signature="recompute()" />
          <scope attributes="public" doc="Override this function when writing a class-based helper." ilk="function" name="compute" signature="compute(params,hash)">
            <variable citdl="Array" doc="The positional arguments to the helper" ilk="argument" name="params" />
            <variable citdl="Object" doc="The named arguments to the helper" ilk="argument" name="hash" />
          </scope>
          <scope attributes="public" doc="In many cases, the ceremony of a full `Ember.Helper` class is not required.&#xA;The `helper` method create pure-function helpers without instances. For&#xA;example:&#xA;  &#xA;```js&#xA;// app/helpers/format-currency.js&#xA;export default Ember.Helper.helper(function(params, hash) {&#xA;  let cents = params[0];&#xA;  let currency = hash.currency;&#xA;  return `${currency}${cents * 0.01}`;&#xA;});&#xA;```" ilk="function" name="helper" signature="helper(helper)">
            <variable citdl="Function" doc="The helper function" ilk="argument" name="helper" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="Ember.HistoryLocation implements the location API using the browser&apos;s&#xA;history.pushState API." ilk="class" name="HistoryLocation">
          <scope attributes="private" doc="Used to set state on first call to setURL" ilk="function" name="initState" signature="initState()" />
          <variable attributes="property private" doc="Will be pre-pended to path upon state change" name="HistoryLocation" />
          <scope attributes="private" doc="Returns the current `location.pathname` without `rootURL` or `baseURL`" ilk="function" name="getURL" returns="String" signature="getURL() =&gt; String" />
          <scope attributes="private" doc="Uses `history.pushState` to update the url without a page reload." ilk="function" name="setURL" signature="setURL(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Uses `history.replaceState` to update the url without a page reload&#xA;or history modification." ilk="function" name="replaceURL" signature="replaceURL(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Get the current `history.state`. Checks for if a polyfill is&#xA;required and if so fetches this._historyState. The state returned&#xA;from getState may be null if an iframe has changed a window&apos;s&#xA;history." ilk="function" name="getState" returns="Object" signature="getState() =&gt; Object" />
          <scope attributes="private" doc="Pushes a new state." ilk="function" name="pushState" signature="pushState(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Replaces the current state." ilk="function" name="replaceState" signature="replaceState(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Register a callback to be invoked whenever the browser&#xA;history changes, including using forward and back buttons." ilk="function" name="onUpdateURL" signature="onUpdateURL(callback)">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="private" doc="Used when using `{{action}}` helper.  The url is always appended to the rootURL." ilk="function" name="formatURL" returns="String" signature="formatURL(url) =&gt; String">
            <variable citdl="String" ilk="argument" name="url" />
          </scope>
          <scope attributes="private" doc="Cleans up the HistoryLocation event listener." ilk="function" name="willDestroy" signature="willDestroy()" />
          <scope attributes="private" ilk="function" name="getHash" signature="getHash()" />
        </scope>
        <scope doc="Read-only property that returns the result of a container lookup." ilk="class" name="InjectedProperty" />
        <scope doc="The purpose of the Ember Instrumentation module is&#xA;to provide efficient, general-purpose instrumentation&#xA;for Ember.&#xA;  &#xA;Subscribe to a listener by using `Ember.subscribe`:&#xA;  &#xA;```javascript&#xA;Ember.subscribe(&quot;render&quot;, {&#xA;  before: function(name, timestamp, payload) {&#xA;  &#xA;  },&#xA;  &#xA;  after: function(name, timestamp, payload) {&#xA;  &#xA;  }&#xA;});&#xA;```&#xA;  &#xA;If you return a value from the `before` callback, that same&#xA;value will be passed as a fourth parameter to the `after`&#xA;callback.&#xA;  &#xA;Instrument a block of code by using `Ember.instrument`:&#xA;  &#xA;```javascript&#xA;Ember.instrument(&quot;render.handlebars&quot;, payload, function() {&#xA;  // rendering logic&#xA;}, binding);&#xA;```&#xA;  &#xA;Event names passed to `Ember.instrument` are namespaced&#xA;by periods, from more general to more specific. Subscribers&#xA;can listen for events by whatever level of granularity they&#xA;are interested in.&#xA;  &#xA;In the above example, the event is `render.handlebars`,&#xA;and the subscriber listened for all events beginning with&#xA;`render`. It would receive callbacks for events named&#xA;`render`, `render.handlebars`, `render.container`, or&#xA;even `render.handlebars.layout`." ilk="class" name="Instrumentation">
          <scope attributes="private" doc="Notifies event&apos;s subscribers, calls `before` and `after` hooks." ilk="function" name="instrument" signature="instrument(name,_payload,callback,binding)">
            <variable citdl="String" doc="Namespaced event name." ilk="argument" name="name" />
            <variable citdl="Object" ilk="argument" name="_payload" />
            <variable citdl="Function" doc="Function that you&apos;re instrumenting." ilk="argument" name="callback" />
            <variable citdl="Object" doc="Context that instrument function is called with." ilk="argument" name="binding" />
          </scope>
          <scope attributes="private" doc="Subscribes to a particular event or instrumented block of code." ilk="function" name="subscribe" returns="Subscriber" signature="subscribe(pattern,object) =&gt; Subscriber">
            <variable citdl="String" doc="Namespaced event name." ilk="argument" name="pattern" />
            <variable citdl="Object" doc="Before and After hooks." ilk="argument" name="object" />
          </scope>
          <scope attributes="private" doc="Unsubscribes from a particular event or instrumented block of code." ilk="function" name="unsubscribe" signature="unsubscribe(subscriber)">
            <variable citdl="Object" ilk="argument" name="subscriber" />
          </scope>
          <scope attributes="private" doc="Resets `Ember.Instrumentation` by flushing list of subscribers." ilk="function" name="reset" signature="reset()" />
        </scope>
        <scope ilk="class" name="InstrumentationSupport">
          <variable attributes="property public" citdl="String" doc="Used to identify this view during debugging" name="InstrumentationSupport" />
        </scope>
        <scope ilk="class" name="LegacyViewSupport">
          <scope attributes="private" doc="Removes all children from the `parentView`." ilk="function" name="removeAllChildren" returns="Ember.View" signature="removeAllChildren() =&gt; Ember.View" />
          <scope attributes="private" doc="Return the nearest ancestor whose parent is an instance of&#xA;`klass`." ilk="function" name="nearestChildOf" signature="nearestChildOf(klass)">
            <variable citdl="Class" doc="Subclass of Ember.View (or Ember.View itself)" ilk="argument" name="klass" />
          </scope>
          <scope attributes="private" doc="Return the nearest ancestor that is an instance of the provided&#xA;class." ilk="function" name="nearestInstanceOf" signature="nearestInstanceOf(klass)">
            <variable citdl="Class" doc="Subclass of Ember.View (or Ember.View itself)" ilk="argument" name="klass" />
          </scope>
          <scope attributes="private" doc="If a value that affects template rendering changes, the view should be&#xA;re-rendered to reflect the new value." ilk="function" name="_contextDidChange" signature="_contextDidChange()" />
        </scope>
        <scope classrefs="Ember.Component" doc="`Ember.LinkComponent` renders an element whose `click` event triggers a&#xA;transition of the application&apos;s instance of `Ember.Router` to&#xA;a supplied route by name.&#xA;  &#xA;`Ember.LinkComponent` components are invoked with {{#link-to}}. Properties&#xA;of this class can be overridden with `reopen` to customize application-wide&#xA;behavior." ilk="class" name="LinkComponent">
          <variable attributes="property private" name="LinkComponent" />
          <variable attributes="property public" doc="Used to determine when this `LinkComponent` is active." name="LinkComponent" />
          <variable attributes="property public" doc="Sets the `title` attribute of the `LinkComponent`&apos;s HTML element." name="LinkComponent" />
          <variable attributes="property public" doc="Sets the `rel` attribute of the `LinkComponent`&apos;s HTML element." name="LinkComponent" />
          <variable attributes="property public" doc="Sets the `tabindex` attribute of the `LinkComponent`&apos;s HTML element." name="LinkComponent" />
          <variable attributes="property public" doc="Sets the `target` attribute of the `LinkComponent`&apos;s HTML element." name="LinkComponent" />
          <variable attributes="property private" citdl="String" doc="The CSS class to apply to `LinkComponent`&apos;s element when its `active`&#xA;property is `true`." name="LinkComponent" />
          <variable attributes="property private" citdl="String" doc="The CSS class to apply to `LinkComponent`&apos;s element when its `loading`&#xA;property is `true`." name="LinkComponent" />
          <variable attributes="property private" citdl="String" doc="The CSS class to apply to a `LinkComponent`&apos;s element when its `disabled`&#xA;property is `true`." name="LinkComponent" />
          <variable attributes="property public" citdl="Boolean" doc="Determines whether the `LinkComponent` will trigger routing via&#xA;the `replaceWith` routing strategy." name="LinkComponent" />
          <variable attributes="property public" citdl="Array | String" doc="By default the `{{link-to}}` component will bind to the `href` and&#xA;`title` attributes. It&apos;s discouraged that you override these defaults,&#xA;however you can push onto the array if needed." name="LinkComponent" />
          <variable attributes="property public" citdl="Array" doc="By default the `{{link-to}}` component will bind to the `active`, `loading`,&#xA;and `disabled` classes. It is discouraged to override these directly." name="LinkComponent" />
          <variable attributes="property private" citdl="String" doc="By default the `{{link-to}}` component responds to the `click` event. You&#xA;can override this globally by setting this property to your custom&#xA;event name.&#xA; This is particularly useful on mobile when one wants to avoid the 300ms&#xA;click delay using some sort of custom `tap` event." name="LinkComponent" />
          <variable attributes="event private" doc="Triggers the `LinkComponent`&apos;s routing behavior. If&#xA;`eventName` is changed to a value other than `click`&#xA;the routing behavior will trigger on that custom event&#xA;instead." name="LinkComponent" />
          <scope attributes="private" doc="An overridable method called when `LinkComponent` objects are instantiated.&#xA; Example:&#xA; ```javascript&#xA;App.MyLinkComponent = Ember.LinkComponent.extend({&#xA;  init: function() {&#xA;    this._super(...arguments);&#xA;    Ember.Logger.log(&apos;Event is &apos; + this.get(&apos;eventName&apos;));&#xA;  }&#xA;});&#xA;```&#xA; NOTE: If you do override `init` for a framework class like `Ember.View`,&#xA;be sure to call `this._super(...arguments)` in your&#xA;`init` declaration! If you don&apos;t, Ember may not have an opportunity to&#xA;do important setup work, and you&apos;ll see strange behavior in your&#xA;application." ilk="function" name="init" signature="init()" />
          <variable attributes="property private" doc="Accessed as a classname binding to apply the `LinkComponent`&apos;s `disabledClass`&#xA;CSS `class` to the element when the link is disabled.&#xA; When `true` interactions with the element will not trigger route changes." name="LinkComponent" />
          <variable attributes="property private" doc="Accessed as a classname binding to apply the `LinkComponent`&apos;s `activeClass`&#xA;CSS `class` to the element when the link is active.&#xA; A `LinkComponent` is considered active when its `currentWhen` property is `true`&#xA;or the application&apos;s current route is the route the `LinkComponent` would trigger&#xA;transitions into.&#xA; The `currentWhen` property can match against multiple routes by separating&#xA;route names using the ` ` (space) character." name="LinkComponent" />
          <scope attributes="private" doc="Event handler that invokes the link, activating the associated route." ilk="function" name="_invoke" signature="_invoke(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <variable attributes="property private" doc="Sets the element&apos;s `href` attribute to the url for&#xA;the `LinkComponent`&apos;s targeted route.&#xA; If the `LinkComponent`&apos;s `tagName` is changed to a value other&#xA;than `a`, this property will be ignored." name="LinkComponent" />
          <variable attributes="property private" citdl="String" doc="The default href value to use while a link-to is loading.&#xA;Only applies when tagName is &apos;a&apos;" name="LinkComponent" />
        </scope>
        <scope doc="Ember.Location returns an instance of the correct implementation of&#xA;the `location` API.&#xA;  &#xA;## Implementations&#xA;  &#xA;You can pass an implementation name (`hash`, `history`, `none`) to force a&#xA;particular implementation to be used in your application.&#xA;  &#xA;### HashLocation&#xA;  &#xA;Using `HashLocation` results in URLs with a `#` (hash sign) separating the&#xA;server side URL portion of the URL from the portion that is used by Ember.&#xA;This relies upon the `hashchange` event existing in the browser.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;posts&apos;, function() {&#xA;    this.route(&apos;new&apos;);&#xA;  });&#xA;});&#xA;  &#xA;App.Router.reopen({&#xA;  location: &apos;hash&apos;&#xA;});&#xA;```&#xA;  &#xA;This will result in a posts.new url of `/#/posts/new`.&#xA;  &#xA;### HistoryLocation&#xA;  &#xA;Using `HistoryLocation` results in URLs that are indistinguishable from a&#xA;standard URL. This relies upon the browser&apos;s `history` API.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;posts&apos;, function() {&#xA;    this.route(&apos;new&apos;);&#xA;  });&#xA;});&#xA;  &#xA;App.Router.reopen({&#xA;  location: &apos;history&apos;&#xA;});&#xA;```&#xA;  &#xA;This will result in a posts.new url of `/posts/new`.&#xA;  &#xA;Keep in mind that your server must serve the Ember app at all the routes you&#xA;define.&#xA;  &#xA;### AutoLocation&#xA;  &#xA;Using `AutoLocation`, the router will use the best Location class supported by&#xA;the browser it is running in.&#xA;  &#xA;Browsers that support the `history` API will use `HistoryLocation`, those that&#xA;do not, but still support the `hashchange` event will use `HashLocation`, and&#xA;in the rare case neither is supported will use `NoneLocation`.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;posts&apos;, function() {&#xA;    this.route(&apos;new&apos;);&#xA;  });&#xA;});&#xA;  &#xA;App.Router.reopen({&#xA;  location: &apos;auto&apos;&#xA;});&#xA;```&#xA;  &#xA;This will result in a posts.new url of `/posts/new` for modern browsers that&#xA;support the `history` api or `/#/posts/new` for older ones, like Internet&#xA;Explorer 9 and below.&#xA;  &#xA;When a user visits a link to your application, they will be automatically&#xA;upgraded or downgraded to the appropriate `Location` class, with the URL&#xA;transformed accordingly, if needed.&#xA;  &#xA;Keep in mind that since some of your users will use `HistoryLocation`, your&#xA;server must serve the Ember app at all the routes you define.&#xA;  &#xA;### NoneLocation&#xA;  &#xA;Using `NoneLocation` causes Ember to not store the applications URL state&#xA;in the actual URL. This is generally used for testing purposes, and is one&#xA;of the changes made when calling `App.setupForTesting()`.&#xA;  &#xA;## Location API&#xA;  &#xA;Each location implementation must provide the following methods:&#xA;  &#xA;* implementation: returns the string name used to reference the implementation.&#xA;* getURL: returns the current URL.&#xA;* setURL(path): sets the current URL.&#xA;* replaceURL(path): replace the current URL (optional).&#xA;* onUpdateURL(callback): triggers the callback when the URL changes.&#xA;* formatURL(url): formats `url` to be placed into `href` attribute.&#xA;* detect() (optional): instructs the location to do any feature detection&#xA;    necessary. If the location needs to redirect to a different URL, it&#xA;    can cancel routing by setting the `cancelRouterSetup` property on itself&#xA;    to `false`.&#xA;  &#xA;Calling setURL or replaceURL will not trigger onUpdateURL callbacks." ilk="class" name="Location">
          <scope attributes="private" doc="This is deprecated in favor of using the container to lookup the location&#xA;implementation as desired.&#xA; For example:&#xA; ```javascript&#xA;// Given a location registered as follows:&#xA;container.register(&apos;location:history-test&apos;, HistoryTestLocation);&#xA; // You could create a new instance via:&#xA;container.lookup(&apos;location:history-test&apos;);&#xA;```" ilk="function" name="create" returns="Object" signature="create(options) =&gt; Object">
            <variable citdl="Object" ilk="argument" name="options" />
          </scope>
          <scope attributes="private" doc="Returns the current `location.hash` by parsing location.href since browsers&#xA;inconsistently URL-decode `location.hash`.&#xA; https://bugzilla.mozilla.org/show_bug.cgi?id=483304" ilk="function" name="getHash" signature="getHash()" />
        </scope>
        <scope doc="Inside Ember-Metal, simply uses the methods from `imports.console`.&#xA;Override this to provide more robust logging functionality." ilk="class" name="Logger">
          <scope attributes="public" doc="Logs the arguments to the console.&#xA;You can pass as many arguments as you want and they will be joined together with a space.&#xA;  ```javascript&#xA; var foo = 1;&#xA; Ember.Logger.log(&apos;log value of foo:&apos;, foo);&#xA; // &quot;log value of foo: 1&quot; will be printed to the console&#xA; ```" ilk="function" name="log" signature="log(arguments)">
            <variable citdl="*" ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="Prints the arguments to the console with a warning icon.&#xA;You can pass as many arguments as you want and they will be joined together with a space.&#xA;  ```javascript&#xA; Ember.Logger.warn(&apos;Something happened!&apos;);&#xA; // &quot;Something happened!&quot; will be printed to the console with a warning icon.&#xA; ```" ilk="function" name="warn" signature="warn(arguments)">
            <variable citdl="*" ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="Prints the arguments to the console with an error icon, red text and a stack trace.&#xA;You can pass as many arguments as you want and they will be joined together with a space.&#xA;  ```javascript&#xA; Ember.Logger.error(&apos;Danger! Danger!&apos;);&#xA; // &quot;Danger! Danger!&quot; will be printed to the console in red text.&#xA; ```" ilk="function" name="error" signature="error(arguments)">
            <variable citdl="*" ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="Logs the arguments to the console.&#xA;You can pass as many arguments as you want and they will be joined together with a space.&#xA;  ```javascript&#xA; var foo = 1;&#xA; Ember.Logger.info(&apos;log value of foo:&apos;, foo);&#xA; // &quot;log value of foo: 1&quot; will be printed to the console&#xA; ```" ilk="function" name="info" signature="info(arguments)">
            <variable citdl="*" ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="Logs the arguments to the console in blue text.&#xA;You can pass as many arguments as you want and they will be joined together with a space.&#xA;  ```javascript&#xA; var foo = 1;&#xA; Ember.Logger.debug(&apos;log value of foo:&apos;, foo);&#xA; // &quot;log value of foo: 1&quot; will be printed to the console&#xA; ```" ilk="function" name="debug" signature="debug(arguments)">
            <variable citdl="*" ilk="argument" name="arguments" />
          </scope>
          <scope attributes="public" doc="If the value passed into `Ember.Logger.assert` is not truthy it will throw an error with a stack trace.&#xA;  ```javascript&#xA; Ember.Logger.assert(true); // undefined&#xA; Ember.Logger.assert(true === false); // Throws an Assertion failed error.&#xA; ```" ilk="function" name="assert" signature="assert(bool)">
            <variable citdl="Boolean" doc="Value to test" ilk="argument" name="bool" />
          </scope>
        </scope>
        <scope doc="A Map stores values indexed by keys. Unlike JavaScript&apos;s&#xA;default Objects, the keys of a Map can be any JavaScript&#xA;object.&#xA;  &#xA;Internally, a Map has two data structures:&#xA;  &#xA;1. `keys`: an OrderedSet of all of the existing keys&#xA;2. `values`: a JavaScript Object indexed by the `Ember.guidFor(key)`&#xA;  &#xA;When a key/value pair is added for the first time, we&#xA;add the key to the `keys` OrderedSet, and create or&#xA;replace an entry in `values`. When an entry is deleted,&#xA;we delete its entry in `keys` and `values`." ilk="class" name="Map">
          <scope attributes="private" ilk="function" name="create" signature="create()" />
          <variable attributes="property private" citdl="number" doc="This property will change as the number of objects in the map changes." name="Map" />
          <scope attributes="private" doc="Retrieve the value associated with a given key." ilk="function" name="get" returns="*" signature="get(key) =&gt; *">
            <variable citdl="*" ilk="argument" name="key" />
          </scope>
          <scope attributes="private" doc="Adds a value to the map. If a value for the given key has already been&#xA;provided, the new value will replace the old value." ilk="function" name="set" returns="Ember.Map" signature="set(key,value) =&gt; Ember.Map">
            <variable citdl="*" ilk="argument" name="key" />
            <variable citdl="*" ilk="argument" name="value" />
          </scope>
          <scope attributes="private" doc="Removes a value from the map for an associated key." ilk="function" name="delete" returns="Boolean" signature="delete(key) =&gt; Boolean">
            <variable citdl="*" ilk="argument" name="key" />
          </scope>
          <scope attributes="private" doc="Check whether a key is present." ilk="function" name="has" returns="Boolean" signature="has(key) =&gt; Boolean">
            <variable citdl="*" ilk="argument" name="key" />
          </scope>
          <scope attributes="private" doc="Iterate over all the keys and values. Calls the function once&#xA;for each key, passing in value, key, and the map being iterated over,&#xA;in that order.&#xA; The keys are guaranteed to be iterated over in insertion order." ilk="function" name="forEach" signature="forEach(callback,self)">
            <variable citdl="Function" ilk="argument" name="callback" />
            <variable citdl="*" doc="if passed, the `this` value inside the&#xA;  callback. By default, `this` is the map." ilk="argument" name="self" />
          </scope>
          <scope attributes="private" ilk="function" name="clear" signature="clear()" />
          <scope attributes="private" ilk="function" name="copy" returns="Ember.Map" signature="copy() =&gt; Ember.Map" />
        </scope>
        <scope classrefs="Ember.Map" ilk="class" name="MapWithDefault">
          <scope attributes="private" ilk="function" name="create" returns="Ember.MapWithDefault|Ember.Map" signature="create(options) =&gt; Ember.MapWithDefault|Ember.Map">
            <variable ilk="argument" name="options" />
          </scope>
          <scope attributes="private" doc="Retrieve the value associated with a given key." ilk="function" name="get" returns="*" signature="get(key) =&gt; *">
            <variable citdl="*" ilk="argument" name="key" />
          </scope>
          <scope attributes="private" ilk="function" name="copy" returns="Ember.MapWithDefault" signature="copy() =&gt; Ember.MapWithDefault" />
        </scope>
        <scope doc="The `Ember.Mixin` class allows you to create mixins, whose properties can be&#xA;added to other classes. For instance,&#xA;  &#xA;```javascript&#xA;App.Editable = Ember.Mixin.create({&#xA;  edit: function() {&#xA;    console.log(&apos;starting to edit&apos;);&#xA;    this.set(&apos;isEditing&apos;, true);&#xA;  },&#xA;  isEditing: false&#xA;});&#xA;  &#xA;// Mix mixins into classes by passing them as the first arguments to&#xA;// .extend.&#xA;App.CommentView = Ember.View.extend(App.Editable, {&#xA;  template: Ember.Handlebars.compile(&apos;{{#if view.isEditing}}...{{else}}...{{/if}}&apos;)&#xA;});&#xA;  &#xA;commentView = App.CommentView.create();&#xA;commentView.edit(); // outputs &apos;starting to edit&apos;&#xA;```&#xA;  &#xA;Note that Mixins are created with `Ember.Mixin.create`, not&#xA;`Ember.Mixin.extend`.&#xA;  &#xA;Note that mixins extend a constructor&apos;s prototype so arrays and object literals&#xA;defined as properties will be shared amongst objects that implement the mixin.&#xA;If you want to define a property in a mixin that is not shared, you can define&#xA;it either as a computed property or have it be created on initialization of the object.&#xA;  &#xA;```javascript&#xA;//filters array will be shared amongst any object implementing mixin&#xA;App.Filterable = Ember.Mixin.create({&#xA;  filters: Ember.A()&#xA;});&#xA;  &#xA;//filters will be a separate  array for every object implementing the mixin&#xA;App.Filterable = Ember.Mixin.create({&#xA;  filters: Ember.computed(function() {return Ember.A();})&#xA;});&#xA;  &#xA;//filters will be created as a separate array during the object&apos;s initialization&#xA;App.Filterable = Ember.Mixin.create({&#xA;  init: function() {&#xA;    this._super(...arguments);&#xA;    this.set(&quot;filters&quot;, Ember.A());&#xA;  }&#xA;});&#xA;```" ilk="class" name="Mixin">
          <scope attributes="public" ilk="function" name="create" signature="create(arguments)">
            <variable ilk="argument" name="arguments" />
          </scope>
          <scope attributes="private" ilk="function" name="reopen" signature="reopen(arguments)">
            <variable ilk="argument" name="arguments" />
          </scope>
          <scope attributes="private" ilk="function" name="apply" signature="apply(obj)">
            <variable ilk="argument" name="obj" />
          </scope>
          <scope attributes="private" ilk="function" name="detect" returns="Boolean" signature="detect(obj) =&gt; Boolean">
            <variable ilk="argument" name="obj" />
          </scope>
        </scope>
        <scope doc="This mixin defines the API for modifying array-like objects. These methods&#xA;can be applied only to a collection that keeps its items in an ordered set.&#xA;It builds upon the Array mixin and adds methods to modify the array.&#xA;One concrete implementations of this class include ArrayProxy.&#xA;  &#xA;It is important to use the methods in this class to modify arrays so that&#xA;changes are observable. This allows the binding system in Ember to function&#xA;correctly.&#xA;  &#xA;  &#xA;Note that an Array can change even if it does not implement this mixin.&#xA;For example, one might implement a SparseArray that cannot be directly&#xA;modified, but if its underlying enumerable changes, it will change also." ilk="class" name="MutableArray">
          <scope attributes="public" doc="__Required.__ You must implement this method to apply this mixin.&#xA; This is one of the primitives you must implement to support `Ember.Array`.&#xA;You should replace amt objects started at idx with the objects in the&#xA;passed array. You should also call `this.enumerableContentDidChange()`" ilk="function" name="replace" signature="replace(idx,amt,objects)">
            <variable citdl="Number" doc="Starting index in the array to replace. If&#xA;  idx &gt;= length, then append to the end of the array." ilk="argument" name="idx" />
            <variable citdl="Number" doc="Number of elements that should be removed from&#xA;  the array, starting at *idx*." ilk="argument" name="amt" />
            <variable citdl="Array" doc="An array of zero or more objects that should be&#xA;  inserted into the array at *idx*" ilk="argument" name="objects" />
          </scope>
          <scope attributes="public" doc="Remove all elements from the array. This is useful if you&#xA;want to reuse an existing array without having to recreate it.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];&#xA; color.length();   //  3&#xA;colors.clear();   //  []&#xA;colors.length();  //  0&#xA;```" ilk="function" name="clear" returns="Ember.Array" signature="clear() =&gt; Ember.Array" />
          <scope attributes="public" doc="This will use the primitive `replace()` method to insert an object at the&#xA;specified index.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];&#xA; colors.insertAt(2, &apos;yellow&apos;);  // [&apos;red&apos;, &apos;green&apos;, &apos;yellow&apos;, &apos;blue&apos;]&#xA;colors.insertAt(5, &apos;orange&apos;);  // Error: Index out of range&#xA;```" ilk="function" name="insertAt" returns="Ember.Array" signature="insertAt(idx,object) =&gt; Ember.Array">
            <variable citdl="Number" doc="index of insert the object at." ilk="argument" name="idx" />
            <variable citdl="Object" doc="object to insert" ilk="argument" name="object" />
          </scope>
          <scope attributes="public" doc="Remove an object at the specified index using the `replace()` primitive&#xA;method. You can pass either a single index, or a start and a length.&#xA; If you pass a start and length that is beyond the&#xA;length this method will throw an `OUT_OF_RANGE_EXCEPTION`.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;orange&apos;];&#xA; colors.removeAt(0);     // [&apos;green&apos;, &apos;blue&apos;, &apos;yellow&apos;, &apos;orange&apos;]&#xA;colors.removeAt(2, 2);  // [&apos;green&apos;, &apos;blue&apos;]&#xA;colors.removeAt(4, 2);  // Error: Index out of range&#xA;```" ilk="function" name="removeAt" returns="Ember.Array" signature="removeAt(start,len) =&gt; Ember.Array">
            <variable citdl="Number" doc="index, start of range" ilk="argument" name="start" />
            <variable citdl="Number" doc="length of passing range" ilk="argument" name="len" />
          </scope>
          <scope attributes="public" doc="Push the object onto the end of the array. Works just like `push()` but it&#xA;is KVO-compliant.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;];&#xA; colors.pushObject(&apos;black&apos;);     // [&apos;red&apos;, &apos;green&apos;, &apos;black&apos;]&#xA;colors.pushObject([&apos;yellow&apos;]);  // [&apos;red&apos;, &apos;green&apos;, [&apos;yellow&apos;]]&#xA;```" ilk="function" name="pushObject" signature="pushObject(obj)">
            <variable citdl="*" doc="object to push" ilk="argument" name="obj" />
          </scope>
          <scope attributes="public" doc="Add the objects in the passed numerable to the end of the array. Defers&#xA;notifying observers of the change until all objects are added.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;];&#xA; colors.pushObjects([&apos;yellow&apos;, &apos;orange&apos;]);  // [&apos;red&apos;, &apos;yellow&apos;, &apos;orange&apos;]&#xA;```" ilk="function" name="pushObjects" returns="Ember.Array" signature="pushObjects(objects) =&gt; Ember.Array">
            <variable citdl="Ember.Enumerable" doc="the objects to add" ilk="argument" name="objects" />
          </scope>
          <scope attributes="public" doc="Pop object from array or nil if none are left. Works just like `pop()` but&#xA;it is KVO-compliant.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];&#xA; colors.popObject();   // &apos;blue&apos;&#xA;console.log(colors);  // [&apos;red&apos;, &apos;green&apos;]&#xA;```" ilk="function" name="popObject" signature="popObject()" />
          <scope attributes="public" doc="Shift an object from start of array or nil if none are left. Works just&#xA;like `shift()` but it is KVO-compliant.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];&#xA; colors.shiftObject();  // &apos;red&apos;&#xA;console.log(colors);   // [&apos;green&apos;, &apos;blue&apos;]&#xA;```" ilk="function" name="shiftObject" signature="shiftObject()" />
          <scope attributes="public" doc="Unshift an object to start of array. Works just like `unshift()` but it is&#xA;KVO-compliant.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;];&#xA; colors.unshiftObject(&apos;yellow&apos;);    // [&apos;yellow&apos;, &apos;red&apos;]&#xA;colors.unshiftObject([&apos;black&apos;]);   // [[&apos;black&apos;], &apos;yellow&apos;, &apos;red&apos;]&#xA;```" ilk="function" name="unshiftObject" signature="unshiftObject(obj)">
            <variable citdl="*" doc="object to unshift" ilk="argument" name="obj" />
          </scope>
          <scope attributes="public" doc="Adds the named objects to the beginning of the array. Defers notifying&#xA;observers until all objects have been added.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;];&#xA; colors.unshiftObjects([&apos;black&apos;, &apos;white&apos;]);   // [&apos;black&apos;, &apos;white&apos;, &apos;red&apos;]&#xA;colors.unshiftObjects(&apos;yellow&apos;); // Type Error: &apos;undefined&apos; is not a function&#xA;```" ilk="function" name="unshiftObjects" returns="Ember.Array" signature="unshiftObjects(objects) =&gt; Ember.Array">
            <variable citdl="Ember.Enumerable" doc="the objects to add" ilk="argument" name="objects" />
          </scope>
          <scope attributes="public" doc="Reverse objects in the array. Works just like `reverse()` but it is&#xA;KVO-compliant." ilk="function" name="reverseObjects" returns="Ember.Array" signature="reverseObjects() =&gt; Ember.Array" />
          <scope attributes="public" doc="Replace all the receiver&apos;s content with content of the argument.&#xA;If argument is an empty array receiver will be cleared.&#xA; ```javascript&#xA;var colors = [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;];&#xA; colors.setObjects([&apos;black&apos;, &apos;white&apos;]);  // [&apos;black&apos;, &apos;white&apos;]&#xA;colors.setObjects([]);                  // []&#xA;```" ilk="function" name="setObjects" returns="Ember.Array" signature="setObjects(objects) =&gt; Ember.Array">
            <variable citdl="Ember.Array" doc="array whose content will be used for replacing&#xA;    the content of the receiver" ilk="argument" name="objects" />
          </scope>
          <scope attributes="public" doc="Remove all occurrences of an object in the array.&#xA; ```javascript&#xA;var cities = [&apos;Chicago&apos;, &apos;Berlin&apos;, &apos;Lima&apos;, &apos;Chicago&apos;];&#xA; cities.removeObject(&apos;Chicago&apos;);  // [&apos;Berlin&apos;, &apos;Lima&apos;]&#xA;cities.removeObject(&apos;Lima&apos;);     // [&apos;Berlin&apos;]&#xA;cities.removeObject(&apos;Tokyo&apos;)     // [&apos;Berlin&apos;]&#xA;```" ilk="function" name="removeObject" returns="Ember.Array" signature="removeObject(obj) =&gt; Ember.Array">
            <variable citdl="*" doc="object to remove" ilk="argument" name="obj" />
          </scope>
          <scope attributes="public" doc="Push the object onto the end of the array if it is not already&#xA;present in the array.&#xA; ```javascript&#xA;var cities = [&apos;Chicago&apos;, &apos;Berlin&apos;];&#xA; cities.addObject(&apos;Lima&apos;);    // [&apos;Chicago&apos;, &apos;Berlin&apos;, &apos;Lima&apos;]&#xA;cities.addObject(&apos;Berlin&apos;);  // [&apos;Chicago&apos;, &apos;Berlin&apos;, &apos;Lima&apos;]&#xA;```" ilk="function" name="addObject" returns="Ember.Array" signature="addObject(obj) =&gt; Ember.Array">
            <variable citdl="*" doc="object to add, if not already present" ilk="argument" name="obj" />
          </scope>
        </scope>
        <scope doc="This mixin defines the API for modifying generic enumerables. These methods&#xA;can be applied to an object regardless of whether it is ordered or&#xA;unordered.&#xA;  &#xA;Note that an Enumerable can change even if it does not implement this mixin.&#xA;For example, a MappedEnumerable cannot be directly modified but if its&#xA;underlying enumerable changes, it will change also.&#xA;  &#xA;## Adding Objects&#xA;  &#xA;To add an object to an enumerable, use the `addObject()` method. This&#xA;method will only add the object to the enumerable if the object is not&#xA;already present and is of a type supported by the enumerable.&#xA;  &#xA;```javascript&#xA;set.addObject(contact);&#xA;```&#xA;  &#xA;## Removing Objects&#xA;  &#xA;To remove an object from an enumerable, use the `removeObject()` method. This&#xA;will only remove the object if it is present in the enumerable, otherwise&#xA;this method has no effect.&#xA;  &#xA;```javascript&#xA;set.removeObject(contact);&#xA;```&#xA;  &#xA;## Implementing In Your Own Code&#xA;  &#xA;If you are implementing an object and want to support this API, just include&#xA;this mixin in your class and implement the required methods. In your unit&#xA;tests, be sure to apply the Ember.MutableEnumerableTests to your object." ilk="class" name="MutableEnumerable">
          <scope attributes="public" doc="__Required.__ You must implement this method to apply this mixin.&#xA; Attempts to add the passed object to the receiver if the object is not&#xA;already present in the collection. If the object is present, this method&#xA;has no effect.&#xA; If the passed object is of a type not supported by the receiver,&#xA;then this method should raise an exception." ilk="function" name="addObject" returns="Object" signature="addObject(object) =&gt; Object">
            <variable citdl="Object" doc="The object to add to the enumerable." ilk="argument" name="object" />
          </scope>
          <scope attributes="public" doc="Adds each object in the passed enumerable to the receiver." ilk="function" name="addObjects" returns="Object" signature="addObjects(objects) =&gt; Object">
            <variable citdl="Ember.Enumerable" doc="the objects to add." ilk="argument" name="objects" />
          </scope>
          <scope attributes="public" doc="__Required.__ You must implement this method to apply this mixin.&#xA; Attempts to remove the passed object from the receiver collection if the&#xA;object is present in the collection. If the object is not present,&#xA;this method has no effect.&#xA; If the passed object is of a type not supported by the receiver,&#xA;then this method should raise an exception." ilk="function" name="removeObject" returns="Object" signature="removeObject(object) =&gt; Object">
            <variable citdl="Object" doc="The object to remove from the enumerable." ilk="argument" name="object" />
          </scope>
          <scope attributes="public" doc="Removes each object in the passed enumerable from the receiver." ilk="function" name="removeObjects" returns="Object" signature="removeObjects(objects) =&gt; Object">
            <variable citdl="Ember.Enumerable" doc="the objects to remove" ilk="argument" name="objects" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="A Namespace is an object usually used to contain other objects or methods&#xA;such as an application or framework. Create a namespace anytime you want&#xA;to define one of these new containers.&#xA;  &#xA;# Example Usage&#xA;  &#xA;```javascript&#xA;MyFramework = Ember.Namespace.create({&#xA;  VERSION: &apos;1.0.0&apos;&#xA;});&#xA;```" ilk="class" name="Namespace" />
        <scope doc="The NativeArray mixin contains the properties needed to make the native&#xA;Array support Ember.MutableArray and all of its dependent APIs. Unless you&#xA;have `Ember.EXTEND_PROTOTYPES` or `Ember.EXTEND_PROTOTYPES.Array` set to&#xA;false, this will be applied automatically. Otherwise you can apply the mixin&#xA;at anytime by calling `Ember.NativeArray.activate`." ilk="class" name="NativeArray" />
        <scope classrefs="Ember.Object" doc="Ember.NoneLocation does not interact with the browser. It is useful for&#xA;testing, or when you need to manage state with your Router, but temporarily&#xA;don&apos;t want it to muck with the URL (for example when you embed your&#xA;application in a larger page)." ilk="class" name="NoneLocation">
          <scope attributes="private" doc="Returns the current path." ilk="function" name="getURL" returns="String" signature="getURL() =&gt; String" />
          <scope attributes="private" doc="Set the path and remembers what was set. Using this method&#xA;to change the path will not invoke the `updateURL` callback." ilk="function" name="setURL" signature="setURL(path)">
            <variable citdl="String" ilk="argument" name="path" />
          </scope>
          <scope attributes="private" doc="Register a callback to be invoked when the path changes. These&#xA;callbacks will execute when the user presses the back or forward&#xA;button, but not after `setURL` is invoked." ilk="function" name="onUpdateURL" signature="onUpdateURL(callback)">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="private" doc="Sets the path and calls the `updateURL` callback." ilk="function" name="handleURL" signature="handleURL(callback)">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="private" doc="Given a URL, formats it to be placed into the page as part&#xA;of an element&apos;s `href` attribute.&#xA; This is used, for example, when using the {{action}} helper&#xA;to generate a URL based on an event." ilk="function" name="formatURL" returns="String" signature="formatURL(url) =&gt; String">
            <variable citdl="String" ilk="argument" name="url" />
          </scope>
        </scope>
        <scope classrefs="Ember.CoreObject" doc="`Ember.Object` is the main base class for all Ember objects. It is a subclass&#xA;of `Ember.CoreObject` with the `Ember.Observable` mixin applied. For details,&#xA;see the documentation for each of these." ilk="class" name="Object" />
        <scope classrefs="Ember._ProxyMixin" doc="`Ember.ObjectProxy` forwards all properties not defined by the proxy itself&#xA;to a proxied `content` object.&#xA;  &#xA;```javascript&#xA;object = Ember.Object.create({&#xA;  name: &apos;Foo&apos;&#xA;});&#xA;  &#xA;proxy = Ember.ObjectProxy.create({&#xA;  content: object&#xA;});&#xA;  &#xA;// Access and change existing properties&#xA;proxy.get(&apos;name&apos;)          // &apos;Foo&apos;&#xA;proxy.set(&apos;name&apos;, &apos;Bar&apos;);&#xA;object.get(&apos;name&apos;)         // &apos;Bar&apos;&#xA;  &#xA;// Create new &apos;description&apos; property on `object`&#xA;proxy.set(&apos;description&apos;, &apos;Foo is a whizboo baz&apos;);&#xA;object.get(&apos;description&apos;)  // &apos;Foo is a whizboo baz&apos;&#xA;```&#xA;  &#xA;While `content` is unset, setting a property to be delegated will throw an&#xA;Error.&#xA;  &#xA;```javascript&#xA;proxy = Ember.ObjectProxy.create({&#xA;  content: null,&#xA;  flag: null&#xA;});&#xA;proxy.set(&apos;flag&apos;, true);&#xA;proxy.get(&apos;flag&apos;);         // true&#xA;proxy.get(&apos;foo&apos;);          // undefined&#xA;proxy.set(&apos;foo&apos;, &apos;data&apos;);  // throws Error&#xA;```&#xA;  &#xA;Delegated properties can be bound to and will change when content is updated.&#xA;  &#xA;Computed properties on the proxy itself can depend on delegated properties.&#xA;  &#xA;```javascript&#xA;ProxyWithComputedProperty = Ember.ObjectProxy.extend({&#xA;  fullName: function() {&#xA;    var firstName = this.get(&apos;firstName&apos;),&#xA;        lastName = this.get(&apos;lastName&apos;);&#xA;    if (firstName &amp;&amp; lastName) {&#xA;      return firstName + &apos; &apos; + lastName;&#xA;    }&#xA;    return firstName || lastName;&#xA;  }.property(&apos;firstName&apos;, &apos;lastName&apos;)&#xA;});&#xA;  &#xA;proxy = ProxyWithComputedProperty.create();&#xA;  &#xA;proxy.get(&apos;fullName&apos;);  // undefined&#xA;proxy.set(&apos;content&apos;, {&#xA;  firstName: &apos;Tom&apos;, lastName: &apos;Dale&apos;&#xA;}); // triggers property change for fullName on proxy&#xA;  &#xA;proxy.get(&apos;fullName&apos;);  // &apos;Tom Dale&apos;&#xA;```" ilk="class" name="ObjectProxy" />
        <scope doc="## Overview&#xA;  &#xA;This mixin provides properties and property observing functionality, core&#xA;features of the Ember object model.&#xA;  &#xA;Properties and observers allow one object to observe changes to a&#xA;property on another object. This is one of the fundamental ways that&#xA;models, controllers and views communicate with each other in an Ember&#xA;application.&#xA;  &#xA;Any object that has this mixin applied can be used in observer&#xA;operations. That includes `Ember.Object` and most objects you will&#xA;interact with as you write your Ember application.&#xA;  &#xA;Note that you will not generally apply this mixin to classes yourself,&#xA;but you will use the features provided by this module frequently, so it&#xA;is important to understand how to use it.&#xA;  &#xA;## Using `get()` and `set()`&#xA;  &#xA;Because of Ember&apos;s support for bindings and observers, you will always&#xA;access properties using the get method, and set properties using the&#xA;set method. This allows the observing objects to be notified and&#xA;computed properties to be handled properly.&#xA;  &#xA;More documentation about `get` and `set` are below.&#xA;  &#xA;## Observing Property Changes&#xA;  &#xA;You typically observe property changes simply by using the `Ember.observer`&#xA;function in classes that you write.&#xA;  &#xA;For example:&#xA;  &#xA;```javascript&#xA;Ember.Object.extend({&#xA;  valueObserver: Ember.observer(&apos;value&apos;, function(sender, key, value, rev) {&#xA;    // Executes whenever the &quot;value&quot; property changes&#xA;    // See the addObserver method for more information about the callback arguments&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Although this is the most common way to add an observer, this capability&#xA;is actually built into the `Ember.Object` class on top of two methods&#xA;defined in this mixin: `addObserver` and `removeObserver`. You can use&#xA;these two methods to add and remove observers yourself if you need to&#xA;do so at runtime.&#xA;  &#xA;To add an observer for a property, call:&#xA;  &#xA;```javascript&#xA;object.addObserver(&apos;propertyKey&apos;, targetObject, targetAction)&#xA;```&#xA;  &#xA;This will call the `targetAction` method on the `targetObject` whenever&#xA;the value of the `propertyKey` changes.&#xA;  &#xA;Note that if `propertyKey` is a computed property, the observer will be&#xA;called when any of the property dependencies are changed, even if the&#xA;resulting value of the computed property is unchanged. This is necessary&#xA;because computed properties are not computed until `get` is called." ilk="class" name="Observable">
          <scope attributes="public" doc="Retrieves the value of a property from the object.&#xA; This method is usually similar to using `object[keyName]` or `object.keyName`,&#xA;however it supports both computed properties and the unknownProperty&#xA;handler.&#xA; Because `get` unifies the syntax for accessing all these kinds&#xA;of properties, it can make many refactorings easier, such as replacing a&#xA;simple property with a computed property, or vice versa.&#xA; ### Computed Properties&#xA; Computed properties are methods defined with the `property` modifier&#xA;declared at the end, such as:&#xA; ```javascript&#xA;fullName: function() {&#xA;  return this.get(&apos;firstName&apos;) + &apos; &apos; + this.get(&apos;lastName&apos;);&#xA;}.property(&apos;firstName&apos;, &apos;lastName&apos;)&#xA;```&#xA; When you call `get` on a computed property, the function will be&#xA;called and the return value will be returned instead of the function&#xA;itself.&#xA; ### Unknown Properties&#xA; Likewise, if you try to call `get` on a property whose value is&#xA;`undefined`, the `unknownProperty()` method will be called on the object.&#xA;If this method returns any value other than `undefined`, it will be returned&#xA;instead. This allows you to implement &quot;virtual&quot; properties that are&#xA;not defined upfront." ilk="function" name="get" returns="Object" signature="get(keyName) =&gt; Object">
            <variable citdl="String" doc="The property to retrieve" ilk="argument" name="keyName" />
          </scope>
          <scope attributes="public" doc="To get the values of multiple properties at once, call `getProperties`&#xA;with a list of strings or an array:&#xA; ```javascript&#xA;record.getProperties(&apos;firstName&apos;, &apos;lastName&apos;, &apos;zipCode&apos;);&#xA;// { firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, zipCode: &apos;10011&apos; }&#xA;```&#xA; is equivalent to:&#xA; ```javascript&#xA;record.getProperties([&apos;firstName&apos;, &apos;lastName&apos;, &apos;zipCode&apos;]);&#xA;// { firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, zipCode: &apos;10011&apos; }&#xA;```" ilk="function" name="getProperties" returns="Object" signature="getProperties(list) =&gt; Object">
            <variable citdl="String...|Array" doc="of keys to get" ilk="argument" name="list" />
          </scope>
          <scope attributes="public" doc="Sets the provided key or path to the value.&#xA; This method is generally very similar to calling `object[key] = value` or&#xA;`object.key = value`, except that it provides support for computed&#xA;properties, the `setUnknownProperty()` method and property observers.&#xA; ### Computed Properties&#xA; If you try to set a value on a key that has a computed property handler&#xA;defined (see the `get()` method for an example), then `set()` will call&#xA;that method, passing both the value and key instead of simply changing&#xA;the value itself. This is useful for those times when you need to&#xA;implement a property that is composed of one or more member&#xA;properties.&#xA; ### Unknown Properties&#xA; If you try to set a value on a key that is undefined in the target&#xA;object, then the `setUnknownProperty()` handler will be called instead. This&#xA;gives you an opportunity to implement complex &quot;virtual&quot; properties that&#xA;are not predefined on the object. If `setUnknownProperty()` returns&#xA;undefined, then `set()` will simply set the value on the object.&#xA; ### Property Observers&#xA; In addition to changing the property, `set()` will also register a property&#xA;change with the object. Unless you have placed this call inside of a&#xA;`beginPropertyChanges()` and `endPropertyChanges(),` any &quot;local&quot; observers&#xA;(i.e. observer methods declared on the same object), will be called&#xA;immediately. Any &quot;remote&quot; observers (i.e. observer methods declared on&#xA;another object) will be placed in a queue and called at a later time in a&#xA;coalesced manner." ilk="function" name="set" returns="Object" signature="set(keyName,value) =&gt; Object">
            <variable citdl="String" doc="The property to set" ilk="argument" name="keyName" />
            <variable citdl="Object" doc="The value to set or `null`." ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="Sets a list of properties at once. These properties are set inside&#xA;a single `beginPropertyChanges` and `endPropertyChanges` batch, so&#xA;observers will be buffered.&#xA; ```javascript&#xA;record.setProperties({ firstName: &apos;Charles&apos;, lastName: &apos;Jolley&apos; });&#xA;```" ilk="function" name="setProperties" returns="Object" signature="setProperties(hash) =&gt; Object">
            <variable citdl="Object" doc="the hash of keys and values to set" ilk="argument" name="hash" />
          </scope>
          <scope attributes="private" doc="Begins a grouping of property changes.&#xA; You can use this method to group property changes so that notifications&#xA;will not be sent until the changes are finished. If you plan to make a&#xA;large number of changes to an object at one time, you should call this&#xA;method at the beginning of the changes to begin deferring change&#xA;notifications. When you are done making changes, call&#xA;`endPropertyChanges()` to deliver the deferred change notifications and end&#xA;deferring." ilk="function" name="beginPropertyChanges" returns="Ember.Observable" signature="beginPropertyChanges() =&gt; Ember.Observable" />
          <scope attributes="private" doc="Ends a grouping of property changes.&#xA; You can use this method to group property changes so that notifications&#xA;will not be sent until the changes are finished. If you plan to make a&#xA;large number of changes to an object at one time, you should call&#xA;`beginPropertyChanges()` at the beginning of the changes to defer change&#xA;notifications. When you are done making changes, call this method to&#xA;deliver the deferred change notifications and end deferring." ilk="function" name="endPropertyChanges" returns="Ember.Observable" signature="endPropertyChanges() =&gt; Ember.Observable" />
          <scope attributes="private" doc="Notify the observer system that a property is about to change.&#xA; Sometimes you need to change a value directly or indirectly without&#xA;actually calling `get()` or `set()` on it. In this case, you can use this&#xA;method and `propertyDidChange()` instead. Calling these two methods&#xA;together will notify all observers that the property has potentially&#xA;changed value.&#xA; Note that you must always call `propertyWillChange` and `propertyDidChange`&#xA;as a pair. If you do not, it may get the property change groups out of&#xA;order and cause notifications to be delivered more often than you would&#xA;like." ilk="function" name="propertyWillChange" returns="Ember.Observable" signature="propertyWillChange(keyName) =&gt; Ember.Observable">
            <variable citdl="String" doc="The property key that is about to change." ilk="argument" name="keyName" />
          </scope>
          <scope attributes="private" doc="Notify the observer system that a property has just changed.&#xA; Sometimes you need to change a value directly or indirectly without&#xA;actually calling `get()` or `set()` on it. In this case, you can use this&#xA;method and `propertyWillChange()` instead. Calling these two methods&#xA;together will notify all observers that the property has potentially&#xA;changed value.&#xA; Note that you must always call `propertyWillChange` and `propertyDidChange`&#xA;as a pair. If you do not, it may get the property change groups out of&#xA;order and cause notifications to be delivered more often than you would&#xA;like." ilk="function" name="propertyDidChange" returns="Ember.Observable" signature="propertyDidChange(keyName) =&gt; Ember.Observable">
            <variable citdl="String" doc="The property key that has just changed." ilk="argument" name="keyName" />
          </scope>
          <scope attributes="public" doc="Convenience method to call `propertyWillChange` and `propertyDidChange` in&#xA;succession." ilk="function" name="notifyPropertyChange" returns="Ember.Observable" signature="notifyPropertyChange(keyName) =&gt; Ember.Observable">
            <variable citdl="String" doc="The property key to be notified about." ilk="argument" name="keyName" />
          </scope>
          <scope attributes="public" doc="Adds an observer on a property.&#xA; This is the core method used to register an observer for a property.&#xA; Once you call this method, any time the key&apos;s value is set, your observer&#xA;will be notified. Note that the observers are triggered any time the&#xA;value is set, regardless of whether it has actually changed. Your&#xA;observer should be prepared to handle that.&#xA; You can also pass an optional context parameter to this method. The&#xA;context will be passed to your observer method whenever it is triggered.&#xA;Note that if you add the same target/method pair on a key multiple times&#xA;with different context parameters, your observer will only be called once&#xA;with the last context you passed.&#xA; ### Observer Methods&#xA; Observer methods you pass should generally have the following signature if&#xA;you do not pass a `context` parameter:&#xA; ```javascript&#xA;fooDidChange: function(sender, key, value, rev) { };&#xA;```&#xA; The sender is the object that changed. The key is the property that&#xA;changes. The value property is currently reserved and unused. The rev&#xA;is the last property revision of the object when it changed, which you can&#xA;use to detect if the key value has really changed or not.&#xA; If you pass a `context` parameter, the context will be passed before the&#xA;revision like so:&#xA; ```javascript&#xA;fooDidChange: function(sender, key, value, context, rev) { };&#xA;```&#xA; Usually you will not need the value, context or revision parameters at&#xA;the end. In this case, it is common to write observer methods that take&#xA;only a sender and key value as parameters or, if you aren&apos;t interested in&#xA;any of these values, to write an observer that has no parameters at all." ilk="function" name="addObserver" signature="addObserver(key,target,method)">
            <variable citdl="String" doc="The key to observer" ilk="argument" name="key" />
            <variable citdl="Object" doc="The target object to invoke" ilk="argument" name="target" />
            <variable citdl="String|Function" doc="The method to invoke." ilk="argument" name="method" />
          </scope>
          <scope attributes="public" doc="Remove an observer you have previously registered on this object. Pass&#xA;the same key, target, and method you passed to `addObserver()` and your&#xA;target will no longer receive notifications." ilk="function" name="removeObserver" signature="removeObserver(key,target,method)">
            <variable citdl="String" doc="The key to observer" ilk="argument" name="key" />
            <variable citdl="Object" doc="The target object to invoke" ilk="argument" name="target" />
            <variable citdl="String|Function" doc="The method to invoke." ilk="argument" name="method" />
          </scope>
          <scope attributes="private" doc="Returns `true` if the object currently has observers registered for a&#xA;particular key. You can use this method to potentially defer performing&#xA;an expensive action until someone begins observing a particular property&#xA;on the object." ilk="function" name="hasObserverFor" returns="Boolean" signature="hasObserverFor(key) =&gt; Boolean">
            <variable citdl="String" doc="Key to check" ilk="argument" name="key" />
          </scope>
          <scope attributes="public" doc="Retrieves the value of a property, or a default value in the case that the&#xA;property returns `undefined`.&#xA; ```javascript&#xA;person.getWithDefault(&apos;lastName&apos;, &apos;Doe&apos;);&#xA;```" ilk="function" name="getWithDefault" returns="Object" signature="getWithDefault(keyName,defaultValue) =&gt; Object">
            <variable citdl="String" doc="The name of the property to retrieve" ilk="argument" name="keyName" />
            <variable citdl="Object" doc="The value to return if the property value is undefined" ilk="argument" name="defaultValue" />
          </scope>
          <scope attributes="public" doc="Set the value of a property to the current value plus some amount.&#xA; ```javascript&#xA;person.incrementProperty(&apos;age&apos;);&#xA;team.incrementProperty(&apos;score&apos;, 2);&#xA;```" ilk="function" name="incrementProperty" returns="Number" signature="incrementProperty(keyName,increment) =&gt; Number">
            <variable citdl="String" doc="The name of the property to increment" ilk="argument" name="keyName" />
            <variable citdl="Number" doc="The amount to increment by. Defaults to 1" ilk="argument" name="increment" />
          </scope>
          <scope attributes="public" doc="Set the value of a property to the current value minus some amount.&#xA; ```javascript&#xA;player.decrementProperty(&apos;lives&apos;);&#xA;orc.decrementProperty(&apos;health&apos;, 5);&#xA;```" ilk="function" name="decrementProperty" returns="Number" signature="decrementProperty(keyName,decrement) =&gt; Number">
            <variable citdl="String" doc="The name of the property to decrement" ilk="argument" name="keyName" />
            <variable citdl="Number" doc="The amount to decrement by. Defaults to 1" ilk="argument" name="decrement" />
          </scope>
          <scope attributes="public" doc="Set the value of a boolean property to the opposite of its&#xA;current value.&#xA; ```javascript&#xA;starship.toggleProperty(&apos;warpDriveEngaged&apos;);&#xA;```" ilk="function" name="toggleProperty" returns="Boolean" signature="toggleProperty(keyName) =&gt; Boolean">
            <variable citdl="String" doc="The name of the property to toggle" ilk="argument" name="keyName" />
          </scope>
          <scope attributes="public" doc="Returns the cached value of a computed property, if it exists.&#xA;This allows you to inspect the value of a computed property&#xA;without accidentally invoking it if it is intended to be&#xA;generated lazily." ilk="function" name="cacheFor" returns="Object" signature="cacheFor(keyName) =&gt; Object">
            <variable citdl="String" ilk="argument" name="keyName" />
          </scope>
        </scope>
        <scope doc="This class is used internally by Ember and Ember Data.&#xA;Please do not use it at this time. We plan to clean it up&#xA;and add many tests soon." ilk="class" name="OrderedSet">
          <scope attributes="private" ilk="function" name="create" returns="Ember.OrderedSet" signature="create() =&gt; Ember.OrderedSet" />
          <scope attributes="private" ilk="function" name="clear" signature="clear()" />
          <scope attributes="private" ilk="function" name="add" returns="Ember.OrderedSet" signature="add(obj,guid) =&gt; Ember.OrderedSet">
            <variable ilk="argument" name="obj" />
            <variable doc="(optional, and for internal use)" ilk="argument" name="guid" />
          </scope>
          <scope attributes="private" ilk="function" name="delete" returns="Boolean" signature="delete(obj,_guid) =&gt; Boolean">
            <variable ilk="argument" name="obj" />
            <variable doc="(optional and for internal use only)" ilk="argument" name="_guid" />
          </scope>
          <scope attributes="private" ilk="function" name="isEmpty" returns="Boolean" signature="isEmpty() =&gt; Boolean" />
          <scope attributes="private" ilk="function" name="has" returns="Boolean" signature="has(obj) =&gt; Boolean">
            <variable ilk="argument" name="obj" />
          </scope>
          <scope attributes="private" ilk="function" name="forEach" signature="forEach(fn,self)">
            <variable citdl="Function" ilk="argument" name="fn" />
            <variable ilk="argument" name="self" />
          </scope>
          <scope attributes="private" ilk="function" name="toArray" returns="Array" signature="toArray() =&gt; Array" />
          <scope attributes="private" ilk="function" name="copy" returns="Ember.OrderedSet" signature="copy() =&gt; Ember.OrderedSet" />
        </scope>
        <scope doc="A low level mixin making ObjectProxy promise-aware.&#xA;  &#xA;```javascript&#xA;var ObjectPromiseProxy = Ember.ObjectProxy.extend(Ember.PromiseProxyMixin);&#xA;  &#xA;var proxy = ObjectPromiseProxy.create({&#xA;  promise: $.getJSON(&apos;/some/remote/data.json&apos;)&#xA;});&#xA;  &#xA;proxy.then(function(json){&#xA;   // the json&#xA;}, function(reason) {&#xA;   // the reason why you have no json&#xA;});&#xA;```&#xA;  &#xA;the proxy has bindable attributes which&#xA;track the promises life cycle&#xA;  &#xA;```javascript&#xA;proxy.get(&apos;isPending&apos;)   //=&gt; true&#xA;proxy.get(&apos;isSettled&apos;)  //=&gt; false&#xA;proxy.get(&apos;isRejected&apos;)  //=&gt; false&#xA;proxy.get(&apos;isFulfilled&apos;) //=&gt; false&#xA;```&#xA;  &#xA;When the $.getJSON completes, and the promise is fulfilled&#xA;with json, the life cycle attributes will update accordingly.&#xA;  &#xA;```javascript&#xA;proxy.get(&apos;isPending&apos;)   //=&gt; false&#xA;proxy.get(&apos;isSettled&apos;)   //=&gt; true&#xA;proxy.get(&apos;isRejected&apos;)  //=&gt; false&#xA;proxy.get(&apos;isFulfilled&apos;) //=&gt; true&#xA;```&#xA;  &#xA;As the proxy is an ObjectProxy, and the json now its content,&#xA;all the json properties will be available directly from the proxy.&#xA;  &#xA;```javascript&#xA;// Assuming the following json:&#xA;{&#xA;  firstName: &apos;Stefan&apos;,&#xA;  lastName: &apos;Penner&apos;&#xA;}&#xA;  &#xA;// both properties will accessible on the proxy&#xA;proxy.get(&apos;firstName&apos;) //=&gt; &apos;Stefan&apos;&#xA;proxy.get(&apos;lastName&apos;)  //=&gt; &apos;Penner&apos;&#xA;```" ilk="class" name="PromiseProxyMixin">
          <variable attributes="property public" doc="If the proxied promise is rejected this will contain the reason&#xA;provided." name="PromiseProxyMixin" />
          <variable attributes="property public" doc="Once the proxied promise has settled this will become `false`." name="PromiseProxyMixin" />
          <variable attributes="property public" doc="Once the proxied promise has settled this will become `true`." name="PromiseProxyMixin" />
          <variable attributes="property public" doc="Will become `true` if the proxied promise is rejected." name="PromiseProxyMixin" />
          <variable attributes="property public" doc="Will become `true` if the proxied promise is fulfilled." name="PromiseProxyMixin" />
          <variable attributes="property public" doc="The promise whose fulfillment value is being proxied by this object.&#xA; This property must be specified upon creation, and should not be&#xA;changed once created.&#xA; Example:&#xA; ```javascript&#xA;Ember.ObjectProxy.extend(Ember.PromiseProxyMixin).create({&#xA;  promise: &lt;thenable&gt;&#xA;});&#xA;```" name="PromiseProxyMixin" />
          <scope attributes="public" doc="An alias to the proxied promise&apos;s `then`.&#xA; See RSVP.Promise.then." ilk="function" name="then" returns="RSVP.Promise" signature="then(callback) =&gt; RSVP.Promise">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="public" doc="An alias to the proxied promise&apos;s `catch`.&#xA; See RSVP.Promise.catch." ilk="function" name="catch" returns="RSVP.Promise" signature="catch(callback) =&gt; RSVP.Promise">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="public" doc="An alias to the proxied promise&apos;s `finally`.&#xA; See RSVP.Promise.finally." ilk="function" name="finally" returns="RSVP.Promise" signature="finally(callback) =&gt; RSVP.Promise">
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
        </scope>
        <scope doc="`Ember.ProxyMixin` forwards all properties not defined by the proxy itself&#xA;to a proxied `content` object.  See Ember.ObjectProxy for more details." ilk="class" name="ProxyMixin">
          <variable attributes="property private" citdl="Ember.Object" doc="The object whose properties will be forwarded." name="ProxyMixin" />
        </scope>
        <scope ilk="class" name="RSVP">
          <scope ilk="class" name="EventTarget">
            <scope attributes="private" doc="`RSVP.EventTarget.mixin` extends an object with EventTarget methods. For&#xA;Example:&#xA; ```javascript&#xA;var object = {};&#xA; RSVP.EventTarget.mixin(object);&#xA; object.on(&apos;finished&apos;, function(event) {&#xA;  // handle event&#xA;});&#xA; object.trigger(&apos;finished&apos;, { detail: value });&#xA;```&#xA; `EventTarget.mixin` also works with prototypes:&#xA; ```javascript&#xA;var Person = function() {};&#xA;RSVP.EventTarget.mixin(Person.prototype);&#xA; var yehuda = new Person();&#xA;var tom = new Person();&#xA; yehuda.on(&apos;poke&apos;, function(event) {&#xA;  console.log(&apos;Yehuda says OW&apos;);&#xA;});&#xA; tom.on(&apos;poke&apos;, function(event) {&#xA;  console.log(&apos;Tom says OW&apos;);&#xA;});&#xA; yehuda.trigger(&apos;poke&apos;);&#xA;tom.trigger(&apos;poke&apos;);&#xA;```" ilk="function" name="mixin" signature="mixin(object)">
              <variable citdl="Object" doc="object to extend with EventTarget methods" ilk="argument" name="object" />
            </scope>
          </scope>
          <scope doc="Promise objects represent the eventual result of an asynchronous operation. The&#xA;primary way of interacting with a promise is through its `then` method, which&#xA;registers callbacks to receive either a promise&#8217;s eventual value or the reason&#xA;why the promise cannot be fulfilled.&#xA;  &#xA;Terminology&#xA;-----------&#xA;  &#xA;- `promise` is an object or function with a `then` method whose behavior conforms to this specification.&#xA;- `thenable` is an object or function that defines a `then` method.&#xA;- `value` is any legal JavaScript value (including undefined, a thenable, or a promise).&#xA;- `exception` is a value that is thrown using the throw statement.&#xA;- `reason` is a value that indicates why a promise was rejected.&#xA;- `settled` the final resting state of a promise, fulfilled or rejected.&#xA;  &#xA;A promise can be in one of three states: pending, fulfilled, or rejected.&#xA;  &#xA;Promises that are fulfilled have a fulfillment value and are in the fulfilled&#xA;state.  Promises that are rejected have a rejection reason and are in the&#xA;rejected state.  A fulfillment value is never a thenable.&#xA;  &#xA;Promises can also be said to *resolve* a value.  If this value is also a&#xA;promise, then the original promise's settled state will match the value's&#xA;settled state.  So a promise that *resolves* a promise that rejects will&#xA;itself reject, and a promise that *resolves* a promise that fulfills will&#xA;itself fulfill.&#xA;  &#xA;  &#xA;Basic Usage:&#xA;------------&#xA;  &#xA;```js&#xA;var promise = new Promise(function(resolve, reject) {&#xA;  // on success&#xA;  resolve(value);&#xA;  &#xA;  // on failure&#xA;  reject(reason);&#xA;});&#xA;  &#xA;promise.then(function(value) {&#xA;  // on fulfillment&#xA;}, function(reason) {&#xA;  // on rejection&#xA;});&#xA;```&#xA;  &#xA;Advanced Usage:&#xA;---------------&#xA;  &#xA;Promises shine when abstracting away asynchronous interactions such as&#xA;`XMLHttpRequest`s.&#xA;  &#xA;```js&#xA;function getJSON(url) {&#xA;  return new Promise(function(resolve, reject){&#xA;    var xhr = new XMLHttpRequest();&#xA;  &#xA;    xhr.open('GET', url);&#xA;    xhr.onreadystatechange = handler;&#xA;    xhr.responseType = 'json';&#xA;    xhr.setRequestHeader('Accept', 'application/json');&#xA;    xhr.send();&#xA;  &#xA;    function handler() {&#xA;      if (this.readyState === this.DONE) {&#xA;        if (this.status === 200) {&#xA;          resolve(this.response);&#xA;        } else {&#xA;          reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));&#xA;        }&#xA;      }&#xA;    };&#xA;  });&#xA;}&#xA;  &#xA;getJSON('/posts.json').then(function(json) {&#xA;  // on fulfillment&#xA;}, function(reason) {&#xA;  // on rejection&#xA;});&#xA;```&#xA;  &#xA;Unlike callbacks, promises are great composable primitives.&#xA;  &#xA;```js&#xA;Promise.all([&#xA;  getJSON('/posts'),&#xA;  getJSON('/comments')&#xA;]).then(function(values){&#xA;  values[0] // =&gt; postsJSON&#xA;  values[1] // =&gt; commentsJSON&#xA;  &#xA;  return values;&#xA;});&#xA;```" ilk="class" name="Promise">
            <scope doc="The primary way of interacting with a promise is through its `then` method,&#xA;which registers callbacks to receive either a promise&apos;s eventual value or the&#xA;reason why the promise cannot be fulfilled.&#xA;    &#xA;```js&#xA;findUser().then(function(user){&#xA;  // user is available&#xA;}, function(reason){&#xA;  // user is unavailable, and you are given the reason why&#xA;});&#xA;```&#xA;    &#xA;Chaining&#xA;--------&#xA;    &#xA;The return value of `then` is itself a promise.  This second, &apos;downstream&apos;&#xA;promise is resolved with the return value of the first promise&apos;s fulfillment&#xA;or rejection handler, or rejected if the handler throws an exception.&#xA;    &#xA;```js&#xA;findUser().then(function (user) {&#xA;  return user.name;&#xA;}, function (reason) {&#xA;  return &apos;default name&apos;;&#xA;}).then(function (userName) {&#xA;  // If `findUser` fulfilled, `userName` will be the user&apos;s name, otherwise it&#xA;  // will be `&apos;default name&apos;`&#xA;});&#xA;    &#xA;findUser().then(function (user) {&#xA;  throw new Error(&apos;Found user, but still unhappy&apos;);&#xA;}, function (reason) {&#xA;  throw new Error(&apos;`findUser` rejected and we&apos;re unhappy&apos;);&#xA;}).then(function (value) {&#xA;  // never reached&#xA;}, function (reason) {&#xA;  // if `findUser` fulfilled, `reason` will be &apos;Found user, but still unhappy&apos;.&#xA;  // If `findUser` rejected, `reason` will be &apos;`findUser` rejected and we&apos;re unhappy&apos;.&#xA;});&#xA;```&#xA;If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.&#xA;    &#xA;```js&#xA;findUser().then(function (user) {&#xA;  throw new PedagogicalException(&apos;Upstream error&apos;);&#xA;}).then(function (value) {&#xA;  // never reached&#xA;}).then(function (value) {&#xA;  // never reached&#xA;}, function (reason) {&#xA;  // The `PedgagocialException` is propagated all the way down to here&#xA;});&#xA;```&#xA;    &#xA;Assimilation&#xA;------------&#xA;    &#xA;Sometimes the value you want to propagate to a downstream promise can only be&#xA;retrieved asynchronously. This can be achieved by returning a promise in the&#xA;fulfillment or rejection handler. The downstream promise will then be pending&#xA;until the returned promise is settled. This is called *assimilation*.&#xA;    &#xA;```js&#xA;findUser().then(function (user) {&#xA;  return findCommentsByAuthor(user);&#xA;}).then(function (comments) {&#xA;  // The user&apos;s comments are now available&#xA;});&#xA;```&#xA;    &#xA;If the assimliated promise rejects, then the downstream promise will also reject.&#xA;    &#xA;```js&#xA;findUser().then(function (user) {&#xA;  return findCommentsByAuthor(user);&#xA;}).then(function (comments) {&#xA;  // If `findCommentsByAuthor` fulfills, we&apos;ll have the value here&#xA;}, function (reason) {&#xA;  // If `findCommentsByAuthor` rejects, we&apos;ll have the reason here&#xA;});&#xA;```&#xA;    &#xA;Simple Example&#xA;--------------&#xA;    &#xA;Synchronous Example&#xA;    &#xA;```javascript&#xA;var result;&#xA;    &#xA;try {&#xA;  result = findResult();&#xA;  // success&#xA;} catch(reason) {&#xA;  // failure&#xA;}&#xA;```&#xA;    &#xA;Errback Example&#xA;    &#xA;```js&#xA;findResult(function(result, err){&#xA;  if (err) {&#xA;    // failure&#xA;  } else {&#xA;    // success&#xA;  }&#xA;});&#xA;```&#xA;    &#xA;Promise Example;&#xA;    &#xA;```javascript&#xA;findResult().then(function(result){&#xA;  // success&#xA;}, function(reason){&#xA;  // failure&#xA;});&#xA;```&#xA;    &#xA;Advanced Example&#xA;--------------&#xA;    &#xA;Synchronous Example&#xA;    &#xA;```javascript&#xA;var author, books;&#xA;    &#xA;try {&#xA;  author = findAuthor();&#xA;  books  = findBooksByAuthor(author);&#xA;  // success&#xA;} catch(reason) {&#xA;  // failure&#xA;}&#xA;```&#xA;    &#xA;Errback Example&#xA;    &#xA;```js&#xA;    &#xA;function foundBooks(books) {&#xA;    &#xA;}&#xA;    &#xA;function failure(reason) {&#xA;    &#xA;}&#xA;    &#xA;findAuthor(function(author, err){&#xA;  if (err) {&#xA;    failure(err);&#xA;    // failure&#xA;  } else {&#xA;    try {&#xA;      findBoooksByAuthor(author, function(books, err) {&#xA;        if (err) {&#xA;          failure(err);&#xA;        } else {&#xA;          try {&#xA;            foundBooks(books);&#xA;          } catch(reason) {&#xA;            failure(reason);&#xA;          }&#xA;        }&#xA;      });&#xA;    } catch(error) {&#xA;      failure(err);&#xA;    }&#xA;    // success&#xA;  }&#xA;});&#xA;```&#xA;    &#xA;Promise Example;&#xA;    &#xA;```javascript&#xA;findAuthor().&#xA;  then(findBooksByAuthor).&#xA;  then(function(books){&#xA;    // found books&#xA;}).catch(function(reason){&#xA;  // something went wrong&#xA;});&#xA;```" ilk="function" name="then" returns="Promise" signature="then(onFulfillment,onRejection,label) =&gt; Promise">
              <variable citdl="Function" ilk="argument" name="onFulfillment" />
              <variable citdl="Function" ilk="argument" name="onRejection" />
              <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
            </scope>
            <scope doc="`catch` is simply sugar for `then(undefined, onRejection)` which makes it the same&#xA;as the catch block of a try/catch statement.&#xA;    &#xA;```js&#xA;function findAuthor(){&#xA;  throw new Error(&apos;couldn&apos;t find that author&apos;);&#xA;}&#xA;    &#xA;// synchronous&#xA;try {&#xA;  findAuthor();&#xA;} catch(reason) {&#xA;  // something went wrong&#xA;}&#xA;    &#xA;// async with promises&#xA;findAuthor().catch(function(reason){&#xA;  // something went wrong&#xA;});&#xA;```" ilk="function" name="catch" returns="Promise" signature="catch(onRejection,label) =&gt; Promise">
              <variable citdl="Function" ilk="argument" name="onRejection" />
              <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
            </scope>
            <scope doc="`finally` will be invoked regardless of the promise&apos;s fate just as native&#xA;try/catch/finally behaves&#xA;    &#xA;Synchronous example:&#xA;    &#xA;```js&#xA;findAuthor() {&#xA;  if (Math.random() &gt; 0.5) {&#xA;    throw new Error();&#xA;  }&#xA;  return new Author();&#xA;}&#xA;    &#xA;try {&#xA;  return findAuthor(); // succeed or fail&#xA;} catch(error) {&#xA;  return findOtherAuther();&#xA;} finally {&#xA;  // always runs&#xA;  // doesn&apos;t affect the return value&#xA;}&#xA;```&#xA;    &#xA;Asynchronous example:&#xA;    &#xA;```js&#xA;findAuthor().catch(function(reason){&#xA;  return findOtherAuther();&#xA;}).finally(function(){&#xA;  // author was either found, or not&#xA;});&#xA;```" ilk="function" name="finally" returns="Promise" signature="finally(callback,label) =&gt; Promise">
              <variable citdl="Function" ilk="argument" name="callback" />
              <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
            </scope>
          </scope>
          <scope doc="`RSVP.allSettled` is similar to `RSVP.all`, but instead of implementing&#xA;a fail-fast method, it waits until all the promises have returned and&#xA;shows you all the results. This is useful if you want to handle multiple&#xA;promises&apos; failure states together as a set.&#xA;  &#xA;Returns a promise that is fulfilled when all the given promises have been&#xA;settled. The return promise is fulfilled with an array of the states of&#xA;the promises passed into the `promises` array argument.&#xA;  &#xA;Each state object will either indicate fulfillment or rejection, and&#xA;provide the corresponding value or reason. The states will take one of&#xA;the following formats:&#xA;  &#xA;```javascript&#xA;{ state: &apos;fulfilled&apos;, value: value }&#xA;  or&#xA;{ state: &apos;rejected&apos;, reason: reason }&#xA;```&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promise1 = RSVP.Promise.resolve(1);&#xA;var promise2 = RSVP.Promise.reject(new Error(&apos;2&apos;));&#xA;var promise3 = RSVP.Promise.reject(new Error(&apos;3&apos;));&#xA;var promises = [ promise1, promise2, promise3 ];&#xA;  &#xA;RSVP.allSettled(promises).then(function(array){&#xA;  // array == [&#xA;  //   { state: &apos;fulfilled&apos;, value: 1 },&#xA;  //   { state: &apos;rejected&apos;, reason: Error },&#xA;  //   { state: &apos;rejected&apos;, reason: Error }&#xA;  // ]&#xA;  // Note that for the second item, reason.message will be &apos;2&apos;, and for the&#xA;  // third item, reason.message will be &apos;3&apos;.&#xA;}, function(error) {&#xA;  // Not run. (This block would only be called if allSettled had failed,&#xA;  // for instance if passed an incorrect argument type.)&#xA;});&#xA;```" ilk="function" name="allSettled" returns="Promise" signature="allSettled(entries,label) =&gt; Promise">
            <variable citdl="Array" ilk="argument" name="entries" />
            <variable citdl="String" doc="- optional string that describes the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="This is a convenient alias for `RSVP.Promise.all`." ilk="function" name="all" signature="all(array,label)">
            <variable citdl="Array" doc="Array of promises." ilk="argument" name="array" />
            <variable citdl="String" doc="An optional label. This is useful&#xA;for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.defer` returns an object similar to jQuery&apos;s `$.Deferred`.&#xA;`RSVP.defer` should be used when porting over code reliant on `$.Deferred`&apos;s&#xA;interface. New code should use the `RSVP.Promise` constructor instead.&#xA;  &#xA;The object returned from `RSVP.defer` is a plain object with three properties:&#xA;  &#xA;* promise - an `RSVP.Promise`.&#xA;* reject - a function that causes the `promise` property on this object to&#xA;  become rejected&#xA;* resolve - a function that causes the `promise` property on this object to&#xA;  become fulfilled.&#xA;  &#xA;Example:&#xA;  &#xA; ```javascript&#xA; var deferred = RSVP.defer();&#xA;  &#xA; deferred.resolve(&quot;Success!&quot;);&#xA;  &#xA; deferred.promise.then(function(value){&#xA;   // value here is &quot;Success!&quot;&#xA; });&#xA; ```" ilk="function" name="defer" returns="Object" signature="defer(label) =&gt; Object">
            <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.filter` is similar to JavaScript&apos;s native `filter` method, except that it&#xA; waits for all promises to become fulfilled before running the `filterFn` on&#xA; each item in given to `promises`. `RSVP.filter` returns a promise that will&#xA; become fulfilled with the result of running `filterFn` on the values the&#xA; promises become fulfilled with.&#xA;  &#xA; For example:&#xA;  &#xA; ```javascript&#xA;  &#xA; var promise1 = RSVP.resolve(1);&#xA; var promise2 = RSVP.resolve(2);&#xA; var promise3 = RSVP.resolve(3);&#xA;  &#xA; var promises = [promise1, promise2, promise3];&#xA;  &#xA; var filterFn = function(item){&#xA;   return item &gt; 1;&#xA; };&#xA;  &#xA; RSVP.filter(promises, filterFn).then(function(result){&#xA;   // result is [ 2, 3 ]&#xA; });&#xA; ```&#xA;  &#xA; If any of the `promises` given to `RSVP.filter` are rejected, the first promise&#xA; that is rejected will be given as an argument to the returned promise&apos;s&#xA; rejection handler. For example:&#xA;  &#xA; ```javascript&#xA; var promise1 = RSVP.resolve(1);&#xA; var promise2 = RSVP.reject(new Error(&apos;2&apos;));&#xA; var promise3 = RSVP.reject(new Error(&apos;3&apos;));&#xA; var promises = [ promise1, promise2, promise3 ];&#xA;  &#xA; var filterFn = function(item){&#xA;   return item &gt; 1;&#xA; };&#xA;  &#xA; RSVP.filter(promises, filterFn).then(function(array){&#xA;   // Code here never runs because there are rejected promises!&#xA; }, function(reason) {&#xA;   // reason.message === &apos;2&apos;&#xA; });&#xA; ```&#xA;  &#xA; `RSVP.filter` will also wait for any promises returned from `filterFn`.&#xA; For instance, you may want to fetch a list of users then return a subset&#xA; of those users based on some asynchronous operation:&#xA;  &#xA; ```javascript&#xA;  &#xA; var alice = { name: &apos;alice&apos; };&#xA; var bob   = { name: &apos;bob&apos; };&#xA; var users = [ alice, bob ];&#xA;  &#xA; var promises = users.map(function(user){&#xA;   return RSVP.resolve(user);&#xA; });&#xA;  &#xA; var filterFn = function(user){&#xA;   // Here, Alice has permissions to create a blog post, but Bob does not.&#xA;   return getPrivilegesForUser(user).then(function(privs){&#xA;     return privs.can_create_blog_post === true;&#xA;   });&#xA; };&#xA; RSVP.filter(promises, filterFn).then(function(users){&#xA;   // true, because the server told us only Alice can create a blog post.&#xA;   users.length === 1;&#xA;   // false, because Alice is the only user present in `users`&#xA;   users[0] === bob;&#xA; });&#xA; ```" ilk="function" name="filter" returns="Promise" signature="filter(promises,filterFn,label) =&gt; Promise">
            <variable citdl="Array" ilk="argument" name="promises" />
            <variable citdl="Function" doc="- function to be called on each resolved value to&#xA; filter the final results." ilk="argument" name="filterFn" />
            <variable citdl="String" doc="optional string describing the promise. Useful for&#xA; tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.hashSettled` is similar to `RSVP.allSettled`, but takes an object&#xA;instead of an array for its `promises` argument.&#xA;  &#xA;Unlike `RSVP.all` or `RSVP.hash`, which implement a fail-fast method,&#xA;but like `RSVP.allSettled`, `hashSettled` waits until all the&#xA;constituent promises have returned and then shows you all the results&#xA;with their states and values/reasons. This is useful if you want to&#xA;handle multiple promises&apos; failure states together as a set.&#xA;  &#xA;Returns a promise that is fulfilled when all the given promises have been&#xA;settled, or rejected if the passed parameters are invalid.&#xA;  &#xA;The returned promise is fulfilled with a hash that has the same key names as&#xA;the `promises` object argument. If any of the values in the object are not&#xA;promises, they will be copied over to the fulfilled object and marked with state&#xA;&apos;fulfilled&apos;.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promises = {&#xA;  myPromise: RSVP.Promise.resolve(1),&#xA;  yourPromise: RSVP.Promise.resolve(2),&#xA;  theirPromise: RSVP.Promise.resolve(3),&#xA;  notAPromise: 4&#xA;};&#xA;  &#xA;RSVP.hashSettled(promises).then(function(hash){&#xA;  // hash here is an object that looks like:&#xA;  // {&#xA;  //   myPromise: { state: &apos;fulfilled&apos;, value: 1 },&#xA;  //   yourPromise: { state: &apos;fulfilled&apos;, value: 2 },&#xA;  //   theirPromise: { state: &apos;fulfilled&apos;, value: 3 },&#xA;  //   notAPromise: { state: &apos;fulfilled&apos;, value: 4 }&#xA;  // }&#xA;});&#xA;```&#xA;  &#xA;If any of the `promises` given to `RSVP.hash` are rejected, the state will&#xA;be set to &apos;rejected&apos; and the reason for rejection provided.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promises = {&#xA;  myPromise: RSVP.Promise.resolve(1),&#xA;  rejectedPromise: RSVP.Promise.reject(new Error(&apos;rejection&apos;)),&#xA;  anotherRejectedPromise: RSVP.Promise.reject(new Error(&apos;more rejection&apos;)),&#xA;};&#xA;  &#xA;RSVP.hashSettled(promises).then(function(hash){&#xA;  // hash here is an object that looks like:&#xA;  // {&#xA;  //   myPromise:              { state: &apos;fulfilled&apos;, value: 1 },&#xA;  //   rejectedPromise:        { state: &apos;rejected&apos;, reason: Error },&#xA;  //   anotherRejectedPromise: { state: &apos;rejected&apos;, reason: Error },&#xA;  // }&#xA;  // Note that for rejectedPromise, reason.message == &apos;rejection&apos;,&#xA;  // and for anotherRejectedPromise, reason.message == &apos;more rejection&apos;.&#xA;});&#xA;```&#xA;  &#xA;An important note: `RSVP.hashSettled` is intended for plain JavaScript objects that&#xA;are just a set of keys and values. `RSVP.hashSettled` will NOT preserve prototype&#xA;chains.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;function MyConstructor(){&#xA;  this.example = RSVP.Promise.resolve(&apos;Example&apos;);&#xA;}&#xA;  &#xA;MyConstructor.prototype = {&#xA;  protoProperty: RSVP.Promise.resolve(&apos;Proto Property&apos;)&#xA;};&#xA;  &#xA;var myObject = new MyConstructor();&#xA;  &#xA;RSVP.hashSettled(myObject).then(function(hash){&#xA;  // protoProperty will not be present, instead you will just have an&#xA;  // object that looks like:&#xA;  // {&#xA;  //   example: { state: &apos;fulfilled&apos;, value: &apos;Example&apos; }&#xA;  // }&#xA;  //&#xA;  // hash.hasOwnProperty(&apos;protoProperty&apos;); // false&#xA;  // &apos;undefined&apos; === typeof hash.protoProperty&#xA;});&#xA;```" ilk="function" name="hashSettled" returns="Promise" signature="hashSettled(object,label) =&gt; Promise">
            <variable citdl="Object" ilk="argument" name="object" />
            <variable citdl="String" doc="optional string that describes the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.hash` is similar to `RSVP.all`, but takes an object instead of an array&#xA;for its `promises` argument.&#xA;  &#xA;Returns a promise that is fulfilled when all the given promises have been&#xA;fulfilled, or rejected if any of them become rejected. The returned promise&#xA;is fulfilled with a hash that has the same key names as the `promises` object&#xA;argument. If any of the values in the object are not promises, they will&#xA;simply be copied over to the fulfilled object.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promises = {&#xA;  myPromise: RSVP.resolve(1),&#xA;  yourPromise: RSVP.resolve(2),&#xA;  theirPromise: RSVP.resolve(3),&#xA;  notAPromise: 4&#xA;};&#xA;  &#xA;RSVP.hash(promises).then(function(hash){&#xA;  // hash here is an object that looks like:&#xA;  // {&#xA;  //   myPromise: 1,&#xA;  //   yourPromise: 2,&#xA;  //   theirPromise: 3,&#xA;  //   notAPromise: 4&#xA;  // }&#xA;});&#xA;````&#xA;  &#xA;If any of the `promises` given to `RSVP.hash` are rejected, the first promise&#xA;that is rejected will be given as the reason to the rejection handler.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promises = {&#xA;  myPromise: RSVP.resolve(1),&#xA;  rejectedPromise: RSVP.reject(new Error(&apos;rejectedPromise&apos;)),&#xA;  anotherRejectedPromise: RSVP.reject(new Error(&apos;anotherRejectedPromise&apos;)),&#xA;};&#xA;  &#xA;RSVP.hash(promises).then(function(hash){&#xA;  // Code here never runs because there are rejected promises!&#xA;}, function(reason) {&#xA;  // reason.message === &apos;rejectedPromise&apos;&#xA;});&#xA;```&#xA;  &#xA;An important note: `RSVP.hash` is intended for plain JavaScript objects that&#xA;are just a set of keys and values. `RSVP.hash` will NOT preserve prototype&#xA;chains.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;function MyConstructor(){&#xA;  this.example = RSVP.resolve(&apos;Example&apos;);&#xA;}&#xA;  &#xA;MyConstructor.prototype = {&#xA;  protoProperty: RSVP.resolve(&apos;Proto Property&apos;)&#xA;};&#xA;  &#xA;var myObject = new MyConstructor();&#xA;  &#xA;RSVP.hash(myObject).then(function(hash){&#xA;  // protoProperty will not be present, instead you will just have an&#xA;  // object that looks like:&#xA;  // {&#xA;  //   example: &apos;Example&apos;&#xA;  // }&#xA;  //&#xA;  // hash.hasOwnProperty(&apos;protoProperty&apos;); // false&#xA;  // &apos;undefined&apos; === typeof hash.protoProperty&#xA;});&#xA;```" ilk="function" name="hash" returns="Promise" signature="hash(object,label) =&gt; Promise">
            <variable citdl="Object" ilk="argument" name="object" />
            <variable citdl="String" doc="optional string that describes the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.map` is similar to JavaScript&apos;s native `map` method, except that it&#xA; waits for all promises to become fulfilled before running the `mapFn` on&#xA; each item in given to `promises`. `RSVP.map` returns a promise that will&#xA; become fulfilled with the result of running `mapFn` on the values the promises&#xA; become fulfilled with.&#xA;  &#xA; For example:&#xA;  &#xA; ```javascript&#xA;  &#xA; var promise1 = RSVP.resolve(1);&#xA; var promise2 = RSVP.resolve(2);&#xA; var promise3 = RSVP.resolve(3);&#xA; var promises = [ promise1, promise2, promise3 ];&#xA;  &#xA; var mapFn = function(item){&#xA;   return item + 1;&#xA; };&#xA;  &#xA; RSVP.map(promises, mapFn).then(function(result){&#xA;   // result is [ 2, 3, 4 ]&#xA; });&#xA; ```&#xA;  &#xA; If any of the `promises` given to `RSVP.map` are rejected, the first promise&#xA; that is rejected will be given as an argument to the returned promise&apos;s&#xA; rejection handler. For example:&#xA;  &#xA; ```javascript&#xA; var promise1 = RSVP.resolve(1);&#xA; var promise2 = RSVP.reject(new Error(&apos;2&apos;));&#xA; var promise3 = RSVP.reject(new Error(&apos;3&apos;));&#xA; var promises = [ promise1, promise2, promise3 ];&#xA;  &#xA; var mapFn = function(item){&#xA;   return item + 1;&#xA; };&#xA;  &#xA; RSVP.map(promises, mapFn).then(function(array){&#xA;   // Code here never runs because there are rejected promises!&#xA; }, function(reason) {&#xA;   // reason.message === &apos;2&apos;&#xA; });&#xA; ```&#xA;  &#xA; `RSVP.map` will also wait if a promise is returned from `mapFn`. For example,&#xA; say you want to get all comments from a set of blog posts, but you need&#xA; the blog posts first because they contain a url to those comments.&#xA;  &#xA; ```javscript&#xA;  &#xA; var mapFn = function(blogPost){&#xA;   // getComments does some ajax and returns an RSVP.Promise that is fulfilled&#xA;   // with some comments data&#xA;   return getComments(blogPost.comments_url);&#xA; };&#xA;  &#xA; // getBlogPosts does some ajax and returns an RSVP.Promise that is fulfilled&#xA; // with some blog post data&#xA; RSVP.map(getBlogPosts(), mapFn).then(function(comments){&#xA;   // comments is the result of asking the server for the comments&#xA;   // of all blog posts returned from getBlogPosts()&#xA; });&#xA; ```" ilk="function" name="map" returns="Promise" signature="map(promises,mapFn,label) =&gt; Promise">
            <variable citdl="Array" ilk="argument" name="promises" />
            <variable citdl="Function" doc="function to be called on each fulfilled promise." ilk="argument" name="mapFn" />
            <variable citdl="String" doc="optional string for labeling the promise.&#xA; Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.denodeify` takes a &apos;node-style&apos; function and returns a function that&#xA;will return an `RSVP.Promise`. You can use `denodeify` in Node.js or the&#xA;browser when you&apos;d prefer to use promises over using callbacks. For example,&#xA;`denodeify` transforms the following:&#xA;  &#xA;```javascript&#xA;var fs = require(&apos;fs&apos;);&#xA;  &#xA;fs.readFile(&apos;myfile.txt&apos;, function(err, data){&#xA;  if (err) return handleError(err);&#xA;  handleData(data);&#xA;});&#xA;```&#xA;  &#xA;into:&#xA;  &#xA;```javascript&#xA;var fs = require(&apos;fs&apos;);&#xA;var readFile = RSVP.denodeify(fs.readFile);&#xA;  &#xA;readFile(&apos;myfile.txt&apos;).then(handleData, handleError);&#xA;```&#xA;  &#xA;If the node function has multiple success parameters, then `denodeify`&#xA;just returns the first one:&#xA;  &#xA;```javascript&#xA;var request = RSVP.denodeify(require(&apos;request&apos;));&#xA;  &#xA;request(&apos;http://example.com&apos;).then(function(res) {&#xA;  // ...&#xA;});&#xA;```&#xA;  &#xA;However, if you need all success parameters, setting `denodeify`&apos;s&#xA;second parameter to `true` causes it to return all success parameters&#xA;as an array:&#xA;  &#xA;```javascript&#xA;var request = RSVP.denodeify(require(&apos;request&apos;), true);&#xA;  &#xA;request(&apos;http://example.com&apos;).then(function(result) {&#xA;  // result[0] -&gt; res&#xA;  // result[1] -&gt; body&#xA;});&#xA;```&#xA;  &#xA;Or if you pass it an array with names it returns the parameters as a hash:&#xA;  &#xA;```javascript&#xA;var request = RSVP.denodeify(require(&apos;request&apos;), [&apos;res&apos;, &apos;body&apos;]);&#xA;  &#xA;request(&apos;http://example.com&apos;).then(function(result) {&#xA;  // result.res&#xA;  // result.body&#xA;});&#xA;```&#xA;  &#xA;Sometimes you need to retain the `this`:&#xA;  &#xA;```javascript&#xA;var app = require(&apos;express&apos;)();&#xA;var render = RSVP.denodeify(app.render.bind(app));&#xA;```&#xA;  &#xA;The denodified function inherits from the original function. It works in all&#xA;environments, except IE 10 and below. Consequently all properties of the original&#xA;function are available to you. However, any properties you change on the&#xA;denodeified function won&apos;t be changed on the original function. Example:&#xA;  &#xA;```javascript&#xA;var request = RSVP.denodeify(require(&apos;request&apos;)),&#xA;    cookieJar = request.jar(); // &lt;- Inheritance is used here&#xA;  &#xA;request(&apos;http://example.com&apos;, {jar: cookieJar}).then(function(res) {&#xA;  // cookieJar.cookies holds now the cookies returned by example.com&#xA;});&#xA;```&#xA;  &#xA;Using `denodeify` makes it easier to compose asynchronous operations instead&#xA;of using callbacks. For example, instead of:&#xA;  &#xA;```javascript&#xA;var fs = require(&apos;fs&apos;);&#xA;  &#xA;fs.readFile(&apos;myfile.txt&apos;, function(err, data){&#xA;  if (err) { ... } // Handle error&#xA;  fs.writeFile(&apos;myfile2.txt&apos;, data, function(err){&#xA;    if (err) { ... } // Handle error&#xA;    console.log(&apos;done&apos;)&#xA;  });&#xA;});&#xA;```&#xA;  &#xA;you can chain the operations together using `then` from the returned promise:&#xA;  &#xA;```javascript&#xA;var fs = require(&apos;fs&apos;);&#xA;var readFile = RSVP.denodeify(fs.readFile);&#xA;var writeFile = RSVP.denodeify(fs.writeFile);&#xA;  &#xA;readFile(&apos;myfile.txt&apos;).then(function(data){&#xA;  return writeFile(&apos;myfile2.txt&apos;, data);&#xA;}).then(function(){&#xA;  console.log(&apos;done&apos;)&#xA;}).catch(function(error){&#xA;  // Handle error&#xA;});&#xA;```" ilk="function" name="denodeify" returns="Function" signature="denodeify(nodeFunc,options) =&gt; Function">
            <variable citdl="Function" doc="a &apos;node-style&apos; function that takes a callback as&#xA;its last argument. The callback expects an error to be passed as its first&#xA;argument (if an error occurred, otherwise null), and the value from the&#xA;operation as its second argument (&apos;function(err, value){ }&apos;)." ilk="argument" name="nodeFunc" />
            <variable citdl="Boolean|Array" doc="An optional paramter that if set&#xA;to `true` causes the promise to fulfill with the callback&apos;s success arguments&#xA;as an array. This is useful if the node function has multiple success&#xA;paramters. If you set this paramter to an array with names, the promise will&#xA;fulfill with a hash with these names as keys and the success parameters as&#xA;values." ilk="argument" name="options" />
          </scope>
          <scope doc="`RSVP.Promise.all` accepts an array of promises, and returns a new promise which&#xA;is fulfilled with an array of fulfillment values for the passed promises, or&#xA;rejected with the reason of the first passed promise to be rejected. It casts all&#xA;elements of the passed iterable to promises as it runs this algorithm.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promise1 = RSVP.resolve(1);&#xA;var promise2 = RSVP.resolve(2);&#xA;var promise3 = RSVP.resolve(3);&#xA;var promises = [ promise1, promise2, promise3 ];&#xA;  &#xA;RSVP.Promise.all(promises).then(function(array){&#xA;  // The array here would be [ 1, 2, 3 ];&#xA;});&#xA;```&#xA;  &#xA;If any of the `promises` given to `RSVP.all` are rejected, the first promise&#xA;that is rejected will be given as an argument to the returned promises&apos;s&#xA;rejection handler. For example:&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promise1 = RSVP.resolve(1);&#xA;var promise2 = RSVP.reject(new Error(&quot;2&quot;));&#xA;var promise3 = RSVP.reject(new Error(&quot;3&quot;));&#xA;var promises = [ promise1, promise2, promise3 ];&#xA;  &#xA;RSVP.Promise.all(promises).then(function(array){&#xA;  // Code here never runs because there are rejected promises!&#xA;}, function(error) {&#xA;  // error.message === &quot;2&quot;&#xA;});&#xA;```" ilk="function" name="all" returns="Promise" signature="all(entries,label) =&gt; Promise">
            <variable citdl="Array" doc="array of promises" ilk="argument" name="entries" />
            <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.Promise.race` returns a new promise which is settled in the same way as the&#xA;first passed promise to settle.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;var promise1 = new RSVP.Promise(function(resolve, reject){&#xA;  setTimeout(function(){&#xA;    resolve(&apos;promise 1&apos;);&#xA;  }, 200);&#xA;});&#xA;  &#xA;var promise2 = new RSVP.Promise(function(resolve, reject){&#xA;  setTimeout(function(){&#xA;    resolve(&apos;promise 2&apos;);&#xA;  }, 100);&#xA;});&#xA;  &#xA;RSVP.Promise.race([promise1, promise2]).then(function(result){&#xA;  // result === &apos;promise 2&apos; because it was resolved before promise1&#xA;  // was resolved.&#xA;});&#xA;```&#xA;  &#xA;`RSVP.Promise.race` is deterministic in that only the state of the first&#xA;settled promise matters. For example, even if other promises given to the&#xA;`promises` array argument are resolved, but the first settled promise has&#xA;become rejected before the other promises became fulfilled, the returned&#xA;promise will become rejected:&#xA;  &#xA;```javascript&#xA;var promise1 = new RSVP.Promise(function(resolve, reject){&#xA;  setTimeout(function(){&#xA;    resolve(&apos;promise 1&apos;);&#xA;  }, 200);&#xA;});&#xA;  &#xA;var promise2 = new RSVP.Promise(function(resolve, reject){&#xA;  setTimeout(function(){&#xA;    reject(new Error(&apos;promise 2&apos;));&#xA;  }, 100);&#xA;});&#xA;  &#xA;RSVP.Promise.race([promise1, promise2]).then(function(result){&#xA;  // Code here never runs&#xA;}, function(reason){&#xA;  // reason.message === &apos;promise 2&apos; because promise 2 became rejected before&#xA;  // promise 1 became fulfilled&#xA;});&#xA;```&#xA;  &#xA;An example real-world use case is implementing timeouts:&#xA;  &#xA;```javascript&#xA;RSVP.Promise.race([ajax(&apos;foo.json&apos;), timeout(5000)])&#xA;```" ilk="function" name="race" returns="Promise" signature="race(entries,label) =&gt; Promise">
            <variable citdl="Array" doc="array of promises to observe" ilk="argument" name="entries" />
            <variable citdl="String" doc="optional string for describing the promise returned.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.Promise.reject` returns a promise rejected with the passed `reason`.&#xA;It is shorthand for the following:&#xA;  &#xA;```javascript&#xA;var promise = new RSVP.Promise(function(resolve, reject){&#xA;  reject(new Error(&apos;WHOOPS&apos;));&#xA;});&#xA;  &#xA;promise.then(function(value){&#xA;  // Code here doesn&apos;t run because the promise is rejected!&#xA;}, function(reason){&#xA;  // reason.message === &apos;WHOOPS&apos;&#xA;});&#xA;```&#xA;  &#xA;Instead of writing the above, your code now simply becomes the following:&#xA;  &#xA;```javascript&#xA;var promise = RSVP.Promise.reject(new Error(&apos;WHOOPS&apos;));&#xA;  &#xA;promise.then(function(value){&#xA;  // Code here doesn&apos;t run because the promise is rejected!&#xA;}, function(reason){&#xA;  // reason.message === &apos;WHOOPS&apos;&#xA;});&#xA;```" ilk="function" name="reject" returns="Promise" signature="reject(reason,label) =&gt; Promise">
            <variable citdl="*" doc="value that the returned promise will be rejected with." ilk="argument" name="reason" />
            <variable citdl="String" doc="optional string for identifying the returned promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.Promise.resolve` returns a promise that will become resolved with the&#xA;passed `value`. It is shorthand for the following:&#xA;  &#xA;```javascript&#xA;var promise = new RSVP.Promise(function(resolve, reject){&#xA;  resolve(1);&#xA;});&#xA;  &#xA;promise.then(function(value){&#xA;  // value === 1&#xA;});&#xA;```&#xA;  &#xA;Instead of writing the above, your code now simply becomes the following:&#xA;  &#xA;```javascript&#xA;var promise = RSVP.Promise.resolve(1);&#xA;  &#xA;promise.then(function(value){&#xA;  // value === 1&#xA;});&#xA;```" ilk="function" name="resolve" returns="Promise" signature="resolve(object,label) =&gt; Promise">
            <variable citdl="*" doc="value that the returned promise will be resolved with" ilk="argument" name="object" />
            <variable citdl="String" doc="optional string for identifying the returned promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="This is a convenient alias for `RSVP.Promise.race`." ilk="function" name="race" signature="race(array,label)">
            <variable citdl="Array" doc="Array of promises." ilk="argument" name="array" />
            <variable citdl="String" doc="An optional label. This is useful&#xA;for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="This is a convenient alias for `RSVP.Promise.reject`." ilk="function" name="reject" returns="Promise" signature="reject(reason,label) =&gt; Promise">
            <variable citdl="*" doc="value that the returned promise will be rejected with." ilk="argument" name="reason" />
            <variable citdl="String" doc="optional string for identifying the returned promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="This is a convenient alias for `RSVP.Promise.resolve`." ilk="function" name="resolve" returns="Promise" signature="resolve(value,label) =&gt; Promise">
            <variable citdl="*" doc="value that the returned promise will be resolved with" ilk="argument" name="value" />
            <variable citdl="String" doc="optional string for identifying the returned promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope doc="`RSVP.rethrow` will rethrow an error on the next turn of the JavaScript event&#xA;loop in order to aid debugging.&#xA;  &#xA;Promises A+ specifies that any exceptions that occur with a promise must be&#xA;caught by the promises implementation and bubbled to the last handler. For&#xA;this reason, it is recommended that you always specify a second rejection&#xA;handler function to `then`. However, `RSVP.rethrow` will throw the exception&#xA;outside of the promise, so it bubbles up to your console if in the browser,&#xA;or domain/cause uncaught exception in Node. `rethrow` will also throw the&#xA;error again so the error can be handled by the promise per the spec.&#xA;  &#xA;```javascript&#xA;function throws(){&#xA;  throw new Error(&apos;Whoops!&apos;);&#xA;}&#xA;  &#xA;var promise = new RSVP.Promise(function(resolve, reject){&#xA;  throws();&#xA;});&#xA;  &#xA;promise.catch(RSVP.rethrow).then(function(){&#xA;  // Code here doesn&apos;t run because the promise became rejected due to an&#xA;  // error!&#xA;}, function (err){&#xA;  // handle the error here&#xA;});&#xA;```&#xA;  &#xA;The &apos;Whoops&apos; error will be thrown on the next turn of the event loop&#xA;and you can watch for it in your console. You can also handle it using a&#xA;rejection handler given to `.then` or `.catch` on the returned promise." ilk="function" name="rethrow" signature="rethrow(reason)">
            <variable citdl="Error" doc="reason the promise became rejected." ilk="argument" name="reason" />
          </scope>
        </scope>
        <scope classrefs="Ember.Object" doc="The `Ember.Route` class is used to define individual routes. Refer to&#xA;the [routing guide](http://emberjs.com/guides/routing/) for documentation." ilk="class" name="Route">
          <variable attributes="property public" citdl="Object" doc="Configuration hash for this route&apos;s queryParams. The possible&#xA;configuration options and their defaults are as follows&#xA;(assuming a query param whose controller property is `page`):&#xA; ```javascript&#xA;queryParams: {&#xA;  page: {&#xA;    // By default, controller query param properties don&apos;t&#xA;    // cause a full transition when they are changed, but&#xA;    // rather only cause the URL to update. Setting&#xA;    // `refreshModel` to true will cause an &quot;in-place&quot;&#xA;    // transition to occur, whereby the model hooks for&#xA;    // this route (and any child routes) will re-fire, allowing&#xA;    // you to reload models (e.g., from the server) using the&#xA;    // updated query param values.&#xA;    refreshModel: false,&#xA;     // By default, changes to controller query param properties&#xA;    // cause the URL to update via `pushState`, which means an&#xA;    // item will be added to the browser&apos;s history, allowing&#xA;    // you to use the back button to restore the app to the&#xA;    // previous state before the query param property was changed.&#xA;    // Setting `replace` to true will use `replaceState` (or its&#xA;    // hash location equivalent), which causes no browser history&#xA;    // item to be added. This options name and default value are&#xA;    // the same as the `link-to` helper&apos;s `replace` option.&#xA;    replace: false,&#xA;     // By default, the query param URL key is the same name as&#xA;    // the controller property name. Use `as` to specify a&#xA;    // different URL key.&#xA;    as: &apos;page&apos;&#xA;  }&#xA;}&#xA;```" name="Route" />
          <variable attributes="property public" citdl="String" doc="The name of the route, dot-delimited.&#xA; For example, a route found at `app/routes/posts/post.js` or&#xA;`app/posts/post/route.js` (with pods) will have a `routeName` of&#xA;`posts.post`." name="Route" />
          <variable attributes="property private" name="Route" />
          <variable attributes="property private" name="Route" />
          <scope attributes="private" ilk="function" name="_stashNames" signature="_stashNames()" />
          <variable attributes="property private" name="Route" />
          <scope attributes="private" ilk="function" name="_updatingQPChanged" signature="_updatingQPChanged()" />
          <scope attributes="public" doc="Retrieves parameters, for current route using the state.params&#xA;variable and getQueryParamsFor, using the supplied routeName." ilk="function" name="paramsFor" signature="paramsFor(name)">
            <variable citdl="String" ilk="argument" name="name" />
          </scope>
          <scope attributes="private" doc="Serializes the query parameter key" ilk="function" name="serializeQueryParamKey" signature="serializeQueryParamKey(controllerPropertyName)">
            <variable citdl="String" ilk="argument" name="controllerPropertyName" />
          </scope>
          <scope attributes="private" doc="Serializes value of the query parameter based on defaultValueType" ilk="function" name="serializeQueryParam" signature="serializeQueryParam(value,urlKey,defaultValueType)">
            <variable citdl="Object" ilk="argument" name="value" />
            <variable citdl="String" ilk="argument" name="urlKey" />
            <variable citdl="String" ilk="argument" name="defaultValueType" />
          </scope>
          <scope attributes="private" doc="Deserializes value of the query parameter based on defaultValueType" ilk="function" name="deserializeQueryParam" signature="deserializeQueryParam(value,urlKey,defaultValueType)">
            <variable citdl="Object" ilk="argument" name="value" />
            <variable citdl="String" ilk="argument" name="urlKey" />
            <variable citdl="String" ilk="argument" name="defaultValueType" />
          </scope>
          <variable attributes="property private" name="Route" />
          <scope attributes="public" doc="A hook you can use to reset controller values either when the model&#xA;changes or the route is exiting.&#xA; ```javascript&#xA;App.ArticlesRoute = Ember.Route.extend({&#xA;  // ...&#xA;   resetController: function(controller, isExiting, transition) {&#xA;    if (isExiting) {&#xA;      controller.set(&apos;page&apos;, 1);&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="resetController" signature="resetController(controller,isExiting,transition)">
            <variable citdl="Controller" doc="instance" ilk="argument" name="controller" />
            <variable citdl="Boolean" ilk="argument" name="isExiting" />
            <variable citdl="Object" ilk="argument" name="transition" />
          </scope>
          <scope attributes="private" ilk="function" name="exit" signature="exit()" />
          <scope attributes="private" ilk="function" name="_reset" signature="_reset()" />
          <scope attributes="private" ilk="function" name="enter" signature="enter()" />
          <variable attributes="property public" citdl="String" doc="The name of the view to use by default when rendering this routes template.&#xA; When rendering a template, the route will, by default, determine the&#xA;template and view to use from the name of the route itself. If you need to&#xA;define a specific view, set this property.&#xA; This is useful when multiple routes would benefit from using the same view&#xA;because it doesn&apos;t require a custom `renderTemplate` method. For example,&#xA;the following routes will all render using the `App.PostsListView` view:&#xA; ```javascript&#xA;var PostsList = Ember.Route.extend({&#xA;  viewName: &apos;postsList&apos;&#xA;});&#xA; App.PostsIndexRoute = PostsList.extend();&#xA;App.PostsArchivedRoute = PostsList.extend();&#xA;```" name="Route" />
          <variable attributes="property public" citdl="String" doc="The name of the template to use by default when rendering this routes&#xA;template.&#xA; This is similar with `viewName`, but is useful when you just want a custom&#xA;template without a view.&#xA; ```javascript&#xA;var PostsList = Ember.Route.extend({&#xA;  templateName: &apos;posts/list&apos;&#xA;});&#xA; App.PostsIndexRoute = PostsList.extend();&#xA;App.PostsArchivedRoute = PostsList.extend();&#xA;```" name="Route" />
          <variable attributes="property public" citdl="String" doc="The name of the controller to associate with this route.&#xA; By default, Ember will lookup a route&apos;s controller that matches the name&#xA;of the route (i.e. `App.PostController` for `App.PostRoute`). However,&#xA;if you would like to define a specific controller to use, you can do so&#xA;using this property.&#xA; This is useful in many ways, as the controller specified will be:&#xA; * passed to the `setupController` method.&#xA;* used as the controller for the view being rendered by the route.&#xA;* returned from a call to `controllerFor` for the route." name="Route" />
          <variable attributes="event public" doc="The `willTransition` action is fired at the beginning of any&#xA;attempted transition with a `Transition` object as the sole&#xA;argument. This action can be used for aborting, redirecting,&#xA;or decorating the transition from the currently active routes.&#xA; A good example is preventing navigation when a form is&#xA;half-filled out:&#xA; ```javascript&#xA;App.ContactFormRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    willTransition: function(transition) {&#xA;      if (this.controller.get(&apos;userHasEnteredData&apos;)) {&#xA;        this.controller.displayNavigationConfirm();&#xA;        transition.abort();&#xA;      }&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; You can also redirect elsewhere by calling&#xA;`this.transitionTo(&apos;elsewhere&apos;)` from within `willTransition`.&#xA;Note that `willTransition` will not be fired for the&#xA;redirecting `transitionTo`, since `willTransition` doesn&apos;t&#xA;fire when there is already a transition underway. If you want&#xA;subsequent `willTransition` actions to fire for the redirecting&#xA;transition, you must first explicitly call&#xA;`transition.abort()`.&#xA; To allow the `willTransition` event to continue bubbling to the parent&#xA;route, use `return true;`. When the `willTransition` method has a&#xA;return value of `true` then the parent route&apos;s `willTransition` method&#xA;will be fired, enabling &quot;bubbling&quot; behavior for the event." name="Route" />
          <variable attributes="event public" doc="The `didTransition` action is fired after a transition has&#xA;successfully been completed. This occurs after the normal model&#xA;hooks (`beforeModel`, `model`, `afterModel`, `setupController`)&#xA;have resolved. The `didTransition` action has no arguments,&#xA;however, it can be useful for tracking page views or resetting&#xA;state on the controller.&#xA; ```javascript&#xA;App.LoginRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    didTransition: function() {&#xA;      this.controller.get(&apos;errors.base&apos;).clear();&#xA;      return true; // Bubble the didTransition event&#xA;    }&#xA;  }&#xA;});&#xA;```" name="Route" />
          <variable attributes="event public" doc="The `loading` action is fired on the route when a route&apos;s `model`&#xA;hook returns a promise that is not already resolved. The current&#xA;`Transition` object is the first parameter and the route that&#xA;triggered the loading event is the second parameter.&#xA; ```javascript&#xA;App.ApplicationRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    loading: function(transition, route) {&#xA;      var view = Ember.View.create({&#xA;        classNames: [&apos;app-loading&apos;]&#xA;      })&#xA;      .append();&#xA;       this.router.one(&apos;didTransition&apos;, function() {&#xA;        view.destroy();&#xA;      });&#xA;       return true; // Bubble the loading event&#xA;    }&#xA;  }&#xA;});&#xA;```" name="Route" />
          <variable attributes="event public" doc="When attempting to transition into a route, any of the hooks&#xA;may return a promise that rejects, at which point an `error`&#xA;action will be fired on the partially-entered routes, allowing&#xA;for per-route error handling logic, or shared error handling&#xA;logic defined on a parent route.&#xA; Here is an example of an error handler that will be invoked&#xA;for rejected promises from the various hooks on the route,&#xA;as well as any unhandled errors from child routes:&#xA; ```javascript&#xA;App.AdminRoute = Ember.Route.extend({&#xA;  beforeModel: function() {&#xA;    return Ember.RSVP.reject(&apos;bad things!&apos;);&#xA;  },&#xA;   actions: {&#xA;    error: function(error, transition) {&#xA;      // Assuming we got here due to the error in `beforeModel`,&#xA;      // we can expect that error === &quot;bad things!&quot;,&#xA;      // but a promise model rejecting would also&#xA;      // call this hook, as would any errors encountered&#xA;      // in `afterModel`.&#xA;       // The `error` hook is also provided the failed&#xA;      // `transition`, which can be stored and later&#xA;      // `.retry()`d if desired.&#xA;       this.transitionTo(&apos;login&apos;);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; `error` actions that bubble up all the way to `ApplicationRoute`&#xA;will fire a default error handler that logs the error. You can&#xA;specify your own global default error handler by overriding the&#xA;`error` handler on `ApplicationRoute`:&#xA; ```javascript&#xA;App.ApplicationRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    error: function(error, transition) {&#xA;      this.controllerFor(&apos;banner&apos;).displayError(error.message);&#xA;    }&#xA;  }&#xA;});&#xA;```" name="Route" />
          <variable attributes="event public" doc="This event is triggered when the router enters the route. It is&#xA;not executed when the model for the route changes.&#xA; ```javascript&#xA;App.ApplicationRoute = Ember.Route.extend({&#xA;  collectAnalytics: function(){&#xA;    collectAnalytics();&#xA;  }.on(&apos;activate&apos;)&#xA;});&#xA;```" name="Route" />
          <variable attributes="event public" doc="This event is triggered when the router completely exits this&#xA;route. It is not executed when the model for the route changes.&#xA; ```javascript&#xA;App.IndexRoute = Ember.Route.extend({&#xA;  trackPageLeaveAnalytics: function(){&#xA;    trackPageLeaveAnalytics();&#xA;  }.on(&apos;deactivate&apos;)&#xA;});&#xA;```" name="Route" />
          <variable attributes="property public" citdl="Ember.Controller" doc="The controller associated with this route.&#xA; Example&#xA; ```javascript&#xA;App.FormRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    willTransition: function(transition) {&#xA;      if (this.controller.get(&apos;userHasEnteredData&apos;) &amp;&amp;&#xA;          !confirm(&apos;Are you sure you want to abandon progress?&apos;)) {&#xA;        transition.abort();&#xA;      } else {&#xA;        // Bubble the `willTransition` action so that&#xA;        // parent routes can decide whether or not to abort.&#xA;        return true;&#xA;      }&#xA;    }&#xA;  }&#xA;});&#xA;```" name="Route" />
          <scope attributes="public" doc="This hook is executed when the router completely exits this route. It is&#xA;not executed when the model for the route changes." ilk="function" name="deactivate" signature="deactivate()" />
          <scope attributes="public" doc="This hook is executed when the router enters the route. It is not executed&#xA;when the model for the route changes." ilk="function" name="activate" signature="activate()" />
          <scope attributes="public" doc="Transition the application into another route. The route may&#xA;be either a single route or route path:&#xA; ```javascript&#xA;this.transitionTo(&apos;blogPosts&apos;);&#xA;this.transitionTo(&apos;blogPosts.recentEntries&apos;);&#xA;```&#xA; Optionally supply a model for the route in question. The model&#xA;will be serialized into the URL using the `serialize` hook of&#xA;the route:&#xA; ```javascript&#xA;this.transitionTo(&apos;blogPost&apos;, aPost);&#xA;```&#xA; If a literal is passed (such as a number or a string), it will&#xA;be treated as an identifier instead. In this case, the `model`&#xA;hook of the route will be triggered:&#xA; ```javascript&#xA;this.transitionTo(&apos;blogPost&apos;, 1);&#xA;```&#xA; Multiple models will be applied last to first recursively up the&#xA;route tree.&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;blogPost&apos;, { path:&apos;:blogPostId&apos; }, function() {&#xA;    this.route(&apos;blogComment&apos;, { path: &apos;:blogCommentId&apos;, resetNamespace: true });&#xA;  });&#xA;});&#xA; this.transitionTo(&apos;blogComment&apos;, aPost, aComment);&#xA;this.transitionTo(&apos;blogComment&apos;, 1, 13);&#xA;```&#xA; It is also possible to pass a URL (a string that starts with a&#xA;`/`). This is intended for testing and debugging purposes and&#xA;should rarely be used in production code.&#xA; ```javascript&#xA;this.transitionTo(&apos;/&apos;);&#xA;this.transitionTo(&apos;/blog/post/1/comment/13&apos;);&#xA;this.transitionTo(&apos;/blog/posts?sort=title&apos;);&#xA;```&#xA; An options hash with a `queryParams` property may be provided as&#xA;the final argument to add query parameters to the destination URL.&#xA; ```javascript&#xA;this.transitionTo(&apos;blogPost&apos;, 1, {&#xA;  queryParams: {showComments: &apos;true&apos;}&#xA;});&#xA; // if you just want to transition the query parameters without changing the route&#xA;this.transitionTo({queryParams: {sort: &apos;date&apos;}});&#xA;```&#xA; See also [replaceWith](#method_replaceWith).&#xA; Simple Transition Example&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;index&apos;);&#xA;  this.route(&apos;secret&apos;);&#xA;  this.route(&apos;fourOhFour&apos;, { path: &apos;*:&apos; });&#xA;});&#xA; App.IndexRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    moveToSecret: function(context) {&#xA;      if (authorized()) {&#xA;        this.transitionTo(&apos;secret&apos;, context);&#xA;      } else {&#xA;        this.transitionTo(&apos;fourOhFour&apos;);&#xA;      }&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; Transition to a nested route&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;articles&apos;, { path: &apos;/articles&apos; }, function() {&#xA;    this.route(&apos;new&apos;);&#xA;  });&#xA;});&#xA; App.IndexRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    transitionToNewArticle: function() {&#xA;      this.transitionTo(&apos;articles.new&apos;);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; Multiple Models Example&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;index&apos;);&#xA;   this.route(&apos;breakfast&apos;, { path: &apos;:breakfastId&apos; }, function() {&#xA;    this.route(&apos;cereal&apos;, { path: &apos;:cerealId&apos;, resetNamespace: true });&#xA;  });&#xA;});&#xA; App.IndexRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    moveToChocolateCereal: function() {&#xA;      var cereal = { cerealId: &apos;ChocolateYumminess&apos; };&#xA;      var breakfast = { breakfastId: &apos;CerealAndMilk&apos; };&#xA;       this.transitionTo(&apos;cereal&apos;, breakfast, cereal);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; Nested Route with Query String Example&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;fruits&apos;, function() {&#xA;    this.route(&apos;apples&apos;);&#xA;  });&#xA;});&#xA; App.IndexRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    transitionToApples: function() {&#xA;      this.transitionTo(&apos;fruits.apples&apos;, {queryParams: {color: &apos;red&apos;}});&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="transitionTo" returns="Transition" signature="transitionTo(name,models,options) =&gt; Transition">
            <variable citdl="String" doc="the name of the route or a URL" ilk="argument" name="name" />
            <variable citdl="...Object" doc="the model(s) or identifier(s) to be used while&#xA;  transitioning to the route." ilk="argument" name="models" />
            <variable citdl="Object" doc="optional hash with a queryParams property&#xA;  containing a mapping of query parameters" ilk="argument" name="options" />
          </scope>
          <scope attributes="public" doc="Perform a synchronous transition into another route without attempting&#xA;to resolve promises, update the URL, or abort any currently active&#xA;asynchronous transitions (i.e. regular transitions caused by&#xA;`transitionTo` or URL changes).&#xA; This method is handy for performing intermediate transitions on the&#xA;way to a final destination route, and is called internally by the&#xA;default implementations of the `error` and `loading` handlers." ilk="function" name="intermediateTransitionTo" signature="intermediateTransitionTo(name,models)">
            <variable citdl="String" doc="the name of the route" ilk="argument" name="name" />
            <variable citdl="...Object" doc="the model(s) to be used while transitioning&#xA;to the route." ilk="argument" name="models" />
          </scope>
          <scope attributes="public" doc="Refresh the model on this route and any child routes, firing the&#xA;`beforeModel`, `model`, and `afterModel` hooks in a similar fashion&#xA;to how routes are entered when transitioning in from other route.&#xA;The current route params (e.g. `article_id`) will be passed in&#xA;to the respective model hooks, and if a different model is returned,&#xA;`setupController` and associated route hooks will re-fire as well.&#xA; An example usage of this method is re-querying the server for the&#xA;latest information using the same parameters as when the route&#xA;was first entered.&#xA; Note that this will cause `model` hooks to fire even on routes&#xA;that were provided a model object when the route was initially&#xA;entered." ilk="function" name="refresh" returns="Transition" signature="refresh() =&gt; Transition" />
          <scope attributes="public" doc="Transition into another route while replacing the current URL, if possible.&#xA;This will replace the current history entry instead of adding a new one.&#xA;Beside that, it is identical to `transitionTo` in all other respects. See&#xA;&apos;transitionTo&apos; for additional information regarding multiple models.&#xA; Example&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;index&apos;);&#xA;  this.route(&apos;secret&apos;);&#xA;});&#xA; App.SecretRoute = Ember.Route.extend({&#xA;  afterModel: function() {&#xA;    if (!authorized()){&#xA;      this.replaceWith(&apos;index&apos;);&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="replaceWith" returns="Transition" signature="replaceWith(name,models) =&gt; Transition">
            <variable citdl="String" doc="the name of the route or a URL" ilk="argument" name="name" />
            <variable citdl="...Object" doc="the model(s) or identifier(s) to be used while&#xA;  transitioning to the route." ilk="argument" name="models" />
          </scope>
          <scope attributes="public" doc="Sends an action to the router, which will delegate it to the currently&#xA;active route hierarchy per the bubbling rules explained under `actions`.&#xA; Example&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;index&apos;);&#xA;});&#xA; App.ApplicationRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    track: function(arg) {&#xA;      console.log(arg, &apos;was clicked&apos;);&#xA;    }&#xA;  }&#xA;});&#xA; App.IndexRoute = Ember.Route.extend({&#xA;  actions: {&#xA;    trackIfDebug: function(arg) {&#xA;      if (debug) {&#xA;        this.send(&apos;track&apos;, arg);&#xA;      }&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="send" signature="send(name,args)">
            <variable citdl="String" doc="the name of the action to trigger" ilk="argument" name="name" />
            <variable citdl="...*" ilk="argument" name="args" />
          </scope>
          <scope attributes="private" doc="This hook is the entry point for router.js" ilk="function" name="setup" signature="setup()" />
          <scope attributes="public" doc="This hook is the first of the route entry validation hooks&#xA;called when an attempt is made to transition into a route&#xA;or one of its children. It is called before `model` and&#xA;`afterModel`, and is appropriate for cases when:&#xA; 1) A decision can be made to redirect elsewhere without&#xA;   needing to resolve the model first.&#xA;2) Any async operations need to occur first before the&#xA;   model is attempted to be resolved.&#xA; This hook is provided the current `transition` attempt&#xA;as a parameter, which can be used to `.abort()` the transition,&#xA;save it for a later `.retry()`, or retrieve values set&#xA;on it from a previous hook. You can also just call&#xA;`this.transitionTo` to another route to implicitly&#xA;abort the `transition`.&#xA; You can return a promise from this hook to pause the&#xA;transition until the promise resolves (or rejects). This could&#xA;be useful, for instance, for retrieving async code from&#xA;the server that is required to enter a route.&#xA; ```javascript&#xA;App.PostRoute = Ember.Route.extend({&#xA;  beforeModel: function(transition) {&#xA;    if (!App.Post) {&#xA;      return Ember.$.getScript(&apos;/models/post.js&apos;);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; If `App.Post` doesn&apos;t exist in the above example,&#xA;`beforeModel` will use jQuery&apos;s `getScript`, which&#xA;returns a promise that resolves after the server has&#xA;successfully retrieved and executed the code from the&#xA;server. Note that if an error were to occur, it would&#xA;be passed to the `error` hook on `Ember.Route`, but&#xA;it&apos;s also possible to handle errors specific to&#xA;`beforeModel` right from within the hook (to distinguish&#xA;from the shared error handling behavior of the `error`&#xA;hook):&#xA; ```javascript&#xA;App.PostRoute = Ember.Route.extend({&#xA;  beforeModel: function(transition) {&#xA;    if (!App.Post) {&#xA;      var self = this;&#xA;      return Ember.$.getScript(&apos;post.js&apos;).then(null, function(e) {&#xA;        self.transitionTo(&apos;help&apos;);&#xA;         // Note that the above transitionTo will implicitly&#xA;        // halt the transition. If you were to return&#xA;        // nothing from this promise reject handler,&#xA;        // according to promise semantics, that would&#xA;        // convert the reject into a resolve and the&#xA;        // transition would continue. To propagate the&#xA;        // error so that it&apos;d be handled by the `error`&#xA;        // hook, you would have to&#xA;        return Ember.RSVP.reject(e);&#xA;      });&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="beforeModel" returns="Promise" signature="beforeModel(transition) =&gt; Promise">
            <variable citdl="Transition" ilk="argument" name="transition" />
          </scope>
          <scope attributes="public" doc="This hook is called after this route&apos;s model has resolved.&#xA;It follows identical async/promise semantics to `beforeModel`&#xA;but is provided the route&apos;s resolved model in addition to&#xA;the `transition`, and is therefore suited to performing&#xA;logic that can only take place after the model has already&#xA;resolved.&#xA; ```javascript&#xA;App.PostsRoute = Ember.Route.extend({&#xA;  afterModel: function(posts, transition) {&#xA;    if (posts.get(&apos;length&apos;) === 1) {&#xA;      this.transitionTo(&apos;post.show&apos;, posts.get(&apos;firstObject&apos;));&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; Refer to documentation for `beforeModel` for a description&#xA;of transition-pausing semantics when a promise is returned&#xA;from this hook." ilk="function" name="afterModel" returns="Promise" signature="afterModel(resolvedModel,transition) =&gt; Promise">
            <variable citdl="Object" doc="the value returned from `model`,&#xA;  or its resolved value if it was a promise" ilk="argument" name="resolvedModel" />
            <variable citdl="Transition" ilk="argument" name="transition" />
          </scope>
          <scope attributes="public" doc="A hook you can implement to optionally redirect to another route.&#xA; If you call `this.transitionTo` from inside of this hook, this route&#xA;will not be entered in favor of the other hook.&#xA; `redirect` and `afterModel` behave very similarly and are&#xA;called almost at the same time, but they have an important&#xA;distinction in the case that, from one of these hooks, a&#xA;redirect into a child route of this route occurs: redirects&#xA;from `afterModel` essentially invalidate the current attempt&#xA;to enter this route, and will result in this route&apos;s `beforeModel`,&#xA;`model`, and `afterModel` hooks being fired again within&#xA;the new, redirecting transition. Redirects that occur within&#xA;the `redirect` hook, on the other hand, will _not_ cause&#xA;these hooks to be fired again the second time around; in&#xA;other words, by the time the `redirect` hook has been called,&#xA;both the resolved model and attempted entry into this route&#xA;are considered to be fully validated." ilk="function" name="redirect" signature="redirect(model,transition)">
            <variable citdl="Object" doc="the model for this route" ilk="argument" name="model" />
            <variable citdl="Transition" doc="the transition object associated with the current transition" ilk="argument" name="transition" />
          </scope>
          <scope attributes="private" doc="Called when the context is changed by router.js." ilk="function" name="contextDidChange" signature="contextDidChange()" />
          <scope attributes="public" doc="A hook you can implement to convert the URL into the model for&#xA;this route.&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;post&apos;, { path: &apos;/posts/:post_id&apos; });&#xA;});&#xA;```&#xA; The model for the `post` route is `store.findRecord(&apos;post&apos;, params.post_id)`.&#xA; By default, if your route has a dynamic segment ending in `_id`:&#xA; * The model class is determined from the segment (`post_id`&apos;s&#xA;  class is `App.Post`)&#xA;* The find method is called on the model class with the value of&#xA;  the dynamic segment.&#xA; Note that for routes with dynamic segments, this hook is not always&#xA;executed. If the route is entered through a transition (e.g. when&#xA;using the `link-to` Handlebars helper or the `transitionTo` method&#xA;of routes), and a model context is already provided this hook&#xA;is not called.&#xA; A model context does not include a primitive string or number,&#xA;which does cause the model hook to be called.&#xA; Routes without dynamic segments will always execute the model hook.&#xA; ```javascript&#xA;// no dynamic segment, model hook always called&#xA;this.transitionTo(&apos;posts&apos;);&#xA; // model passed in, so model hook not called&#xA;thePost = store.findRecord(&apos;post&apos;, 1);&#xA;this.transitionTo(&apos;post&apos;, thePost);&#xA; // integer passed in, model hook is called&#xA;this.transitionTo(&apos;post&apos;, 1);&#xA; // model id passed in, model hook is called&#xA;// useful for forcing the hook to execute&#xA;thePost = store.findRecord(&apos;post&apos;, 1);&#xA;this.transitionTo(&apos;post&apos;, thePost.id);&#xA;```&#xA;  This hook follows the asynchronous/promise semantics&#xA;described in the documentation for `beforeModel`. In particular,&#xA;if a promise returned from `model` fails, the error will be&#xA;handled by the `error` hook on `Ember.Route`.&#xA; Example&#xA; ```javascript&#xA;App.PostRoute = Ember.Route.extend({&#xA;  model: function(params) {&#xA;    return this.store.findRecord(&apos;post&apos;, params.post_id);&#xA;  }&#xA;});&#xA;```" ilk="function" name="model" returns="Object|Promise" signature="model(params,transition) =&gt; Object|Promise">
            <variable citdl="Object" doc="the parameters extracted from the URL" ilk="argument" name="params" />
            <variable citdl="Transition" ilk="argument" name="transition" />
          </scope>
          <scope attributes="private" ilk="function" name="deserialize" returns="Object|Promise" signature="deserialize(params,transition) =&gt; Object|Promise">
            <variable citdl="Object" doc="the parameters extracted from the URL" ilk="argument" name="params" />
            <variable citdl="Transition" ilk="argument" name="transition" />
          </scope>
          <scope attributes="private" ilk="function" name="findModel" signature="findModel(type,value)">
            <variable citdl="String" doc="the model type" ilk="argument" name="type" />
            <variable citdl="Object" doc="the value passed to find" ilk="argument" name="value" />
          </scope>
          <scope attributes="private" doc="Store property provides a hook for data persistence libraries to inject themselves.&#xA; By default, this store property provides the exact same functionality previously&#xA;in the model hook.&#xA; Currently, the required interface is:&#xA; `store.find(modelName, findArguments)`" ilk="function" name="store" signature="store(store)">
            <variable citdl="Object" ilk="argument" name="store" />
          </scope>
          <scope attributes="public" doc="A hook you can implement to convert the route&apos;s model into parameters&#xA;for the URL.&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;post&apos;, { path: &apos;/posts/:post_id&apos; });&#xA;});&#xA; App.PostRoute = Ember.Route.extend({&#xA;  model: function(params) {&#xA;    // the server returns `{ id: 12 }`&#xA;    return Ember.$.getJSON(&apos;/posts/&apos; + params.post_id);&#xA;  },&#xA;   serialize: function(model) {&#xA;    // this will make the URL `/posts/12`&#xA;    return { post_id: model.id };&#xA;  }&#xA;});&#xA;```&#xA; The default `serialize` method will insert the model&apos;s `id` into the&#xA;route&apos;s dynamic segment (in this case, `:post_id`) if the segment contains &apos;_id&apos;.&#xA;If the route has multiple dynamic segments or does not contain &apos;_id&apos;, `serialize`&#xA;will return `Ember.getProperties(model, params)`&#xA; This method is called when `transitionTo` is called with a context&#xA;in order to populate the URL." ilk="function" name="serialize" returns="Object" signature="serialize(model,params) =&gt; Object">
            <variable citdl="Object" doc="the routes model" ilk="argument" name="model" />
            <variable citdl="Array" doc="an Array of parameter names for the current&#xA;  route (in the example, `[&apos;post_id&apos;]`." ilk="argument" name="params" />
          </scope>
          <scope attributes="public" doc="A hook you can use to setup the controller for the current route.&#xA; This method is called with the controller for the current route and the&#xA;model supplied by the `model` hook.&#xA; By default, the `setupController` hook sets the `model` property of&#xA;the controller to the `model`.&#xA; If you implement the `setupController` hook in your Route, it will&#xA;prevent this default behavior. If you want to preserve that behavior&#xA;when implementing your `setupController` function, make sure to call&#xA;`_super`:&#xA; ```javascript&#xA;App.PhotosRoute = Ember.Route.extend({&#xA;  model: function() {&#xA;    return this.store.findAll(&apos;photo&apos;);&#xA;  },&#xA;   setupController: function(controller, model) {&#xA;    // Call _super for default behavior&#xA;    this._super(controller, model);&#xA;    // Implement your custom setup after&#xA;    this.controllerFor(&apos;application&apos;).set(&apos;showingPhotos&apos;, true);&#xA;  }&#xA;});&#xA;```&#xA; The provided controller will be one resolved based on the name&#xA;of this route.&#xA; If no explicit controller is defined, Ember will automatically create one.&#xA; As an example, consider the router:&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;  this.route(&apos;post&apos;, { path: &apos;/posts/:post_id&apos; });&#xA;});&#xA;```&#xA; For the `post` route, a controller named `App.PostController` would&#xA;be used if it is defined. If it is not defined, a basic `Ember.Controller`&#xA;instance would be used.&#xA; Example&#xA; ```javascript&#xA;App.PostRoute = Ember.Route.extend({&#xA;  setupController: function(controller, model) {&#xA;    controller.set(&apos;model&apos;, model);&#xA;  }&#xA;});&#xA;```" ilk="function" name="setupController" signature="setupController(controller,model)">
            <variable citdl="Controller" doc="instance" ilk="argument" name="controller" />
            <variable citdl="Object" ilk="argument" name="model" />
          </scope>
          <scope attributes="public" doc="Returns the controller for a particular route or name.&#xA; The controller instance must already have been created, either through entering the&#xA;associated route or using `generateController`.&#xA; ```javascript&#xA;App.PostRoute = Ember.Route.extend({&#xA;  setupController: function(controller, post) {&#xA;    this._super(controller, post);&#xA;    this.controllerFor(&apos;posts&apos;).set(&apos;currentPost&apos;, post);&#xA;  }&#xA;});&#xA;```" ilk="function" name="controllerFor" returns="Ember.Controller" signature="controllerFor(name) =&gt; Ember.Controller">
            <variable citdl="String" doc="the name of the route or controller" ilk="argument" name="name" />
          </scope>
          <scope attributes="private" doc="Generates a controller for a route.&#xA; Example&#xA; ```javascript&#xA;App.PostRoute = Ember.Route.extend({&#xA;  setupController: function(controller, post) {&#xA;    this._super(controller, post);&#xA;    this.generateController(&apos;posts&apos;, post);&#xA;  }&#xA;});&#xA;```" ilk="function" name="generateController" signature="generateController(name,model)">
            <variable citdl="String" doc="the name of the controller" ilk="argument" name="name" />
            <variable citdl="Object" doc="the model to infer the type of the controller (optional)" ilk="argument" name="model" />
          </scope>
          <scope attributes="public" doc="Returns the resolved model of a parent (or any ancestor) route&#xA;in a route hierarchy.  During a transition, all routes&#xA;must resolve a model object, and if a route&#xA;needs access to a parent route&apos;s model in order to&#xA;resolve a model (or just reuse the model from a parent),&#xA;it can call `this.modelFor(theNameOfParentRoute)` to&#xA;retrieve it. If the ancestor route&apos;s model was a promise,&#xA;its resolved result is returned.&#xA; Example&#xA; ```javascript&#xA;App.Router.map(function() {&#xA;    this.route(&apos;post&apos;, { path: &apos;/post/:post_id&apos; }, function() {&#xA;      this.route(&apos;comments&apos;, { resetNamespace: true });&#xA;    });&#xA;});&#xA; App.CommentsRoute = Ember.Route.extend({&#xA;    afterModel: function() {&#xA;      this.set(&apos;post&apos;, this.modelFor(&apos;post&apos;));&#xA;    }&#xA;});&#xA;```" ilk="function" name="modelFor" returns="Object" signature="modelFor(name) =&gt; Object">
            <variable citdl="String" doc="the name of the route" ilk="argument" name="name" />
          </scope>
          <scope attributes="public" doc="A hook you can use to render the template for the current route.&#xA; This method is called with the controller for the current route and the&#xA;model supplied by the `model` hook. By default, it renders the route&apos;s&#xA;template, configured with the controller for the route.&#xA; This method can be overridden to set up and render additional or&#xA;alternative templates.&#xA; ```javascript&#xA;App.PostsRoute = Ember.Route.extend({&#xA;  renderTemplate: function(controller, model) {&#xA;    var favController = this.controllerFor(&apos;favoritePost&apos;);&#xA;     // Render the `favoritePost` template into&#xA;    // the outlet `posts`, and display the `favoritePost`&#xA;    // controller.&#xA;    this.render(&apos;favoritePost&apos;, {&#xA;      outlet: &apos;posts&apos;,&#xA;      controller: favController&#xA;    });&#xA;  }&#xA;});&#xA;```" ilk="function" name="renderTemplate" signature="renderTemplate(controller,model)">
            <variable citdl="Object" doc="the route&apos;s controller" ilk="argument" name="controller" />
            <variable citdl="Object" doc="the route&apos;s model" ilk="argument" name="model" />
          </scope>
          <scope attributes="public" doc="`render` is used to render a template into a region of another template&#xA;(indicated by an `{{outlet}}`). `render` is used both during the entry&#xA;phase of routing (via the `renderTemplate` hook) and later in response to&#xA;user interaction.&#xA; For example, given the following minimal router and templates:&#xA; ```javascript&#xA;Router.map(function() {&#xA;  this.route(&apos;photos&apos;);&#xA;});&#xA;```&#xA; ```handlebars&#xA;&lt;!-- application.hbs --&gt;&#xA;&lt;div class=&apos;something-in-the-app-hbs&apos;&gt;&#xA;  {{outlet &quot;anOutletName&quot;}}&#xA;&lt;/div&gt;&#xA;```&#xA; ```handlebars&#xA;&lt;!-- photos.hbs --&gt;&#xA;&lt;h1&gt;Photos&lt;/h1&gt;&#xA;```&#xA; You can render `photos.hbs` into the `&quot;anOutletName&quot;` outlet of&#xA;`application.hbs` by calling `render`:&#xA; ```javascript&#xA;// posts route&#xA;Ember.Route.extend({&#xA;  renderTemplate: function() {&#xA;    this.render(&apos;photos&apos;, {&#xA;      into: &apos;application&apos;,&#xA;      outlet: &apos;anOutletName&apos;&#xA;    })&#xA;  }&#xA;});&#xA;```&#xA; `render` additionally allows you to supply which `view`, `controller`, and&#xA;`model` objects should be loaded and associated with the rendered template.&#xA;  ```javascript&#xA;// posts route&#xA;Ember.Route.extend({&#xA;  renderTemplate: function(controller, model){&#xA;    this.render(&apos;posts&apos;, {    // the template to render, referenced by name&#xA;      into: &apos;application&apos;,    // the template to render into, referenced by name&#xA;      outlet: &apos;anOutletName&apos;, // the outlet inside `options.template` to render into.&#xA;      view: &apos;aViewName&apos;,      // the view to use for this template, referenced by name&#xA;      controller: &apos;someControllerName&apos;, // the controller to use for this template, referenced by name&#xA;      model: model            // the model to set on `options.controller`.&#xA;    })&#xA;  }&#xA;});&#xA;```&#xA; The string values provided for the template name, view, and controller&#xA;will eventually pass through to the resolver for lookup. See&#xA;Ember.Resolver for how these are mapped to JavaScript objects in your&#xA;application.&#xA; Not all options need to be passed to `render`. Default values will be used&#xA;based on the name of the route specified in the router or the Route&apos;s&#xA;`controllerName`, `viewName` and `templateName` properties.&#xA; For example:&#xA; ```javascript&#xA;// router&#xA;Router.map(function() {&#xA;  this.route(&apos;index&apos;);&#xA;  this.route(&apos;post&apos;, { path: &apos;/posts/:post_id&apos; });&#xA;});&#xA;```&#xA; ```javascript&#xA;// post route&#xA;PostRoute = App.Route.extend({&#xA;  renderTemplate: function() {&#xA;    this.render(); // all defaults apply&#xA;  }&#xA;});&#xA;```&#xA; The name of the `PostRoute`, defined by the router, is `post`.&#xA; The following equivalent default options will be applied when&#xA;the Route calls `render`:&#xA; ```javascript&#xA;//&#xA;this.render(&apos;post&apos;, {  // the template name associated with &apos;post&apos; Route&#xA;  into: &apos;application&apos;, // the parent route to &apos;post&apos; Route&#xA;  outlet: &apos;main&apos;,      // {{outlet}} and {{outlet &apos;main&apos; are synonymous}},&#xA;  view: &apos;post&apos;,        // the view associated with the &apos;post&apos; Route&#xA;  controller: &apos;post&apos;,  // the controller associated with the &apos;post&apos; Route&#xA;})&#xA;```&#xA; By default the controller&apos;s `model` will be the route&apos;s model, so it does not&#xA;need to be passed unless you wish to change which model is being used." ilk="function" name="render" signature="render(name,options)">
            <variable citdl="String" doc="the name of the template to render" ilk="argument" name="name" />
            <variable citdl="Object" doc="the options" ilk="argument" name="options" />
          </scope>
          <scope attributes="public" doc="Disconnects a view that has been rendered into an outlet.&#xA; You may pass any or all of the following options to `disconnectOutlet`:&#xA; * `outlet`: the name of the outlet to clear (default: &apos;main&apos;)&#xA;* `parentView`: the name of the view containing the outlet to clear&#xA;   (default: the view rendered by the parent route)&#xA; Example:&#xA; ```javascript&#xA;App.ApplicationRoute = App.Route.extend({&#xA;  actions: {&#xA;    showModal: function(evt) {&#xA;      this.render(evt.modalName, {&#xA;        outlet: &apos;modal&apos;,&#xA;        into: &apos;application&apos;&#xA;      });&#xA;    },&#xA;    hideModal: function(evt) {&#xA;      this.disconnectOutlet({&#xA;        outlet: &apos;modal&apos;,&#xA;        parentView: &apos;application&apos;&#xA;      });&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA; Alternatively, you can pass the `outlet` name directly as a string.&#xA; Example:&#xA; ```javascript&#xA;hideModal: function(evt) {&#xA;  this.disconnectOutlet(&apos;modal&apos;);&#xA;}&#xA;```" ilk="function" name="disconnectOutlet" signature="disconnectOutlet(options)">
            <variable citdl="Object|String" doc="the options hash or outlet name" ilk="argument" name="options" />
          </scope>
          <scope attributes="private" ilk="function" name="teardownViews" signature="teardownViews()" />
        </scope>
        <scope classrefs="Ember.Object" doc="The `Ember.Router` class manages the application state and URLs. Refer to&#xA;the [routing guide](http://emberjs.com/guides/routing/) for documentation." ilk="class" name="Router">
          <variable attributes="property public" doc="The `location` property determines the type of URL&apos;s that your&#xA;application will use.&#xA; The following location types are currently available:&#xA; * `history` - use the browser&apos;s history API to make the URLs look just like any standard URL&#xA;* `hash` - use `#` to separate the server part of the URL from the Ember part: `/blog/#/posts/new`&#xA;* `none` - do not store the Ember URL in the actual browser URL (mainly used for testing)&#xA;* `auto` - use the best option based on browser capabilites: `history` if possible, then `hash` if possible, otherwise `none`&#xA; Note: If using ember-cli, this value is defaulted to `auto` by the `locationType` setting of `/config/environment.js`" name="Router" />
          <variable attributes="property public" doc="Represents the URL of the root of the application, often &apos;/&apos;. This prefix is&#xA;assumed on all routes defined on this router." name="Router" />
          <scope attributes="private" doc="Represents the current URL." ilk="function" name="url" returns="String" signature="url() =&gt; String" />
          <scope attributes="private" doc="Initializes the current router instance and sets up the change handling&#xA;event listeners used by the instances `location` implementation.&#xA; A property named `initialURL` will be used to determine the initial URL.&#xA;If no value is found `/` will be used." ilk="function" name="startRouting" signature="startRouting()" />
          <scope attributes="public" doc="Handles updating the paths and notifying any listeners of the URL&#xA;change.&#xA; Triggers the router level `didTransition` hook.&#xA; For example, to notify google analytics when the route changes,&#xA;you could use this hook.  (Note: requires also including GA scripts, etc.)&#xA; ```javascript&#xA;var Router = Ember.Router.extend({&#xA;  location: config.locationType,&#xA;   didTransition: function() {&#xA;    this._super(...arguments);&#xA;     return ga(&apos;send&apos;, &apos;pageview&apos;, {&#xA;        &apos;page&apos;: this.get(&apos;url&apos;),&#xA;        &apos;title&apos;: this.get(&apos;url&apos;)&#xA;      });&#xA;  }&#xA;});&#xA;```" ilk="function" name="didTransition" signature="didTransition()" />
          <scope attributes="public" doc="Handles notifying any listeners of an impending URL&#xA;change.&#xA; Triggers the router level `willTransition` hook." ilk="function" name="willTransition" signature="willTransition()" />
          <scope attributes="private" doc="Transition the application into another route. The route may&#xA;be either a single route or route path:&#xA; See [Route.transitionTo](http://emberjs.com/api/classes/Ember.Route.html#method_transitionTo) for more info." ilk="function" name="transitionTo" returns="Transition" signature="transitionTo(name,models,options) =&gt; Transition">
            <variable citdl="String" doc="the name of the route or a URL" ilk="argument" name="name" />
            <variable citdl="...Object" doc="the model(s) or identifier(s) to be used while&#xA;  transitioning to the route." ilk="argument" name="models" />
            <variable citdl="Object" doc="optional hash with a queryParams property&#xA;  containing a mapping of query parameters" ilk="argument" name="options" />
          </scope>
          <scope attributes="private" doc="Determines if the supplied route is currently active." ilk="function" name="isActive" returns="Boolean" signature="isActive(routeName) =&gt; Boolean">
            <variable ilk="argument" name="routeName" />
          </scope>
          <scope attributes="private" doc="An alternative form of `isActive` that doesn&apos;t require&#xA;manual concatenation of the arguments into a single&#xA;array." ilk="function" name="isActiveIntent" returns="Boolean" signature="isActiveIntent(routeName,models,queryParams) =&gt; Boolean">
            <variable ilk="argument" name="routeName" />
            <variable ilk="argument" name="models" />
            <variable ilk="argument" name="queryParams" />
          </scope>
          <scope attributes="private" doc="Does this router instance have the given route." ilk="function" name="hasRoute" returns="Boolean" signature="hasRoute() =&gt; Boolean" />
          <scope attributes="private" doc="Resets the state of the router by clearing the current route&#xA;handlers and deactivating them." ilk="function" name="reset" signature="reset()" />
          <scope attributes="public" doc="The `Router.map` function allows you to define mappings from URLs to routes&#xA;in your application. These mappings are defined within the&#xA;supplied callback function using `this.route`.&#xA; The first parameter is the name of the route which is used by default as the&#xA;path name as well.&#xA; The second parameter is the optional options hash. Available options are:&#xA;  * `path`: allows you to provide your own path as well as mark dynamic&#xA;    segments.&#xA;  * `resetNamespace`: false by default; when nesting routes, ember will&#xA;    combine the route names to form the fully-qualified route name, which is&#xA;    used with `{{link-to}}` or manually transitioning to routes. Setting&#xA;    `resetNamespace: true` will cause the route not to inherit from its&#xA;    parent route&apos;s names. This is handy for resources which can be accessed&#xA;    in multiple places as well as preventing extremely long route names.&#xA;    Keep in mind that the actual URL path behavior is still retained.&#xA; The third parameter is a function, which can be used to nest routes.&#xA;Nested routes, by default, will have the parent route tree&apos;s route name and&#xA;path prepended to it&apos;s own.&#xA; ```javascript&#xA;App.Router.map(function(){&#xA;  this.route(&apos;post&apos;, { path: &apos;/post/:post_id&apos; }, function() {&#xA;    this.route(&apos;edit&apos;);&#xA;    this.route(&apos;comments&apos;, { resetNamespace: true }, function() {&#xA;      this.route(&apos;new&apos;);&#xA;    });&#xA;  });&#xA;});&#xA;```&#xA; For more detailed documentation and examples please see&#xA;[the guides](http://emberjs.com/guides/routing/defining-your-routes/)." ilk="function" name="map" signature="map(callback)">
            <variable ilk="argument" name="callback" />
          </scope>
        </scope>
        <scope classrefs="Ember.View" doc="The `Ember.Select` view class renders a&#xA;[select](https://developer.mozilla.org/en/HTML/Element/select) HTML element,&#xA;allowing the user to choose from a list of options.&#xA;  &#xA;The text and `value` property of each `&lt;option&gt;` element within the&#xA;`&lt;select&gt;` element are populated from the objects in the `Element.Select`&apos;s&#xA;`content` property. The underlying data object of the selected `&lt;option&gt;` is&#xA;stored in the `Element.Select`&apos;s `value` property.&#xA;  &#xA;## The Content Property (array of strings)&#xA;  &#xA;The simplest version of an `Ember.Select` takes an array of strings as its&#xA;`content` property. The string will be used as both the `value` property and&#xA;the inner text of each `&lt;option&gt;` element inside the rendered `&lt;select&gt;`.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  names: [&quot;Yehuda&quot;, &quot;Tom&quot;]&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{view &quot;select&quot; content=names}}&#xA;```&#xA;  &#xA;Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option value=&quot;Yehuda&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;Tom&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```&#xA;  &#xA;You can control which `&lt;option&gt;` is selected through the `Ember.Select`&apos;s&#xA;`value` property:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  selectedName: &apos;Tom&apos;,&#xA;  names: [&quot;Yehuda&quot;, &quot;Tom&quot;]&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{view &quot;select&quot; content=names value=selectedName}}&#xA;```&#xA;  &#xA;Would result in the following HTML with the `&lt;option&gt;` for &apos;Tom&apos; selected:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option value=&quot;Yehuda&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;Tom&quot; selected=&quot;selected&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```&#xA;  &#xA;A user interacting with the rendered `&lt;select&gt;` to choose &quot;Yehuda&quot; would&#xA;update the value of `selectedName` to &quot;Yehuda&quot;.&#xA;  &#xA;## The Content Property (array of Objects)&#xA;  &#xA;An `Ember.Select` can also take an array of JavaScript or Ember objects as&#xA;its `content` property.&#xA;  &#xA;When using objects you need to tell the `Ember.Select` which property should&#xA;be accessed on each object to supply the `value` attribute of the `&lt;option&gt;`&#xA;and which property should be used to supply the element text.&#xA;  &#xA;The `optionValuePath` option is used to specify the path on each object to&#xA;the desired property for the `value` attribute. The `optionLabelPath`&#xA;specifies the path on each object to the desired property for the&#xA;element&apos;s text. Both paths must reference each object itself as `content`:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  programmers: [&#xA;    {firstName: &quot;Yehuda&quot;, id: 1},&#xA;    {firstName: &quot;Tom&quot;,    id: 2}&#xA;  ]&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{view &quot;select&quot;&#xA;       content=programmers&#xA;       optionValuePath=&quot;content.id&quot;&#xA;       optionLabelPath=&quot;content.firstName&quot;}}&#xA;```&#xA;  &#xA;Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option value=&quot;1&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;2&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```&#xA;  &#xA;The `value` attribute of the selected `&lt;option&gt;` within an `Ember.Select`&#xA;can be bound to a property on another object:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  programmers: [&#xA;    {firstName: &quot;Yehuda&quot;, id: 1},&#xA;    {firstName: &quot;Tom&quot;,    id: 2}&#xA;  ],&#xA;  currentProgrammer: {&#xA;    id: 2&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{view &quot;select&quot;&#xA;       content=programmers&#xA;       optionValuePath=&quot;content.id&quot;&#xA;       optionLabelPath=&quot;content.firstName&quot;&#xA;       value=currentProgrammer.id}}&#xA;```&#xA;  &#xA;Would result in the following HTML with a selected option:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option value=&quot;1&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```&#xA;  &#xA;Interacting with the rendered element by selecting the first option&#xA;(&apos;Yehuda&apos;) will update the `id` of `currentProgrammer`&#xA;to match the `value` property of the newly selected `&lt;option&gt;`.&#xA;  &#xA;Alternatively, you can control selection through the underlying objects&#xA;used to render each object by binding the `selection` option. When the selected&#xA;`&lt;option&gt;` is changed, the property path provided to `selection`&#xA;will be updated to match the content object of the rendered `&lt;option&gt;`&#xA;element:&#xA;  &#xA;```javascript&#xA;  &#xA;var yehuda = {firstName: &quot;Yehuda&quot;, id: 1, bff4eva: &apos;tom&apos;}&#xA;var tom = {firstName: &quot;Tom&quot;, id: 2, bff4eva: &apos;yehuda&apos;};&#xA;  &#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  selectedPerson: tom,&#xA;  programmers: [ yehuda, tom ]&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{view &quot;select&quot;&#xA;       content=programmers&#xA;       optionValuePath=&quot;content.id&quot;&#xA;       optionLabelPath=&quot;content.firstName&quot;&#xA;       selection=selectedPerson}}&#xA;```&#xA;  &#xA;Would result in the following HTML with a selected option:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option value=&quot;1&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```&#xA;  &#xA;Interacting with the rendered element by selecting the first option&#xA;(&apos;Yehuda&apos;) will update the `selectedPerson` to match the object of&#xA;the newly selected `&lt;option&gt;`. In this case it is the first object&#xA;in the `programmers`&#xA;  &#xA;## Supplying a Prompt&#xA;  &#xA;A `null` value for the `Ember.Select`&apos;s `value` or `selection` property&#xA;results in there being no `&lt;option&gt;` with a `selected` attribute:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  selectedProgrammer: null,&#xA;  programmers: [&quot;Yehuda&quot;, &quot;Tom&quot;]&#xA;});&#xA;```&#xA;  &#xA;``` handlebars&#xA;{{view &quot;select&quot;&#xA;       content=programmers&#xA;       value=selectedProgrammer&#xA;}}&#xA;```&#xA;  &#xA;Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option value=&quot;Yehuda&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;Tom&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```&#xA;  &#xA;Although `selectedProgrammer` is `null` and no `&lt;option&gt;`&#xA;has a `selected` attribute the rendered HTML will display the&#xA;first item as though it were selected. You can supply a string&#xA;value for the `Ember.Select` to display when there is no selection&#xA;with the `prompt` option:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  selectedProgrammer: null,&#xA;  programmers: [ &quot;Yehuda&quot;, &quot;Tom&quot; ]&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{view &quot;select&quot;&#xA;       content=programmers&#xA;       value=selectedProgrammer&#xA;       prompt=&quot;Please select a name&quot;&#xA;}}&#xA;```&#xA;  &#xA;Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;select class=&quot;ember-select&quot;&gt;&#xA;  &lt;option&gt;Please select a name&lt;/option&gt;&#xA;  &lt;option value=&quot;Yehuda&quot;&gt;Yehuda&lt;/option&gt;&#xA;  &lt;option value=&quot;Tom&quot;&gt;Tom&lt;/option&gt;&#xA;&lt;/select&gt;&#xA;```" ilk="class" name="Select">
          <variable attributes="property public" citdl="Boolean" doc="The `multiple` attribute of the select element. Indicates whether multiple&#xA;options can be selected." name="Select" />
          <variable attributes="property public" citdl="Boolean" doc="The `disabled` attribute of the select element. Indicates whether&#xA;the element is disabled from interactions." name="Select" />
          <variable attributes="property public" citdl="Boolean" doc="The `required` attribute of the select element. Indicates whether&#xA;a selected option is required for form validation." name="Select" />
          <variable attributes="property public" citdl="Array" doc="The list of options.&#xA; If `optionLabelPath` and `optionValuePath` are not overridden, this should&#xA;be a list of strings, which will serve simultaneously as labels and values.&#xA; Otherwise, this should be a list of objects. For instance:&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA;var App.MySelect = Ember.Select.extend({&#xA;  content: Ember.A([&#xA;      { id: 1, firstName: &apos;Yehuda&apos; },&#xA;      { id: 2, firstName: &apos;Tom&apos; }&#xA;    ]),&#xA;  optionLabelPath: &apos;content.firstName&apos;,&#xA;  optionValuePath: &apos;content.id&apos;&#xA;});&#xA;```" name="Select" />
          <variable attributes="property public" citdl="Object or Array" doc="When `multiple` is `false`, the element of `content` that is currently&#xA;selected, if any.&#xA; When `multiple` is `true`, an array of such elements." name="Select" />
          <variable attributes="property public" citdl="String" doc="In single selection mode (when `multiple` is `false`), value can be used to&#xA;get the current selection&apos;s value or set the selection by its value.&#xA; It is not currently supported in multiple selection mode." name="Select" />
          <variable attributes="property public" citdl="String" doc="If given, a top-most dummy option will be rendered to serve as a user&#xA;prompt." name="Select" />
          <variable attributes="property public" citdl="String" doc="The path of the option labels. See [content](/api/classes/Ember.Select.html#property_content)." name="Select" />
          <variable attributes="property public" citdl="String" doc="The path of the option values. See [content](/api/classes/Ember.Select.html#property_content)." name="Select" />
          <variable attributes="property public" citdl="String" doc="The path of the option group.&#xA;When this property is used, `content` should be sorted by `optionGroupPath`." name="Select" />
          <variable attributes="property public" citdl="Ember.View" doc="The view class for optgroup." name="Select" />
          <variable attributes="property private" citdl="Ember.View" doc="The view class for option." name="Select" />
        </scope>
        <scope classrefs="Ember.Object" ilk="class" name="Service" />
        <scope doc="Defines string helper methods including string formatting and localization.&#xA;Unless `Ember.EXTEND_PROTOTYPES.String` is `false` these methods will also be&#xA;added to the `String.prototype` as well." ilk="class" name="String">
          <scope attributes="public" doc="Mark a string as safe for unescaped output with Ember templates. If you&#xA;return HTML from a helper, use this function to&#xA;ensure Ember&apos;s rendering layer does not escape the HTML.&#xA;  &#xA;```javascript&#xA;Ember.String.htmlSafe(&apos;&lt;div&gt;someString&lt;/div&gt;&apos;)&#xA;```" ilk="function" name="htmlSafe" returns="Handlebars.SafeString" signature="htmlSafe() =&gt; Handlebars.SafeString" />
          <scope attributes="public" doc="Apply formatting options to the string. This will look for occurrences&#xA;of &quot;%@&quot; in your string and substitute them with the arguments you pass into&#xA;this method. If you want to control the specific order of replacement,&#xA;you can add a number after the key as well to indicate which argument&#xA;you want to insert.&#xA; Ordered insertions are most useful when building loc strings where values&#xA;you need to insert may appear in different orders.&#xA; ```javascript&#xA;&quot;Hello %@ %@&quot;.fmt(&apos;John&apos;, &apos;Doe&apos;);     // &quot;Hello John Doe&quot;&#xA;&quot;Hello %@2, %@1&quot;.fmt(&apos;John&apos;, &apos;Doe&apos;);  // &quot;Hello Doe, John&quot;&#xA;```" ilk="function" name="fmt" returns="String" signature="fmt(str,formats) =&gt; String">
            <variable citdl="String" doc="The string to format" ilk="argument" name="str" />
            <variable citdl="Array" doc="An array of parameters to interpolate into string." ilk="argument" name="formats" />
          </scope>
          <scope attributes="public" doc="Formats the passed string, but first looks up the string in the localized&#xA;strings hash. This is a convenient way to localize text. See&#xA;`Ember.String.fmt()` for more information on formatting.&#xA; Note that it is traditional but not required to prefix localized string&#xA;keys with an underscore or other character so you can easily identify&#xA;localized strings.&#xA; ```javascript&#xA;Ember.STRINGS = {&#xA;  &apos;_Hello World&apos;: &apos;Bonjour le monde&apos;,&#xA;  &apos;_Hello %@ %@&apos;: &apos;Bonjour %@ %@&apos;&#xA;};&#xA; Ember.String.loc(&quot;_Hello World&quot;);  // &apos;Bonjour le monde&apos;;&#xA;Ember.String.loc(&quot;_Hello %@ %@&quot;, [&quot;John&quot;, &quot;Smith&quot;]);  // &quot;Bonjour John Smith&quot;;&#xA;```" ilk="function" name="loc" returns="String" signature="loc(str,formats) =&gt; String">
            <variable citdl="String" doc="The string to format" ilk="argument" name="str" />
            <variable citdl="Array" doc="Optional array of parameters to interpolate into string." ilk="argument" name="formats" />
          </scope>
          <scope attributes="public" doc="Splits a string into separate units separated by spaces, eliminating any&#xA;empty strings in the process. This is a convenience method for split that&#xA;is mostly useful when applied to the `String.prototype`.&#xA; ```javascript&#xA;Ember.String.w(&quot;alpha beta gamma&quot;).forEach(function(key) {&#xA;  console.log(key);&#xA;});&#xA; // &gt; alpha&#xA;// &gt; beta&#xA;// &gt; gamma&#xA;```" ilk="function" name="w" returns="Array" signature="w(str) =&gt; Array">
            <variable citdl="String" doc="The string to split" ilk="argument" name="str" />
          </scope>
          <scope attributes="public" doc="Converts a camelized string into all lower case separated by underscores.&#xA; ```javascript&#xA;&apos;innerHTML&apos;.decamelize();           // &apos;inner_html&apos;&#xA;&apos;action_name&apos;.decamelize();        // &apos;action_name&apos;&#xA;&apos;css-class-name&apos;.decamelize();     // &apos;css-class-name&apos;&#xA;&apos;my favorite items&apos;.decamelize();  // &apos;my favorite items&apos;&#xA;```" ilk="function" name="decamelize" returns="String" signature="decamelize(str) =&gt; String">
            <variable citdl="String" doc="The string to decamelize." ilk="argument" name="str" />
          </scope>
          <scope attributes="public" doc="Replaces underscores, spaces, or camelCase with dashes.&#xA; ```javascript&#xA;&apos;innerHTML&apos;.dasherize();          // &apos;inner-html&apos;&#xA;&apos;action_name&apos;.dasherize();        // &apos;action-name&apos;&#xA;&apos;css-class-name&apos;.dasherize();     // &apos;css-class-name&apos;&#xA;&apos;my favorite items&apos;.dasherize();  // &apos;my-favorite-items&apos;&#xA;&apos;privateDocs/ownerInvoice&apos;.dasherize(); // &apos;private-docs/owner-invoice&apos;&#xA;```" ilk="function" name="dasherize" returns="String" signature="dasherize(str) =&gt; String">
            <variable citdl="String" doc="The string to dasherize." ilk="argument" name="str" />
          </scope>
          <scope attributes="public" doc="Returns the lowerCamelCase form of a string.&#xA; ```javascript&#xA;&apos;innerHTML&apos;.camelize();          // &apos;innerHTML&apos;&#xA;&apos;action_name&apos;.camelize();        // &apos;actionName&apos;&#xA;&apos;css-class-name&apos;.camelize();     // &apos;cssClassName&apos;&#xA;&apos;my favorite items&apos;.camelize();  // &apos;myFavoriteItems&apos;&#xA;&apos;My Favorite Items&apos;.camelize();  // &apos;myFavoriteItems&apos;&#xA;&apos;private-docs/owner-invoice&apos;.camelize(); // &apos;privateDocs/ownerInvoice&apos;&#xA;```" ilk="function" name="camelize" returns="String" signature="camelize(str) =&gt; String">
            <variable citdl="String" doc="The string to camelize." ilk="argument" name="str" />
          </scope>
          <scope attributes="public" doc="Returns the UpperCamelCase form of a string.&#xA; ```javascript&#xA;&apos;innerHTML&apos;.classify();          // &apos;InnerHTML&apos;&#xA;&apos;action_name&apos;.classify();        // &apos;ActionName&apos;&#xA;&apos;css-class-name&apos;.classify();     // &apos;CssClassName&apos;&#xA;&apos;my favorite items&apos;.classify();  // &apos;MyFavoriteItems&apos;&#xA;&apos;private-docs/owner-invoice&apos;.classify(); // &apos;PrivateDocs/OwnerInvoice&apos;&#xA;```" ilk="function" name="classify" returns="String" signature="classify(str) =&gt; String">
            <variable citdl="String" doc="the string to classify" ilk="argument" name="str" />
          </scope>
          <scope attributes="public" doc="More general than decamelize. Returns the lower\_case\_and\_underscored&#xA;form of a string.&#xA; ```javascript&#xA;&apos;innerHTML&apos;.underscore();          // &apos;inner_html&apos;&#xA;&apos;action_name&apos;.underscore();        // &apos;action_name&apos;&#xA;&apos;css-class-name&apos;.underscore();     // &apos;css_class_name&apos;&#xA;&apos;my favorite items&apos;.underscore();  // &apos;my_favorite_items&apos;&#xA;&apos;privateDocs/ownerInvoice&apos;.underscore(); // &apos;private_docs/owner_invoice&apos;&#xA;```" ilk="function" name="underscore" returns="String" signature="underscore(str) =&gt; String">
            <variable citdl="String" doc="The string to underscore." ilk="argument" name="str" />
          </scope>
          <scope attributes="public" doc="Returns the Capitalized form of a string&#xA; ```javascript&#xA;&apos;innerHTML&apos;.capitalize()         // &apos;InnerHTML&apos;&#xA;&apos;action_name&apos;.capitalize()       // &apos;Action_name&apos;&#xA;&apos;css-class-name&apos;.capitalize()    // &apos;Css-class-name&apos;&#xA;&apos;my favorite items&apos;.capitalize() // &apos;My favorite items&apos;&#xA;&apos;privateDocs/ownerInvoice&apos;.capitalize(); // &apos;PrivateDocs/ownerInvoice&apos;&#xA;```" ilk="function" name="capitalize" returns="String" signature="capitalize(str) =&gt; String">
            <variable citdl="String" doc="The string to capitalize." ilk="argument" name="str" />
          </scope>
        </scope>
        <scope classrefs="Ember.Mixin" doc="`Ember.TargetActionSupport` is a mixin that can be included in a class&#xA;to add a `triggerAction` method with semantics similar to the Handlebars&#xA;`{{action}}` helper. In normal Ember usage, the `{{action}}` helper is&#xA;usually the best choice. This mixin is most often useful when you are&#xA;doing more complex event handling in View objects.&#xA;&#xA;See also `Ember.ViewTargetActionSupport`, which has&#xA;view-aware defaults for target and actionContext." ilk="class" name="TargetActionSupport">
          <scope attributes="private" doc="Send an `action` with an `actionContext` to a `target`. The action, actionContext&#xA;and target will be retrieved from properties of the object. For example:&#xA; ```javascript&#xA;App.SaveButtonView = Ember.View.extend(Ember.TargetActionSupport, {&#xA;  target: Ember.computed.alias(&apos;controller&apos;),&#xA;  action: &apos;save&apos;,&#xA;  actionContext: Ember.computed.alias(&apos;context&apos;),&#xA;  click: function() {&#xA;    this.triggerAction(); // Sends the `save` action, along with the current context&#xA;                          // to the current controller&#xA;  }&#xA;});&#xA;```&#xA; The `target`, `action`, and `actionContext` can be provided as properties of&#xA;an optional object argument to `triggerAction` as well.&#xA; ```javascript&#xA;App.SaveButtonView = Ember.View.extend(Ember.TargetActionSupport, {&#xA;  click: function() {&#xA;    this.triggerAction({&#xA;      action: &apos;save&apos;,&#xA;      target: this.get(&apos;controller&apos;),&#xA;      actionContext: this.get(&apos;context&apos;)&#xA;    }); // Sends the `save` action, along with the current context&#xA;        // to the current controller&#xA;  }&#xA;});&#xA;```&#xA; The `actionContext` defaults to the object you are mixing `TargetActionSupport` into.&#xA;But `target` and `action` must be specified either as properties or with the argument&#xA;to `triggerAction`, or a combination:&#xA; ```javascript&#xA;App.SaveButtonView = Ember.View.extend(Ember.TargetActionSupport, {&#xA;  target: Ember.computed.alias(&apos;controller&apos;),&#xA;  click: function() {&#xA;    this.triggerAction({&#xA;      action: &apos;save&apos;&#xA;    }); // Sends the `save` action, along with a reference to `this`,&#xA;        // to the current controller&#xA;  }&#xA;});&#xA;```" ilk="function" name="triggerAction" returns="Boolean" signature="triggerAction(opts) =&gt; Boolean">
            <variable citdl="Object" doc="(optional, with the optional keys action, target and/or actionContext)" ilk="argument" name="opts" />
          </scope>
        </scope>
        <scope ilk="class" name="TemplateRenderingSupport">
          <scope attributes="private" doc="Called on your view when it should push strings of HTML into a&#xA;`Ember.RenderBuffer`. Most users will want to override the `template`&#xA;or `templateName` properties instead of this method.&#xA; By default, `Ember.View` will look for a function in the `template`&#xA;property and invoke it with the value of `context`. The value of&#xA;`context` will be the view&apos;s controller unless you override it." ilk="function" name="renderBlock" signature="renderBlock(buffer)">
            <variable citdl="Ember.RenderBuffer" doc="The render buffer" ilk="argument" name="buffer" />
          </scope>
        </scope>
        <scope ilk="namespace" name="Templates">
          <scope ilk="class" name="helpers">
            <scope attributes="public" doc="Concatenates input params together.&#xA;  &#xA;Example:&#xA;  &#xA;```handlebars&#xA;{{some-component name=(concat firstName &quot; &quot; lastName)}}&#xA;  &#xA;{{! would pass name=&quot;&lt;first name value&gt; &lt;last name value&gt;&quot; to the component}}&#xA;```" ilk="function" name="concat" signature="concat()" />
            <scope attributes="public" doc="The `{{each-in}}` helper loops over properties on an object. It is unbound,&#xA;in that new (or removed) properties added to the target object will not be&#xA;rendered.&#xA;  &#xA;For example, given a `user` object that looks like:&#xA;  &#xA;```javascript&#xA;{&#xA;  &quot;name&quot;: &quot;Shelly Sails&quot;,&#xA;  &quot;age&quot;: 42&#xA;}&#xA;```&#xA;  &#xA;This template would display all properties on the `user`&#xA;object in a list:&#xA;  &#xA;```handlebars&#xA;&lt;ul&gt;&#xA;{{#each-in user as |key value|}}&#xA;  &lt;li&gt;{{key}}: {{value}}&lt;/li&gt;&#xA;{{/each-in}}&#xA;&lt;/ul&gt;&#xA;```&#xA;  &#xA;Outputting their name and age." ilk="function" name="each-in" signature="each-in()" />
            <scope attributes="public" doc="The `{{#each}}` helper loops over elements in a collection. It is an extension&#xA;of the base Handlebars `{{#each}}` helper.&#xA;  &#xA;The default behavior of `{{#each}}` is to yield its inner block once for every&#xA;item in an array passing the item as the first block parameter.&#xA;  &#xA;```javascript&#xA;var developers = [{name: &apos;Yehuda&apos;},{name: &apos;Tom&apos;}, {name: &apos;Paul&apos;}];&#xA;```&#xA;  &#xA;```handlebars&#xA;{{#each developers key=&quot;name&quot; as |person|}}&#xA;  {{person.name}}&#xA;  {{! `this` is whatever it was outside the #each }}&#xA;{{/each}}&#xA;```&#xA;  &#xA;The same rules apply to arrays of primitives.&#xA;  &#xA;```javascript&#xA;var developerNames = [&apos;Yehuda&apos;, &apos;Tom&apos;, &apos;Paul&apos;]&#xA;```&#xA;  &#xA;```handlebars&#xA;{{#each developerNames key=&quot;@index&quot; as |name|}}&#xA;  {{name}}&#xA;{{/each}}&#xA;```&#xA;  &#xA;During iteration, the index of each item in the array is provided as a second block parameter.&#xA;  &#xA;```handlebars&#xA;&lt;ul&gt;&#xA;  {{#each people as |person index|}}&#xA;    &lt;li&gt;Hello, {{person.name}}! You&apos;re number {{index}} in line&lt;/li&gt;&#xA;  {{/each}}&#xA;&lt;/ul&gt;&#xA;```&#xA;  &#xA;### Specifying Keys&#xA;  &#xA;The `key` option is used to tell Ember how to determine if the array being&#xA;iterated over with `{{#each}}` has changed between renders. By helping Ember&#xA;detect that some elements in the array are the same, DOM elements can be&#xA;re-used, significantly improving rendering speed.&#xA;  &#xA;For example, here&apos;s the `{{#each}}` helper with its `key` set to `id`:&#xA;  &#xA;```handlebars&#xA;{{#each model key=&quot;id&quot; as |item|}}&#xA;{{/each}}&#xA;```&#xA;  &#xA;When this `{{#each}}` re-renders, Ember will match up the previously rendered&#xA;items (and reorder the generated DOM elements) based on each item&apos;s `id`&#xA;property.&#xA;  &#xA;By default the item&apos;s own reference is used.&#xA;  &#xA;### {{else}} condition&#xA;  &#xA;`{{#each}}` can have a matching `{{else}}`. The contents of this block will render&#xA;if the collection is empty.&#xA;  &#xA;```handlebars&#xA;{{#each developers as |person|}}&#xA;  {{person.name}}&#xA;{{else}}&#xA;  &lt;p&gt;Sorry, nobody is available for this task.&lt;/p&gt;&#xA;{{/each}}&#xA;```" ilk="function" name="each" signature="each()" />
            <scope attributes="public" doc="Use the `{{hash}}` helper to create a hash to pass as an option to your&#xA;components. This is specially useful for contextual components where you can&#xA;just yield a hash:&#xA;   &#xA;```handlebars&#xA;{{yield (hash&#xA;   name=&apos;Sarah&apos;&#xA;   title=office&#xA;)}}&#xA;```&#xA;   &#xA;Would result in an object such as:&#xA;   &#xA;```js&#xA;{ name: &apos;Sarah&apos;, title: this.get(&apos;office&apos;) }&#xA;```&#xA;   &#xA;Where the `title` is bound to updates of the `office` property." ilk="function" name="hash" returns="Object" signature="hash(options) =&gt; Object">
              <variable citdl="Object" ilk="argument" name="options" />
            </scope>
            <scope attributes="public" doc="Use the `if` block helper to conditionally render a block depending on a&#xA;property. If the property is &quot;falsey&quot;, for example: `false`, `undefined`,&#xA;   `null`, `&quot;&quot;`, `0`, `NaN` or an empty array, the block will not be rendered.&#xA;  &#xA;   ```handlebars&#xA;{{! will not render if foo is falsey}}&#xA;{{#if foo}}&#xA;  Welcome to the {{foo.bar}}&#xA;{{/if}}&#xA;```&#xA;  &#xA;You can also specify a template to show if the property is falsey by using&#xA;the `else` helper.&#xA;  &#xA;```handlebars&#xA;{{!Is it raining outside?}}&#xA;{{#if isRaining}}&#xA;  Yes, grab an umbrella!&#xA;{{else}}&#xA;  No, it&apos;s lovely outside!&#xA;{{/if}}&#xA;```&#xA;  &#xA;You are also able to combine `else` and `if` helpers to create more complex&#xA;conditional logic.&#xA;  &#xA;```handlebars&#xA;{{#if isMorning}}&#xA;  Good morning&#xA;{{else if isAfternoon}}&#xA;  Good afternoon&#xA;{{else}}&#xA;  Good night&#xA;{{/if}}&#xA;```&#xA;  &#xA;You can use `if` inline to conditionally render a single property or string.&#xA;This helper acts like a ternary operator. If the first property is truthy,&#xA;the second argument will be displayed, if not, the third argument will be&#xA;displayed&#xA;  &#xA;```handlebars&#xA;{{if useLongGreeting &quot;Hello&quot; &quot;Hi&quot;}} Dave&#xA;```&#xA;  &#xA;Finally, you can use the `if` helper inside another helper as a subexpression.&#xA;  &#xA;```handlebars&#xA;{{some-component height=(if isBig &quot;100&quot; &quot;10&quot;)}}&#xA;```" ilk="function" name="if" signature="if()" />
            <scope attributes="public" doc="The `unless` helper is the inverse of the `if` helper. Its block will be&#xA;rendered if the expression contains a falsey value.  All forms of the `if`&#xA;helper can also be used with `unless`." ilk="function" name="unless" signature="unless()" />
            <scope attributes="public" doc="Calls [Ember.String.loc](/api/classes/Ember.String.html#method_loc) with the&#xA;provided string. This is a convenient way to localize text within a template.&#xA;For example:&#xA;  &#xA;```javascript&#xA;Ember.STRINGS = {&#xA;  &apos;_welcome_&apos;: &apos;Bonjour&apos;&#xA;};&#xA;```&#xA;  &#xA;```handlebars&#xA;&lt;div class=&apos;message&apos;&gt;&#xA;  {{loc &apos;_welcome_&apos;}}&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;```html&#xA;&lt;div class=&apos;message&apos;&gt;&#xA;  Bonjour&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;See [Ember.String.loc](/api/classes/Ember.String.html#method_loc) for how to&#xA;set up localized string references." ilk="function" name="loc" signature="loc(str)">
              <variable citdl="String" doc="The string to format" ilk="argument" name="str" />
            </scope>
            <scope attributes="public" doc="`log` allows you to output the value of variables in the current rendering&#xA;context. `log` also accepts primitive types such as strings or numbers.&#xA;  &#xA;```handlebars&#xA;{{log &quot;myVariable:&quot; myVariable }}&#xA;```" ilk="function" name="log" signature="log(values)">
              <variable citdl="*" ilk="argument" name="values" />
            </scope>
            <scope attributes="public" doc="Use the `{{with}}` helper when you want to alias a property to a new name. This is helpful&#xA;for semantic clarity as it allows you to retain default scope or to reference a property from another&#xA;`{{with}}` block.&#xA;  &#xA;If the aliased property is &quot;falsey&quot;, for example: `false`, `undefined` `null`, `&quot;&quot;`, `0`, NaN or&#xA;an empty array, the block will not be rendered.&#xA;  &#xA;```handlebars&#xA;{{! Will only render if user.posts contains items}}&#xA;{{#with user.posts as |blogPosts|}}&#xA;  &lt;div class=&quot;notice&quot;&gt;&#xA;    There are {{blogPosts.length}} blog posts written by {{user.name}}.&#xA;  &lt;/div&gt;&#xA;  {{#each blogPosts as |post|}}&#xA;    &lt;li&gt;{{post.title}}&lt;/li&gt;&#xA;  {{/each}}&#xA;{{/with}}&#xA;```&#xA;  &#xA;Without the `as` operator, it would be impossible to reference `user.name` in the example above.&#xA;  &#xA;NOTE: The alias should not reuse a name from the bound property path.&#xA;For example: `{{#with foo.bar as |foo|}}` is not supported because it attempts to alias using&#xA;the first part of the property path, `foo`. Instead, use `{{#with foo.bar as |baz|}}`." ilk="function" name="with" returns="String" signature="with(options) =&gt; String">
              <variable citdl="Object" ilk="argument" name="options" />
            </scope>
            <variable attributes="property private" name="helpers" />
            <scope attributes="public" doc="`{{collection}}` is a template helper for adding instances of&#xA;`Ember.CollectionView` to a template. See [Ember.CollectionView](/api/classes/Ember.CollectionView.html)&#xA; for additional information on how a `CollectionView` functions.&#xA;  &#xA;`{{collection}}`&apos;s primary use is as a block helper with a `contentBinding`&#xA;option pointing towards an `Ember.Array`-compatible object. An `Ember.View`&#xA;instance will be created for each item in its `content` property. Each view&#xA;will have its own `content` property set to the appropriate item in the&#xA;collection.&#xA;  &#xA;The provided block will be applied as the template for each item&apos;s view.&#xA;  &#xA;Given an empty `&lt;body&gt;` the following template:&#xA;  &#xA;```handlebars&#xA;{{! application.hbs }}&#xA;{{#collection content=model}}&#xA;  Hi {{view.content.name}}&#xA;{{/collection}}&#xA;```&#xA;  &#xA;And the following application code&#xA;  &#xA;```javascript&#xA;App = Ember.Application.create();&#xA;App.ApplicationRoute = Ember.Route.extend({&#xA;  model: function() {&#xA;    return [{name: &apos;Yehuda&apos;},{name: &apos;Tom&apos;},{name: &apos;Peter&apos;}];&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;The following HTML will result:&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Hi Yehuda&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Hi Tom&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Hi Peter&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;### Non-block version of collection&#xA;  &#xA;If you provide an `itemViewClass` option that has its own `template` you may&#xA;omit the block.&#xA;  &#xA;The following template:&#xA;  &#xA;```handlebars&#xA;{{! application.hbs }}&#xA;{{collection content=model itemViewClass=&quot;an-item&quot;}}&#xA;```&#xA;  &#xA;And application code&#xA;  &#xA;```javascript&#xA;App = Ember.Application.create();&#xA;App.ApplicationRoute = Ember.Route.extend({&#xA;  model: function() {&#xA;    return [{name: &apos;Yehuda&apos;},{name: &apos;Tom&apos;},{name: &apos;Peter&apos;}];&#xA;  }&#xA;});&#xA;  &#xA;App.AnItemView = Ember.View.extend({&#xA;  template: Ember.Handlebars.compile(&quot;Greetings {{view.content.name}}&quot;)&#xA;});&#xA;```&#xA;  &#xA;Will result in the HTML structure below&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view&quot;&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Greetings Yehuda&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Greetings Tom&lt;/div&gt;&#xA;  &lt;div class=&quot;ember-view&quot;&gt;Greetings Peter&lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;### Specifying a CollectionView subclass&#xA;  &#xA;By default the `{{collection}}` helper will create an instance of&#xA;`Ember.CollectionView`. You can supply a `Ember.CollectionView` subclass to&#xA;the helper by passing it as the first argument:&#xA;  &#xA;```handlebars&#xA;{{#collection &quot;my-custom-collection&quot; content=model}}&#xA;  Hi {{view.content.name}}&#xA;{{/collection}}&#xA;```&#xA;  &#xA;This example would look for the class `App.MyCustomCollection`.&#xA;  &#xA;### Forwarded `item.*`-named Options&#xA;  &#xA;As with the `{{view}}`, helper options passed to the `{{collection}}` will be&#xA;set on the resulting `Ember.CollectionView` as properties. Additionally,&#xA;options prefixed with `item` will be applied to the views rendered for each&#xA;item (note the camelcasing):&#xA;  &#xA;```handlebars&#xA;{{#collection content=model&#xA;              itemTagName=&quot;p&quot;&#xA;              itemClassNames=&quot;greeting&quot;}}&#xA;  Howdy {{view.content.name}}&#xA;{{/collection}}&#xA;```&#xA;  &#xA;Will result in the following HTML structure:&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view&quot;&gt;&#xA;  &lt;p class=&quot;ember-view greeting&quot;&gt;Howdy Yehuda&lt;/p&gt;&#xA;  &lt;p class=&quot;ember-view greeting&quot;&gt;Howdy Tom&lt;/p&gt;&#xA;  &lt;p class=&quot;ember-view greeting&quot;&gt;Howdy Peter&lt;/p&gt;&#xA;&lt;/div&gt;&#xA;```" ilk="function" name="collection" signature="collection()" />
            <scope attributes="public" doc="The `{{component}}` helper lets you add instances of `Ember.Component` to a&#xA;template. See [Ember.Component](/api/classes/Ember.Component.html) for&#xA;additional information on how a `Component` functions.&#xA;`{{component}}`&apos;s primary use is for cases where you want to dynamically&#xA;change which type of component is rendered as the state of your application&#xA;changes. The provided block will be applied as the template for the component.&#xA;Given an empty `&lt;body&gt;` the following template:&#xA;  &#xA;```handlebars&#xA;{{! application.hbs }}&#xA;{{component infographicComponentName}}&#xA;```&#xA;  &#xA;And the following application code:&#xA;  &#xA;```javascript&#xA;export default Ember.Controller.extend({&#xA;  infographicComponentName: computed(&apos;isMarketOpen&apos;, {&#xA;    get() {&#xA;      if (this.get(&apos;isMarketOpen&apos;)) {&#xA;        return &apos;live-updating-chart&apos;;&#xA;      } else {&#xA;        return &apos;market-close-summary&apos;;&#xA;      }&#xA;    }&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;The `live-updating-chart` component will be appended when `isMarketOpen` is&#xA;`true`, and the `market-close-summary` component will be appended when&#xA;`isMarketOpen` is `false`. If the value changes while the app is running,&#xA;the component will be automatically swapped out accordingly.&#xA;Note: You should not use this helper when you are consistently rendering the same&#xA;component. In that case, use standard component syntax, for example:&#xA;  &#xA;```handlebars&#xA;{{! application.hbs }}&#xA;{{live-updating-chart}}&#xA;```&#xA;  &#xA;## Nested Usage&#xA;  &#xA;The `component` helper can be used to package a component path with initial attrs.&#xA;The included attrs can then be merged during the final invocation.&#xA;  &#xA;For example, given a `person-form` component with the following template:&#xA;  &#xA;```handlebars&#xA;{{yield (hash&#xA;    nameInput=(component &quot;my-input-component&quot; value=model.name placeholder=&quot;First Name&quot;))}}&#xA;```&#xA;  &#xA;The following snippet:&#xA;  &#xA;```&#xA;{{#person-form as |form|}}&#xA;  {{component form.nameInput placeholder=&quot;Username&quot;}}&#xA;{{/person-form}}&#xA;```&#xA;  &#xA;would output an input whose value is already bound to `model.name` and `placeholder`&#xA;is &quot;Username&quot;." ilk="function" name="component" signature="component()" />
            <scope attributes="public" doc="Execute the `debugger` statement in the current template&apos;s context.&#xA;  &#xA;```handlebars&#xA;{{debugger}}&#xA;```&#xA;  &#xA;When using the debugger helper you will have access to a `get` function. This&#xA;function retrieves values available in the context of the template.&#xA;For example, if you&apos;re wondering why a value `{{foo}}` isn&apos;t rendering as&#xA;expected within a template, you could place a `{{debugger}}` statement and,&#xA;when the `debugger;` breakpoint is hit, you can attempt to retrieve this value:&#xA;  &#xA;```&#xA;&gt; get(&apos;foo&apos;)&#xA;```&#xA;  &#xA;`get` is also aware of keywords. So in this situation&#xA;  &#xA;```handlebars&#xA;{{#each items as |item|}}&#xA;  {{debugger}}&#xA;{{/each}}&#xA;```&#xA;  &#xA;You&apos;ll be able to get values from the current item:&#xA;  &#xA;```&#xA;&gt; get(&apos;item.name&apos;)&#xA;```&#xA;  &#xA;You can also access the context of the view to make sure it is the object that&#xA;you expect:&#xA;  &#xA;```&#xA;&gt; context&#xA;```" ilk="function" name="debugger" signature="debugger()" />
            <scope attributes="public" doc="Dynamically look up a property on an object. The second argument to `{{get}}`&#xA;should have a string value, although it can be bound.&#xA;  &#xA;For example, these two usages are equivilent:&#xA;  &#xA;```handlebars&#xA;{{person.height}}&#xA;{{get person &quot;height&quot;}}&#xA;```&#xA;  &#xA;If there were several facts about a person, the `{{get}}` helper can dynamically&#xA;pick one:&#xA;  &#xA;```handlebars&#xA;{{get person factName}}&#xA;```&#xA;  &#xA;For a more complex example, this template would allow the user to switch&#xA;between showing the user&apos;s height and weight with a click:&#xA;  &#xA;```handlebars&#xA;{{get person factName}}&#xA;&lt;button {{action (mut factName) &quot;height&quot;}}&gt;Show height&lt;/button&gt;&#xA;&lt;button {{action (mut factName) &quot;weight&quot;}}&gt;Show weight&lt;/button&gt;&#xA;```&#xA;  &#xA;The `{{get}}` helper can also respect mutable values itself. For example:&#xA;  &#xA;```handlebars&#xA;{{input value=(mut (get person factName)) type=&quot;text&quot;}}&#xA;&lt;button {{action (mut factName) &quot;height&quot;}}&gt;Show height&lt;/button&gt;&#xA;&lt;button {{action (mut factName) &quot;weight&quot;}}&gt;Show weight&lt;/button&gt;&#xA;```&#xA;  &#xA;Would allow the user to swap what fact is being displayed, and also edit&#xA;that fact via a two-way mutable binding." ilk="function" name="get" signature="get()" />
            <scope attributes="public" doc="The `{{input}}` helper lets you create an HTML `&lt;input /&gt;` component.&#xA;It causes an `Ember.TextField` component to be rendered.  For more info,&#xA;see the [Ember.TextField](/api/classes/Ember.TextField.html) docs and&#xA;the [templates guide](http://emberjs.com/guides/templates/input-helpers/).&#xA;  &#xA;```handlebars&#xA;{{input value=&quot;987&quot;}}&#xA;```&#xA;  &#xA;renders as:&#xA;  &#xA;```HTML&#xA;&lt;input type=&quot;text&quot; value=&quot;987&quot; /&gt;&#xA;```&#xA;  &#xA;### Text field&#xA;  &#xA;If no `type` option is specified, a default of type &apos;text&apos; is used.&#xA;  &#xA;Many of the standard HTML attributes may be passed to this helper.&#xA;  &#xA;&lt;table&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`readonly`&lt;/td&gt;&lt;td&gt;`required`&lt;/td&gt;&lt;td&gt;`autofocus`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`value`&lt;/td&gt;&lt;td&gt;`placeholder`&lt;/td&gt;&lt;td&gt;`disabled`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`size`&lt;/td&gt;&lt;td&gt;`tabindex`&lt;/td&gt;&lt;td&gt;`maxlength`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`name`&lt;/td&gt;&lt;td&gt;`min`&lt;/td&gt;&lt;td&gt;`max`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`pattern`&lt;/td&gt;&lt;td&gt;`accept`&lt;/td&gt;&lt;td&gt;`autocomplete`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`autosave`&lt;/td&gt;&lt;td&gt;`formaction`&lt;/td&gt;&lt;td&gt;`formenctype`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`formmethod`&lt;/td&gt;&lt;td&gt;`formnovalidate`&lt;/td&gt;&lt;td&gt;`formtarget`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`height`&lt;/td&gt;&lt;td&gt;`inputmode`&lt;/td&gt;&lt;td&gt;`multiple`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`step`&lt;/td&gt;&lt;td&gt;`width`&lt;/td&gt;&lt;td&gt;`form`&lt;/td&gt;&lt;/tr&gt;&#xA;  &lt;tr&gt;&lt;td&gt;`selectionDirection`&lt;/td&gt;&lt;td&gt;`spellcheck`&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;  &#xA;  &#xA;When set to a quoted string, these values will be directly applied to the HTML&#xA;element. When left unquoted, these values will be bound to a property on the&#xA;template&apos;s current rendering context (most typically a controller instance).&#xA;  &#xA;  &#xA;A very common use of this helper is to bind the `value` of an input to an Object&apos;s attribute:&#xA;  &#xA;```handlebars&#xA;Search:&#xA;{{input value=searchWord}}&#xA;```&#xA;  &#xA;In this example, the inital value in the `&lt;input /&gt;` will be set to the value of `searchWord`.&#xA;If the user changes the text, the value of `searchWord` will also be updated.&#xA;  &#xA;### Actions&#xA;The helper can send multiple actions based on user events.&#xA;The action property defines the action which is sent when&#xA;the user presses the return key.&#xA;  &#xA;```handlebars&#xA;{{input action=&quot;submit&quot;}}&#xA;```&#xA;  &#xA;The helper allows some user events to send actions.&#xA;  &#xA;* `enter`&#xA;* `insert-newline`&#xA;* `escape-press`&#xA;* `focus-in`&#xA;* `focus-out`&#xA;* `key-press`&#xA;* `key-up`&#xA;  &#xA;  &#xA;For example, if you desire an action to be sent when the input is blurred,&#xA;you only need to setup the action name to the event name property.&#xA;  &#xA;```handlebars&#xA;{{input focus-out=&quot;alertMessage&quot;}}&#xA;```&#xA;  &#xA;See more about [Text Support Actions](/api/classes/Ember.TextField.html)&#xA;  &#xA;  &#xA;### Extending `Ember.TextField`&#xA;  &#xA;Internally, `{{input type=&quot;text&quot;}}` creates an instance of `Ember.TextField`, passing&#xA;arguments from the helper to `Ember.TextField`&apos;s `create` method. You can extend the&#xA;capabilities of text inputs in your applications by reopening this class. For example,&#xA;if you are building a Bootstrap project where `data-*` attributes are used, you&#xA;can add one to the `TextField`&apos;s `attributeBindings` property:&#xA;  &#xA;  &#xA;```javascript&#xA;Ember.TextField.reopen({&#xA;  attributeBindings: [&apos;data-error&apos;]&#xA;});&#xA;```&#xA;  &#xA;Keep in mind when writing `Ember.TextField` subclasses that `Ember.TextField`&#xA;itself extends `Ember.Component`. Expect isolated component semantics, not&#xA;legacy 1.x view semantics (like `controller` being present).&#xA;  &#xA;See more about [Ember components](/api/classes/Ember.Component.html)&#xA;  &#xA;  &#xA;### Checkbox&#xA;  &#xA;Checkboxes are special forms of the `{{input}}` helper.  To create a `&lt;checkbox /&gt;`:&#xA;  &#xA;```handlebars&#xA;Emberize Everything:&#xA;{{input type=&quot;checkbox&quot; name=&quot;isEmberized&quot; checked=isEmberized}}&#xA;```&#xA;  &#xA;This will bind checked state of this checkbox to the value of `isEmberized`  -- if either one changes,&#xA;it will be reflected in the other.&#xA;  &#xA;  &#xA;The following HTML attributes can be set via the helper:&#xA;  &#xA;* `checked`&#xA;* `disabled`&#xA;* `tabindex`&#xA;* `indeterminate`&#xA;* `name`&#xA;* `autofocus`&#xA;* `form`&#xA;  &#xA;  &#xA;### Extending `Ember.Checkbox`&#xA;  &#xA;Internally, `{{input type=&quot;checkbox&quot;}}` creates an instance of `Ember.Checkbox`, passing&#xA;arguments from the helper to `Ember.Checkbox`&apos;s `create` method. You can extend the&#xA;capablilties of checkbox inputs in your applications by reopening this class. For example,&#xA;if you wanted to add a css class to all checkboxes in your application:&#xA;  &#xA;```javascript&#xA;Ember.Checkbox.reopen({&#xA;  classNames: [&apos;my-app-checkbox&apos;]&#xA;});&#xA;```" ilk="function" name="input" signature="input(options)">
              <variable citdl="Hash" ilk="argument" name="options" />
            </scope>
            <scope attributes="public" doc="The `mut` helper lets you __clearly specify__ that a child `Component` can update the&#xA;(mutable) value passed to it, which will __change the value of the parent component__.&#xA;  &#xA;This is very helpful for passing mutable values to a `Component` of any size, but&#xA;critical to understanding the logic of a large/complex `Component`.&#xA;  &#xA;To specify that a parameter is mutable, when invoking the child `Component`:&#xA;  &#xA;```handlebars&#xA;&lt;my-child child-click-count={{mut totalClicks}} /&gt;&#xA;```&#xA;  &#xA;The child `Component` can then modify the parent&apos;s value as needed:&#xA;  &#xA;```javascript&#xA;// my-child.js&#xA;export default Component.extend({&#xA;  click: function() {&#xA;    this.attrs.childClickCount.update(this.attrs.childClickCount.value + 1);&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;See a [2.0 blog post](http://emberjs.com/blog/2015/05/10/run-up-to-two-oh.html#toc_the-code-mut-code-helper) for&#xA;additional information on using `{{mut}}`." ilk="function" name="mut" signature="mut(attr)">
              <variable citdl="Object" doc="the &quot;two-way&quot; attribute that can be modified." ilk="argument" name="attr" />
            </scope>
            <scope attributes="public" doc="The `{{outlet}}` helper lets you specify where a child routes will render in&#xA;your template. An important use of the `{{outlet}}` helper is in your&#xA;application&apos;s `application.hbs` file:&#xA;  &#xA;```handlebars&#xA;{{! app/templates/application.hbs }}&#xA;  &#xA;&lt;!-- header content goes here, and will always display --&gt;&#xA;{{my-header}}&#xA;  &#xA;&lt;div class=&quot;my-dynamic-content&quot;&gt;&#xA;  &lt;!-- this content will change based on the current route, which depends on the current URL --&gt;&#xA;  {{outlet}}&#xA;&lt;/div&gt;&#xA;  &#xA;&lt;!-- footer content goes here, and will always display --&gt;&#xA;{{my-footer}}&#xA;```&#xA;  &#xA;See [templates guide](http://emberjs.com/guides/templates/the-application-template/) for&#xA;additional information on using `{{outlet}}` in `application.hbs`.&#xA;  &#xA;You may also specify a name for the `{{outlet}}`, which is useful when using more than one&#xA;`{{outlet}}` in a template:&#xA;  &#xA;```handlebars&#xA;{{outlet &quot;menu&quot;}}&#xA;{{outlet &quot;sidebar&quot;}}&#xA;{{outlet &quot;main&quot;}}&#xA;```&#xA;  &#xA;Your routes can then render into a specific one of these `outlet`s by specifying the `outlet`&#xA;attribute in your `renderTemplate` function:&#xA;  &#xA;```javascript&#xA;// app/routes/menu.js&#xA;  &#xA;export default Ember.Route.extend({&#xA;  renderTemplate() {&#xA;    this.render({ outlet: &apos;menu&apos; });&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;See the [routing guide](http://emberjs.com/guides/routing/rendering-a-template/) for more&#xA;information on how your `route` interacts with the `{{outlet}}` helper.&#xA;  &#xA;Note: Your content __will not render__ if there isn&apos;t an `{{outlet}}` for it." ilk="function" name="outlet" signature="outlet(name)">
              <variable citdl="String" ilk="argument" name="name" />
            </scope>
            <scope attributes="public" doc="The `partial` helper renders another template without&#xA;changing the template context:&#xA;  &#xA;```handlebars&#xA;{{foo}}&#xA;{{partial &quot;nav&quot;}}&#xA;```&#xA;  &#xA;The above example template will render a template named&#xA;&quot;_nav&quot;, which has the same context as the parent template&#xA;it&apos;s rendered into, so if the &quot;_nav&quot; template also referenced&#xA;`{{foo}}`, it would print the same thing as the `{{foo}}`&#xA;in the above example.&#xA;  &#xA;If a &quot;_nav&quot; template isn&apos;t found, the `partial` helper will&#xA;fall back to a template named &quot;nav&quot;.&#xA;  &#xA;### Bound template names&#xA;  &#xA;The parameter supplied to `partial` can also be a path&#xA;to a property containing a template name, e.g.:&#xA;  &#xA;```handlebars&#xA;{{partial someTemplateName}}&#xA;```&#xA;  &#xA;The above example will look up the value of `someTemplateName`&#xA;on the template context (e.g. a controller) and use that&#xA;value as the name of the template to render. If the resolved&#xA;value is falsy, nothing will be rendered. If `someTemplateName`&#xA;changes, the partial will be re-rendered using the new template&#xA;name." ilk="function" name="partial" signature="partial(partialName)">
              <variable citdl="String" doc="the name of the template to render minus the leading underscore" ilk="argument" name="partialName" />
            </scope>
            <scope attributes="public" doc="`{{textarea}}` inserts a new instance of `&lt;textarea&gt;` tag into the template.&#xA;The attributes of `{{textarea}}` match those of the native HTML tags as&#xA;closely as possible.&#xA;  &#xA;The following HTML attributes can be set:&#xA;  &#xA;  * `value`&#xA;  * `name`&#xA;  * `rows`&#xA;  * `cols`&#xA;  * `placeholder`&#xA;  * `disabled`&#xA;  * `maxlength`&#xA;  * `tabindex`&#xA;  * `selectionEnd`&#xA;  * `selectionStart`&#xA;  * `selectionDirection`&#xA;  * `wrap`&#xA;  * `readonly`&#xA;  * `autofocus`&#xA;  * `form`&#xA;  * `spellcheck`&#xA;  * `required`&#xA;  &#xA;When set to a quoted string, these value will be directly applied to the HTML&#xA;element. When left unquoted, these values will be bound to a property on the&#xA;template&apos;s current rendering context (most typically a controller instance).&#xA;  &#xA;Unbound:&#xA;  &#xA;```handlebars&#xA;{{textarea value=&quot;Lots of static text that ISN&apos;T bound&quot;}}&#xA;```&#xA;  &#xA;Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;textarea class=&quot;ember-text-area&quot;&gt;&#xA;  Lots of static text that ISN&apos;T bound&#xA;&lt;/textarea&gt;&#xA;```&#xA;  &#xA;Bound:&#xA;  &#xA;In the following example, the `writtenWords` property on `App.ApplicationController`&#xA;will be updated live as the user types &apos;Lots of text that IS bound&apos; into&#xA;the text area of their browser&apos;s window.&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  writtenWords: &quot;Lots of text that IS bound&quot;&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{textarea value=writtenWords}}&#xA;```&#xA;  &#xA; Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;textarea class=&quot;ember-text-area&quot;&gt;&#xA;  Lots of text that IS bound&#xA;&lt;/textarea&gt;&#xA;```&#xA;  &#xA;If you wanted a one way binding between the text area and a div tag&#xA;somewhere else on your screen, you could use `Ember.computed.oneWay`:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  writtenWords: &quot;Lots of text that IS bound&quot;,&#xA;  outputWrittenWords: Ember.computed.oneWay(&quot;writtenWords&quot;)&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{textarea value=writtenWords}}&#xA;  &#xA;&lt;div&gt;&#xA;  {{outputWrittenWords}}&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;Would result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;textarea class=&quot;ember-text-area&quot;&gt;&#xA;  Lots of text that IS bound&#xA;&lt;/textarea&gt;&#xA;  &#xA;&lt;-- the following div will be updated in real time as you type --&gt;&#xA;  &#xA;&lt;div&gt;&#xA;  Lots of text that IS bound&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;Finally, this example really shows the power and ease of Ember when two&#xA;properties are bound to eachother via `Ember.computed.alias`. Type into&#xA;either text area box and they&apos;ll both stay in sync. Note that&#xA;`Ember.computed.alias` costs more in terms of performance, so only use it when&#xA;your really binding in both directions:&#xA;  &#xA;```javascript&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  writtenWords: &quot;Lots of text that IS bound&quot;,&#xA;  twoWayWrittenWords: Ember.computed.alias(&quot;writtenWords&quot;)&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{textarea value=writtenWords}}&#xA;{{textarea value=twoWayWrittenWords}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;textarea id=&quot;ember1&quot; class=&quot;ember-text-area&quot;&gt;&#xA;  Lots of text that IS bound&#xA;&lt;/textarea&gt;&#xA;  &#xA;&lt;-- both updated in real time --&gt;&#xA;  &#xA;&lt;textarea id=&quot;ember2&quot; class=&quot;ember-text-area&quot;&gt;&#xA;  Lots of text that IS bound&#xA;&lt;/textarea&gt;&#xA;```&#xA;  &#xA;### Actions&#xA;  &#xA;The helper can send multiple actions based on user events.&#xA;  &#xA;The action property defines the action which is send when&#xA;the user presses the return key.&#xA;  &#xA;```handlebars&#xA;{{input action=&quot;submit&quot;}}&#xA;```&#xA;  &#xA;The helper allows some user events to send actions.&#xA;  &#xA;  * `enter`&#xA;  * `insert-newline`&#xA;  * `escape-press`&#xA;  * `focus-in`&#xA;  * `focus-out`&#xA;  * `key-press`&#xA;  &#xA;For example, if you desire an action to be sent when the input is blurred,&#xA;you only need to setup the action name to the event name property.&#xA;  &#xA;```handlebars&#xA;{{textarea focus-in=&quot;alertMessage&quot;}}&#xA;```&#xA;  &#xA;See more about [Text Support Actions](/api/classes/Ember.TextArea.html)&#xA;  &#xA;### Extension&#xA;  &#xA;Internally, `{{textarea}}` creates an instance of `Ember.TextArea`, passing&#xA;arguments from the helper to `Ember.TextArea`&apos;s `create` method. You can&#xA;extend the capabilities of text areas in your application by reopening this&#xA;class. For example, if you are building a Bootstrap project where `data-*`&#xA;attributes are used, you can globally add support for a `data-*` attribute&#xA;on all `{{textarea}}`s&apos; in your app by reopening `Ember.TextArea` or&#xA;`Ember.TextSupport` and adding it to the `attributeBindings` concatenated&#xA;property:&#xA;  &#xA;```javascript&#xA;Ember.TextArea.reopen({&#xA;  attributeBindings: [&apos;data-error&apos;]&#xA;});&#xA;```&#xA;  &#xA;Keep in mind when writing `Ember.TextArea` subclasses that `Ember.TextArea`&#xA;itself extends `Ember.Component`. Expect isolated component semantics, not&#xA;legacy 1.x view semantics (like `controller` being present).&#xA;  &#xA;See more about [Ember components](/api/classes/Ember.Component.html)" ilk="function" name="textarea" signature="textarea(options)">
              <variable citdl="Hash" ilk="argument" name="options" />
            </scope>
            <scope attributes="public" doc="The `{{unbound}}` helper disconnects the one-way binding of a property,&#xA;essentially freezing its value at the moment of rendering. For example,&#xA;in this example the display of the variable `name` will not change even&#xA;if it is set with a new value:&#xA;  &#xA;```handlebars&#xA;{{unbound name}}&#xA;```&#xA;  &#xA;Like any helper, the `unbound` helper can accept a nested helper expression.&#xA;This allows for custom helpers to be rendered unbound:&#xA;  &#xA;```handlebars&#xA;{{unbound (some-custom-helper)}}&#xA;{{unbound (capitalize name)}}&#xA;{{! You can use any helper, including unbound, in a nested expression }}&#xA;{{capitalize (unbound name)}}&#xA;```&#xA;  &#xA;The `unbound` helper only accepts a single argument, and it return an&#xA;unbound value." ilk="function" name="unbound" signature="unbound()" />
            <scope attributes="public" doc="`{{view}}` inserts a new instance of an `Ember.View` into a template passing its&#xA;options to the `Ember.View`&apos;s `create` method and using the supplied block as&#xA;the view&apos;s own template.&#xA;  &#xA;An empty `&lt;body&gt;` and the following template:&#xA;  &#xA;```handlebars&#xA;A span:&#xA;{{#view tagName=&quot;span&quot;}}&#xA;  hello.&#xA;{{/view}}&#xA;```&#xA;  &#xA;Will result in HTML structure:&#xA;  &#xA;```html&#xA;&lt;body&gt;&#xA;  &lt;!-- Note: the handlebars template script&#xA;       also results in a rendered Ember.View&#xA;       which is the outer &lt;div&gt; here --&gt;&#xA;  &#xA;  &lt;div class=&quot;ember-view&quot;&gt;&#xA;    A span:&#xA;    &lt;span id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;&#xA;      Hello.&#xA;    &lt;/span&gt;&#xA;  &lt;/div&gt;&#xA;&lt;/body&gt;&#xA;```&#xA;  &#xA;### `parentView` setting&#xA;  &#xA;The `parentView` property of the new `Ember.View` instance created through&#xA;`{{view}}` will be set to the `Ember.View` instance of the template where&#xA;`{{view}}` was called.&#xA;  &#xA;```javascript&#xA;aView = Ember.View.create({&#xA;  template: Ember.Handlebars.compile(&quot;{{#view}} my parent: {{parentView.elementId}} {{/view}}&quot;)&#xA;});&#xA;  &#xA;aView.appendTo(&apos;body&apos;);&#xA;```&#xA;  &#xA;Will result in HTML structure:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;&#xA;  &lt;div id=&quot;ember2&quot; class=&quot;ember-view&quot;&gt;&#xA;    my parent: ember1&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;### Setting CSS id and class attributes&#xA;  &#xA;The HTML `id` attribute can be set on the `{{view}}`&apos;s resulting element with&#xA;the `id` option. This option will _not_ be passed to `Ember.View.create`.&#xA;  &#xA;```handlebars&#xA;{{#view tagName=&quot;span&quot; id=&quot;a-custom-id&quot;}}&#xA;  hello.&#xA;{{/view}}&#xA;```&#xA;  &#xA;Results in the following HTML structure:&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view&quot;&gt;&#xA;  &lt;span id=&quot;a-custom-id&quot; class=&quot;ember-view&quot;&gt;&#xA;    hello.&#xA;  &lt;/span&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;The HTML `class` attribute can be set on the `{{view}}`&apos;s resulting element&#xA;with the `class` or `classNameBindings` options. The `class` option will&#xA;directly set the CSS `class` attribute and will not be passed to&#xA;`Ember.View.create`. `classNameBindings` will be passed to `create` and use&#xA;`Ember.View`&apos;s class name binding functionality:&#xA;  &#xA;```handlebars&#xA;{{#view tagName=&quot;span&quot; class=&quot;a-custom-class&quot;}}&#xA;  hello.&#xA;{{/view}}&#xA;```&#xA;  &#xA;Results in the following HTML structure:&#xA;  &#xA;```html&#xA;&lt;div class=&quot;ember-view&quot;&gt;&#xA;  &lt;span id=&quot;ember2&quot; class=&quot;ember-view a-custom-class&quot;&gt;&#xA;    hello.&#xA;  &lt;/span&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;### Supplying a different view class&#xA;  &#xA;`{{view}}` can take an optional first argument before its supplied options to&#xA;specify a path to a custom view class.&#xA;  &#xA;```handlebars&#xA;{{#view &quot;custom&quot;}}{{! will look up App.CustomView }}&#xA;  hello.&#xA;{{/view}}&#xA;```&#xA;  &#xA;The first argument can also be a relative path accessible from the current&#xA;context.&#xA;  &#xA;```javascript&#xA;MyApp = Ember.Application.create({});&#xA;MyApp.OuterView = Ember.View.extend({&#xA;  innerViewClass: Ember.View.extend({&#xA;    classNames: [&apos;a-custom-view-class-as-property&apos;]&#xA;  }),&#xA;  template: Ember.Handlebars.compile(&apos;{{#view view.innerViewClass}} hi {{/view}}&apos;)&#xA;});&#xA;  &#xA;MyApp.OuterView.create().appendTo(&apos;body&apos;);&#xA;```&#xA;  &#xA;Will result in the following HTML:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;&#xA;  &lt;div id=&quot;ember2&quot; class=&quot;ember-view a-custom-view-class-as-property&quot;&gt;&#xA;    hi&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;### Blockless use&#xA;  &#xA;If you supply a custom `Ember.View` subclass that specifies its own template&#xA;or provide a `templateName` option to `{{view}}` it can be used without&#xA;supplying a block. Attempts to use both a `templateName` option and supply a&#xA;block will throw an error.&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create();&#xA;App.WithTemplateDefinedView = Ember.View.extend({&#xA;  templateName: &apos;defined-template&apos;&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{! application.hbs }}&#xA;{{view &apos;with-template-defined&apos;}}&#xA;```&#xA;  &#xA;```handlebars&#xA;{{! defined-template.hbs }}&#xA;Some content for the defined template view.&#xA;```&#xA;  &#xA;### `viewName` property&#xA;  &#xA;You can supply a `viewName` option to `{{view}}`. The `Ember.View` instance&#xA;will be referenced as a property of its parent view by this name.&#xA;  &#xA;```javascript&#xA;aView = Ember.View.create({&#xA;  template: Ember.Handlebars.compile(&apos;{{#view viewName=&quot;aChildByName&quot;}} hi {{/view}}&apos;)&#xA;});&#xA;  &#xA;aView.appendTo(&apos;body&apos;);&#xA;aView.get(&apos;aChildByName&apos;) // the instance of Ember.View created by {{view}} helper&#xA;```" ilk="function" name="view" signature="view()" />
            <variable attributes="property private" name="helpers" />
            <scope attributes="public" doc="This is a helper to be used in conjunction with the link-to helper.&#xA;It will supply url query parameters to the target route.&#xA;  &#xA;Example&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;posts&apos; (query-params direction=&quot;asc&quot;)}}Sort{{/link-to}}&#xA;```" ilk="function" name="query-params" returns="Object" signature="query-params(hash) =&gt; Object">
              <variable citdl="Object" doc="takes a hash of query parameters" ilk="argument" name="hash" />
            </scope>
            <scope attributes="public" doc="The `{{action}}` helper provides a way to pass triggers for behavior (usually&#xA;just a function) between components, and into components from controllers.&#xA;  &#xA;### Passing functions with the action helper&#xA;  &#xA;There are three contexts an action helper can be used in. The first two&#xA;contexts to discuss are attribute context, and Handlebars value context.&#xA;  &#xA;```handlebars&#xA;{{! An example of attribute context }}&#xA;&lt;div onclick={{action &quot;save&quot;}}&gt;&lt;/div&gt;&#xA;{{! Examples of Handlebars value context }}&#xA;{{input on-input=(action &quot;save&quot;)}}&#xA;{{yield (action &quot;refreshData&quot;) andAnotherParam}}&#xA;```&#xA;  &#xA;In these contexts,&#xA;the helper is called a &quot;closure action&quot; helper. It&apos;s behavior is simple:&#xA;If passed a function name, read that function off the `actions` property&#xA;of the current context. Once that function is read (or if a function was&#xA;passed), create a closure over that function and any arguments.&#xA;  &#xA;The resulting value of an action helper used this way is simply a function.&#xA;For example with this attribute context example:&#xA;  &#xA;```handlebars&#xA;{{! An example of attribute context }}&#xA;&lt;div onclick={{action &quot;save&quot;}}&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;The resulting template render logic would be:&#xA;  &#xA;```js&#xA;var div = document.createElement(&apos;div&apos;);&#xA;var actionFunction = (function(context){&#xA;  return function() {&#xA;    return context.actions.save.apply(context, arguments);&#xA;  };&#xA;})(context);&#xA;div.onclick = actionFunction;&#xA;```&#xA;  &#xA;Thus when the div is clicked, the action on that context is called.&#xA;Because the `actionFunction` is just a function, closure actions can be&#xA;passed between components the still execute in the correct context.&#xA;  &#xA;Here is an example action handler on a component:&#xA;  &#xA;```js&#xA;export default Ember.Component.extend({&#xA;  actions: {&#xA;    save() {&#xA;      this.get(&apos;model&apos;).save();&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;Actions are always looked up on the `actions` property of the current context.&#xA;This avoids collisions in the naming of common actions, such as `destroy`.&#xA;  &#xA;Two options can be passed to the `action` helper when it is used in this way.&#xA;  &#xA;* `target=someProperty` will look to `someProperty` instead of the current&#xA;  context for the `actions` hash. This can be useful when targetting a&#xA;  service for actions.&#xA;* `value=&quot;target.value&quot;` will read the path `target.value` off the first&#xA;  argument to the action when it is called and rewrite the first argument&#xA;  to be that value. This is useful when attaching actions to event listeners.&#xA;  &#xA;### Invoking an action&#xA;  &#xA;Closure actions curry both their scope and any arguments. When invoked, any&#xA;additional arguments are added to the already curried list.&#xA;  &#xA;Actions should be invoked using the [sendAction](/api/classes/Ember.Component.html#method_sendAction)&#xA;method. The first argument to `sendAction` is the action to be called, and&#xA;additional arguments are passed to the action function. This has interesting&#xA;properties combined with currying of arguments. For example:&#xA;  &#xA;```js&#xA;export default Ember.Component.extend({&#xA;  actions: {&#xA;    // Usage {{input on-input=(action (action &apos;setName&apos; model) value=&quot;target.value&quot;)}}&#xA;    setName(model, name) {&#xA;      model.set(&apos;name&apos;, name);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;The first argument (`model`) was curried over, and the run-time argument (`event`)&#xA;becomes a second argument. Action calls be nested this way because each simply&#xA;returns a function. Any function can be passed to the `{{action` helper, including&#xA;other actions.&#xA;  &#xA;Actions invoked with `sendAction` have the same currying behavior as demonstrated&#xA;with `on-input` above. For example:&#xA;  &#xA;```js&#xA;export default Ember.Component.extend({&#xA;  actions: {&#xA;    setName(model, name) {&#xA;      model.set(&apos;name&apos;, name);&#xA;    }&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{my-input submit=(action &apos;setName&apos; model)}}&#xA;```&#xA;  &#xA;```js&#xA;// app/components/my-component.js&#xA;export default Ember.Component.extend({&#xA;  click() {&#xA;    // Note that model is not passed, it was curried in the template&#xA;    this.sendAction(&apos;submit&apos;, &apos;bob&apos;);&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;### Attaching actions to DOM&#xA;  &#xA;The third context the `{{action` helper can be used in we call &quot;element space&quot;.&#xA;For example:&#xA;  &#xA;```handlebars&#xA;{{! An example of element space }}&#xA;&lt;div {{action &quot;save&quot;}}&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;Used this way, the `{{action}}` helper provides a useful shortcut for&#xA;registering an HTML element within a template for a single DOM event and&#xA;forwarding that interaction to the template&apos;s context (controller or component).&#xA;  &#xA;If the context of a template is a controller, actions used this way will&#xA;bubble to routes when the controller does not implement the specified action.&#xA;Once an action hits a route, it will bubble through the route hierarchy.&#xA;  &#xA;### Event Propagation&#xA;  &#xA;`{{action` helpers called in element space can control event bubbling.&#xA;  &#xA;Events triggered through the action helper will automatically have&#xA;`.preventDefault()` called on them. You do not need to do so in your event&#xA;handlers. If you need to allow event propagation (to handle file inputs for&#xA;example) you can supply the `preventDefault=false` option to the `{{action}}` helper:&#xA;  &#xA;```handlebars&#xA;&lt;div {{action &quot;sayHello&quot; preventDefault=false}}&gt;&#xA;  &lt;input type=&quot;file&quot; /&gt;&#xA;  &lt;input type=&quot;checkbox&quot; /&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;To disable bubbling, pass `bubbles=false` to the helper:&#xA;  &#xA;```handlebars&#xA;&lt;button {{action &apos;edit&apos; post bubbles=false}}&gt;Edit&lt;/button&gt;&#xA;```&#xA;  &#xA;If you need the default handler to trigger you should either register your&#xA;own event handler, or use event methods on your view class. See [Ember.View](/api/classes/Ember.View.html)&#xA;&apos;Responding to Browser Events&apos; for more information.&#xA;  &#xA;### Specifying DOM event type&#xA;  &#xA;`{{action` helpers called in element space can specify an event type.&#xA;  &#xA;By default the `{{action}}` helper registers for DOM `click` events. You can&#xA;supply an `on` option to the helper to specify a different DOM event name:&#xA;  &#xA;```handlebars&#xA;&lt;div {{action &quot;anActionName&quot; on=&quot;doubleClick&quot;}}&gt;&#xA;  click me&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;See [Event Names](/api/classes/Ember.View.html#toc_event-names) for a list of&#xA;acceptable DOM event names.&#xA;  &#xA;### Specifying whitelisted modifier keys&#xA;  &#xA;`{{action` helpers called in element space can specify modifier keys.&#xA;  &#xA;By default the `{{action}}` helper will ignore click event with pressed modifier&#xA;keys. You can supply an `allowedKeys` option to specify which keys should not be ignored.&#xA;  &#xA;```handlebars&#xA;&lt;div {{action &quot;anActionName&quot; allowedKeys=&quot;alt&quot;}}&gt;&#xA;  click me&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;This way the `{{action}}` will fire when clicking with the alt key pressed down.&#xA;  &#xA;Alternatively, supply &quot;any&quot; to the `allowedKeys` option to accept any combination of modifier keys.&#xA;  &#xA;```handlebars&#xA;&lt;div {{action &quot;anActionName&quot; allowedKeys=&quot;any&quot;}}&gt;&#xA;  click me with any key pressed&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;### Specifying a Target&#xA;  &#xA;A `target` option can be provided to the helper to change&#xA;which object will receive the method call. This option must be a path&#xA;to an object, accessible in the current context:&#xA;  &#xA;```handlebars&#xA;{{! app/templates/application.hbs }}&#xA;&lt;div {{action &quot;anActionName&quot; target=someService}}&gt;&#xA;  click me&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;```javascript&#xA;// app/controllers/application.js&#xA;export default Ember.Controller.extend({&#xA;  someService: Ember.inject.service()&#xA;});&#xA;```" ilk="function" name="action" signature="action()" />
            <scope attributes="public" doc="Calling ``{{render}}`` from within a template will insert another&#xA;template that matches the provided name. The inserted template will&#xA;access its properties on its own controller (rather than the controller&#xA;of the parent template).&#xA;If a view class with the same name exists, the view class also will be used.&#xA;Note: A given controller may only be used *once* in your app in this manner.&#xA;A singleton instance of the controller will be created for you.&#xA;Example:&#xA;  &#xA;```javascript&#xA;App.NavigationController = Ember.Controller.extend({&#xA;  who: &quot;world&quot;&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;&lt;!-- navigation.hbs --&gt;&#xA;Hello, {{who}}.&#xA;```&#xA;  &#xA;```handlebars&#xA;&lt;!-- application.hbs --&gt;&#xA;&lt;h1&gt;My great app&lt;/h1&gt;&#xA;{{render &quot;navigation&quot;}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;h1&gt;My great app&lt;/h1&gt;&#xA;&lt;div class=&apos;ember-view&apos;&gt;&#xA;  Hello, world.&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;Optionally you may provide a second argument: a property path&#xA;that will be bound to the `model` property of the controller.&#xA;If a `model` property path is specified, then a new instance of the&#xA;controller will be created and `{{render}}` can be used multiple times&#xA;with the same name.&#xA;  &#xA;For example if you had this `author` template.&#xA;  &#xA;```handlebars&#xA;&lt;div class=&quot;author&quot;&gt;&#xA;  Written by {{firstName}} {{lastName}}.&#xA;  Total Posts: {{postCount}}&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;You could render it inside the `post` template using the `render` helper.&#xA;  &#xA;```handlebars&#xA;&lt;div class=&quot;post&quot;&gt;&#xA;  &lt;h1&gt;{{title}}&lt;/h1&gt;&#xA;  &lt;div&gt;{{body}}&lt;/div&gt;&#xA;  {{render &quot;author&quot; author}}&#xA;&lt;/div&gt;&#xA;```" ilk="function" name="render" returns="String" signature="render(name,context,options) =&gt; String">
              <variable citdl="String" ilk="argument" name="name" />
              <variable citdl="Object?" ilk="argument" name="context" />
              <variable citdl="Hash" ilk="argument" name="options" />
            </scope>
            <scope attributes="public" doc="The `{{link-to}}` component renders a link to the supplied&#xA;`routeName` passing an optionally supplied model to the&#xA;route as its `model` context of the route. The block&#xA;for `{{link-to}}` becomes the innerHTML of the rendered&#xA;element:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos;}}&#xA;  Great Hamster Photos&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;You can also use an inline form of `{{link-to}}` component by&#xA;passing the link text as the first argument&#xA;to the component:&#xA;  &#xA;```handlebars&#xA;{{link-to &apos;Great Hamster Photos&apos; &apos;photoGallery&apos;}}&#xA;```&#xA;  &#xA;Both will result in:&#xA;  &#xA;```html&#xA;&lt;a href=&quot;/hamster-photos&quot;&gt;&#xA;  Great Hamster Photos&#xA;&lt;/a&gt;&#xA;```&#xA;  &#xA;### Supplying a tagName&#xA;By default `{{link-to}}` renders an `&lt;a&gt;` element. This can&#xA;be overridden for a single use of `{{link-to}}` by supplying&#xA;a `tagName` option:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; tagName=&quot;li&quot;}}&#xA;  Great Hamster Photos&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;li&gt;&#xA;  Great Hamster Photos&#xA;&lt;/li&gt;&#xA;```&#xA;  &#xA;To override this option for your entire application, see&#xA;&quot;Overriding Application-wide Defaults&quot;.&#xA;  &#xA;### Disabling the `link-to` component&#xA;By default `{{link-to}}` is enabled.&#xA;any passed value to the `disabled` component property will disable&#xA;the `link-to` component.&#xA;  &#xA;static use: the `disabled` option:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; disabled=true}}&#xA;  Great Hamster Photos&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;dynamic use: the `disabledWhen` option:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; disabledWhen=controller.someProperty}}&#xA;  Great Hamster Photos&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;any passed value to `disabled` will disable it except `undefined`.&#xA;to ensure that only `true` disable the `link-to` component you can&#xA;override the global behaviour of `Ember.LinkComponent`.&#xA;  &#xA;```javascript&#xA;Ember.LinkComponent.reopen({&#xA;  disabled: Ember.computed(function(key, value) {&#xA;    if (value !== undefined) {&#xA;      this.set(&apos;_isDisabled&apos;, value === true);&#xA;    }&#xA;    return value === true ? get(this, &apos;disabledClass&apos;) : false;&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;see &quot;Overriding Application-wide Defaults&quot; for more.&#xA;  &#xA;### Handling `href`&#xA;`{{link-to}}` will use your application&apos;s Router to&#xA;fill the element&apos;s `href` property with a url that&#xA;matches the path to the supplied `routeName` for your&#xA;router&apos;s configured `Location` scheme, which defaults&#xA;to Ember.HashLocation.&#xA;  &#xA;### Handling current route&#xA;`{{link-to}}` will apply a CSS class name of &apos;active&apos;&#xA;when the application&apos;s current route matches&#xA;the supplied routeName. For example, if the application&apos;s&#xA;current route is &apos;photoGallery.recent&apos; the following&#xA;use of `{{link-to}}`:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery.recent&apos;}}&#xA;  Great Hamster Photos&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;will result in&#xA;  &#xA;```html&#xA;&lt;a href=&quot;/hamster-photos/this-week&quot; class=&quot;active&quot;&gt;&#xA;  Great Hamster Photos&#xA;&lt;/a&gt;&#xA;```&#xA;  &#xA;The CSS class name used for active classes can be customized&#xA;for a single use of `{{link-to}}` by passing an `activeClass`&#xA;option:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery.recent&apos; activeClass=&quot;current-url&quot;}}&#xA;  Great Hamster Photos&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;a href=&quot;/hamster-photos/this-week&quot; class=&quot;current-url&quot;&gt;&#xA;  Great Hamster Photos&#xA;&lt;/a&gt;&#xA;```&#xA;  &#xA;To override this option for your entire application, see&#xA;&quot;Overriding Application-wide Defaults&quot;.&#xA;  &#xA;### Keeping a link active for other routes&#xA;  &#xA;If you need a link to be &apos;active&apos; even when it doesn&apos;t match&#xA;the current route, you can use the `current-when` argument.&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; current-when=&apos;photos&apos;}}&#xA;  Photo Gallery&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;This may be helpful for keeping links active for:&#xA;  &#xA;* non-nested routes that are logically related&#xA;* some secondary menu approaches&#xA;* &apos;top navigation&apos; with &apos;sub navigation&apos; scenarios&#xA;  &#xA;A link will be active if `current-when` is `true` or the current&#xA;route is the route this link would transition to.&#xA;  &#xA;To match multiple routes &apos;space-separate&apos; the routes:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;gallery&apos; current-when=&apos;photos drawings paintings&apos;}}&#xA;  Art Gallery&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;### Supplying a model&#xA;An optional model argument can be used for routes whose&#xA;paths contain dynamic segments. This argument will become&#xA;the model context of the linked route:&#xA;  &#xA;```javascript&#xA;Router.map(function() {&#xA;  this.route(&quot;photoGallery&quot;, {path: &quot;hamster-photos/:photo_id&quot;});&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; aPhoto}}&#xA;  {{aPhoto.title}}&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;a href=&quot;/hamster-photos/42&quot;&gt;&#xA;  Tomster&#xA;&lt;/a&gt;&#xA;```&#xA;  &#xA;### Supplying multiple models&#xA;For deep-linking to route paths that contain multiple&#xA;dynamic segments, multiple model arguments can be used.&#xA;As the router transitions through the route path, each&#xA;supplied model argument will become the context for the&#xA;route with the dynamic segments:&#xA;  &#xA;```javascript&#xA;Router.map(function() {&#xA;  this.route(&quot;photoGallery&quot;, { path: &quot;hamster-photos/:photo_id&quot; }, function() {&#xA;    this.route(&quot;comment&quot;, {path: &quot;comments/:comment_id&quot;});&#xA;  });&#xA;});&#xA;```&#xA;This argument will become the model context of the linked route:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery.comment&apos; aPhoto comment}}&#xA;  {{comment.body}}&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;a href=&quot;/hamster-photos/42/comments/718&quot;&gt;&#xA;  A+++ would snuggle again.&#xA;&lt;/a&gt;&#xA;```&#xA;  &#xA;### Supplying an explicit dynamic segment value&#xA;If you don&apos;t have a model object available to pass to `{{link-to}}`,&#xA;an optional string or integer argument can be passed for routes whose&#xA;paths contain dynamic segments. This argument will become the value&#xA;of the dynamic segment:&#xA;  &#xA;```javascript&#xA;Router.map(function() {&#xA;  this.route(&quot;photoGallery&quot;, { path: &quot;hamster-photos/:photo_id&quot; });&#xA;});&#xA;```&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; aPhotoId}}&#xA;  {{aPhoto.title}}&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;```html&#xA;&lt;a href=&quot;/hamster-photos/42&quot;&gt;&#xA;  Tomster&#xA;&lt;/a&gt;&#xA;```&#xA;  &#xA;When transitioning into the linked route, the `model` hook will&#xA;be triggered with parameters including this passed identifier.&#xA;  &#xA;### Allowing Default Action&#xA;  &#xA;   By default the `{{link-to}}` component prevents the default browser action&#xA;   by calling `preventDefault()` as this sort of action bubbling is normally&#xA;   handled internally and we do not want to take the browser to a new URL (for&#xA;   example).&#xA;  &#xA;   If you need to override this behavior specify `preventDefault=false` in&#xA;   your template:&#xA;  &#xA;```handlebars&#xA;{{#link-to &apos;photoGallery&apos; aPhotoId preventDefault=false}}&#xA;  {{aPhotoId.title}}&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;### Overriding attributes&#xA;You can override any given property of the `Ember.LinkComponent`&#xA;that is generated by the `{{link-to}}` component by passing&#xA;key/value pairs, like so:&#xA;  &#xA;```handlebars&#xA;{{#link-to  aPhoto tagName=&apos;li&apos; title=&apos;Following this link will change your life&apos; classNames=&apos;pic sweet&apos;}}&#xA;  Uh-mazing!&#xA;{{/link-to}}&#xA;```&#xA;  &#xA;See [Ember.LinkComponent](/api/classes/Ember.LinkComponent.html) for a&#xA;complete list of overrideable properties. Be sure to also&#xA;check out inherited properties of `LinkComponent`.&#xA;  &#xA;### Overriding Application-wide Defaults&#xA;``{{link-to}}`` creates an instance of `Ember.LinkComponent`&#xA;for rendering. To override options for your entire&#xA;application, reopen `Ember.LinkComponent` and supply the&#xA;desired values:&#xA;  &#xA;``` javascript&#xA;Ember.LinkComponent.reopen({&#xA;  activeClass: &quot;is-active&quot;,&#xA;  tagName: &apos;li&apos;&#xA;})&#xA;```&#xA;  &#xA;It is also possible to override the default event in&#xA;this manner:&#xA;  &#xA;``` javascript&#xA;Ember.LinkComponent.reopen({&#xA;  eventName: &apos;customEventName&apos;&#xA;});&#xA;```" ilk="function" name="link-to" returns="String" signature="link-to(routeName,context,options) =&gt; String">
              <variable citdl="String" ilk="argument" name="routeName" />
              <variable citdl="Object" ilk="argument" name="context" />
              <variable citdl="Object" doc="Handlebars key/value pairs of options, you can override any property of Ember.LinkComponent" ilk="argument" name="options" />
            </scope>
          </scope>
        </scope>
        <scope classrefs="Ember.Component" doc="The internal class used to create textarea element when the `{{textarea}}`&#xA;helper is used.&#xA;  &#xA;See [Ember.Templates.helpers.textarea](/api/classes/Ember.Templates.helpers.html#method_textarea)  for usage details.&#xA;  &#xA;## Layout and LayoutName properties&#xA;  &#xA;Because HTML `textarea` elements do not contain inner HTML the `layout` and&#xA;`layoutName` properties will not be applied. See [Ember.View](/api/classes/Ember.View.html)&apos;s&#xA;layout section for more information." ilk="class" name="TextArea" />
        <scope classrefs="Ember.Component" doc="The internal class used to create text inputs when the `{{input}}`&#xA;    helper is used with `type` of `text`.&#xA;See [Ember.Templates.helpers.input](/api/classes/Ember.Templates.helpers.html#method_input)  for usage details.&#xA;## Layout and LayoutName properties&#xA;Because HTML `input` elements are self closing `layout` and `layoutName`&#xA;    properties will not be applied. See [Ember.View](/api/classes/Ember.View.html)&apos;s&#xA;    layout section for more information." ilk="class" name="TextField">
          <variable attributes="property public" citdl="String" doc="The `value` attribute of the input element. As the user inputs text, this&#xA;property is updated live." name="TextField" />
          <variable attributes="property public" citdl="String" doc="The `type` attribute of the input element." name="TextField" />
          <variable attributes="property public" citdl="String" doc="The `size` of the text field in characters." name="TextField" />
          <variable attributes="property public" citdl="String" doc="The `pattern` attribute of input element." name="TextField" />
          <variable attributes="property public" citdl="String" doc="The `min` attribute of input element used with `type=&quot;number&quot;` or `type=&quot;range&quot;`." name="TextField" />
          <variable attributes="property public" citdl="String" doc="The `max` attribute of input element used with `type=&quot;number&quot;` or `type=&quot;range&quot;`." name="TextField" />
        </scope>
        <scope classrefs="Ember.Mixin" doc="`TextSupport` is a shared mixin used by both `Ember.TextField` and&#xA;`Ember.TextArea`. `TextSupport` adds a number of methods that allow you to&#xA;specify a controller action to invoke when a certain event is fired on your&#xA;text field or textarea. The specifed controller action would get the current&#xA;value of the field passed in as the only argument unless the value of&#xA;the field is empty. In that case, the instance of the field itself is passed&#xA;in as the only argument.&#xA;  &#xA;Let&apos;s use the pressing of the escape key as an example. If you wanted to&#xA;invoke a controller action when a user presses the escape key while on your&#xA;field, you would use the `escape-press` attribute on your field like so:&#xA;  &#xA;```handlebars&#xA;  {{! application.hbs}}&#xA;  &#xA;  {{input escape-press=&apos;alertUser&apos;}}&#xA;```&#xA;  &#xA;```javascript&#xA;    App = Ember.Application.create();&#xA;  &#xA;    App.ApplicationController = Ember.Controller.extend({&#xA;      actions: {&#xA;        alertUser: function ( currentValue ) {&#xA;          alert( &apos;escape pressed, current value: &apos; + currentValue );&#xA;        }&#xA;      }&#xA;    });&#xA;```&#xA;  &#xA;The following chart is a visual representation of what takes place when the&#xA;escape key is pressed in this scenario:&#xA;  &#xA;```&#xA;The Template&#xA;+---------------------------+&#xA;|                           |&#xA;| escape-press=&apos;alertUser&apos;  |&#xA;|                           |          TextSupport Mixin&#xA;+----+----------------------+          +-------------------------------+&#xA;     |                                 | cancel method                 |&#xA;     |      escape button pressed      |                               |&#xA;     +-------------------------------&gt; | checks for the `escape-press` |&#xA;                                       | attribute and pulls out the   |&#xA;     +-------------------------------+ | `alertUser` value             |&#xA;     |     action name &apos;alertUser&apos;     +-------------------------------+&#xA;     |     sent to controller&#xA;     v&#xA;Controller&#xA;+------------------------------------------ +&#xA;|                                           |&#xA;|  actions: {                               |&#xA;|     alertUser: function( currentValue ){  |&#xA;|       alert( &apos;the esc key was pressed!&apos; ) |&#xA;|     }                                     |&#xA;|  }                                        |&#xA;|                                           |&#xA;+-------------------------------------------+&#xA;```&#xA;  &#xA;Here are the events that we currently support along with the name of the&#xA;attribute you would need to use on your field. To reiterate, you would use the&#xA;attribute name like so:&#xA;  &#xA;```handlebars&#xA;  {{input attribute-name=&apos;controllerAction&apos;}}&#xA;```&#xA;  &#xA;```&#xA;+--------------------+----------------+&#xA;|                    |                |&#xA;| event              | attribute name |&#xA;+--------------------+----------------+&#xA;| new line inserted  | insert-newline |&#xA;|                    |                |&#xA;| enter key pressed  | insert-newline |&#xA;|                    |                |&#xA;| cancel key pressed | escape-press   |&#xA;|                    |                |&#xA;| focusin            | focus-in       |&#xA;|                    |                |&#xA;| focusout           | focus-out      |&#xA;|                    |                |&#xA;| keypress           | key-press      |&#xA;|                    |                |&#xA;| keyup              | key-up         |&#xA;|                    |                |&#xA;| keydown            | key-down       |&#xA;+--------------------+----------------+&#xA;```" ilk="class" name="TextSupport">
          <variable attributes="property private" citdl="String" doc="The action to be sent when the user presses the return key.&#xA; This is similar to the `{{action}}` helper, but is fired when&#xA;the user presses the return key when editing a text field, and sends&#xA;the value of the field as the context." name="TextSupport" />
          <variable attributes="property private" citdl="String" doc="The event that should send the action.&#xA; Options are:&#xA; * `enter`: the user pressed enter&#xA;* `keyPress`: the user pressed a key" name="TextSupport" />
          <variable attributes="property private" citdl="Boolean" doc="Whether the `keyUp` event that triggers an `action` to be sent continues&#xA;propagating to other views.&#xA; By default, when the user presses the return key on their keyboard and&#xA;the text field has an `action` set, the action will be sent to the view&apos;s&#xA;controller and the key event will stop propagating.&#xA; If you would like parent views to receive the `keyUp` event even after an&#xA;action has been dispatched, set `bubbles` to true." name="TextSupport" />
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when either the `enter`&#xA;key is pressed or, in the case of the field being a textarea, when a newline&#xA;is inserted. To use this method, give your field an `insert-newline`&#xA;attribute. The value of that attribute should be the name of the action&#xA;in your controller that you wish to invoke.&#xA; For an example on how to use the `insert-newline` attribute, please&#xA;reference the example near the top of this file." ilk="function" name="insertNewline" signature="insertNewline(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when the escape button&#xA;is pressed. To use this method, give your field an `escape-press`&#xA;attribute. The value of that attribute should be the name of the action&#xA;in your controller that you wish to invoke.&#xA; For an example on how to use the `escape-press` attribute, please reference&#xA;the example near the top of this file." ilk="function" name="cancel" signature="cancel(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when a field receives&#xA;focus. To use this method, give your field a `focus-in` attribute. The value&#xA;of that attribute should be the name of the action in your controller&#xA;that you wish to invoke.&#xA; For an example on how to use the `focus-in` attribute, please reference the&#xA;example near the top of this file." ilk="function" name="focusIn" signature="focusIn(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when a field loses&#xA;focus. To use this method, give your field a `focus-out` attribute. The value&#xA;of that attribute should be the name of the action in your controller&#xA;that you wish to invoke.&#xA; For an example on how to use the `focus-out` attribute, please reference the&#xA;example near the top of this file." ilk="function" name="focusOut" signature="focusOut(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when a key is pressed.&#xA;To use this method, give your field a `key-press` attribute. The value of&#xA;that attribute should be the name of the action in your controller you&#xA;that wish to invoke.&#xA; For an example on how to use the `key-press` attribute, please reference the&#xA;example near the top of this file." ilk="function" name="keyPress" signature="keyPress(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when a key-up event is&#xA;fired. To use this method, give your field a `key-up` attribute. The value&#xA;of that attribute should be the name of the action in your controller&#xA;that you wish to invoke.&#xA; For an example on how to use the `key-up` attribute, please reference the&#xA;example near the top of this file." ilk="function" name="keyUp" signature="keyUp(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <scope attributes="private" doc="Allows you to specify a controller action to invoke when a key-down event is&#xA;fired. To use this method, give your field a `key-down` attribute. The value&#xA;of that attribute should be the name of the action in your controller that&#xA;you wish to invoke.&#xA; For an example on how to use the `key-down` attribute, please reference the&#xA;example near the top of this file." ilk="function" name="keyDown" signature="keyDown(event)">
            <variable citdl="Event" ilk="argument" name="event" />
          </scope>
          <variable attributes="property private" citdl="Array" doc="Array of child views. You should never edit this array directly.&#xA;Instead, use `appendChild` and `removeFromParent`." name="TextSupport" />
          <scope attributes="private" doc="Removes the child view from the parent view." ilk="function" name="removeChild" returns="Ember.View" signature="removeChild(view) =&gt; Ember.View">
            <variable citdl="Ember.View" ilk="argument" name="view" />
          </scope>
          <scope attributes="private" doc="Instantiates a view to be added to the childViews array during view&#xA;initialization. You generally will not call this method directly unless&#xA;you are overriding `createChildViews()`. Note that this method will&#xA;automatically configure the correct settings on the new view instance to&#xA;act as a child of the parent." ilk="function" name="createChildView" returns="Ember.View" signature="createChildView(viewClass,attrs) =&gt; Ember.View">
            <variable citdl="Class|String" ilk="argument" name="viewClass" />
            <variable citdl="Object" doc="Attributes to add" ilk="argument" name="attrs" />
          </scope>
          <variable attributes="property private" citdl="Object" doc="The object from which templates should access properties.&#xA; This object will be passed to the template function each time the render&#xA;method is called, but it is up to the individual function to decide what&#xA;to do with it.&#xA; By default, this will be the view&apos;s controller." name="TextSupport" />
          <variable attributes="property private" doc="Private copy of the view&apos;s template context. This can be set directly&#xA;by Handlebars without triggering the observer that causes the view&#xA;to be re-rendered.&#xA; The context of a view is looked up as follows:&#xA; 1. Supplied context (usually by Handlebars)&#xA;2. Specified controller&#xA;3. `parentView`&apos;s context (for a child of a ContainerView)&#xA; The code in Handlebars that overrides the `_context` property first&#xA;checks to see whether the view has a specified controller. This is&#xA;something of a hack and should be revisited." name="TextSupport" />
          <variable attributes="property private" citdl="Object" doc="The controller managing this view. If this property is set, it will be&#xA;made available for use by the template." name="TextSupport" />
          <variable attributes="property private" citdl="Boolean" name="TextSupport" />
          <variable attributes="property private" citdl="String" doc="The name of the template to lookup if no template is provided.&#xA; By default `Ember.View` will lookup a template with this name in&#xA;`Ember.TEMPLATES` (a shared global object)." name="TextSupport" />
          <variable attributes="property private" citdl="String" doc="The name of the layout to lookup if no layout is provided.&#xA; By default `Ember.View` will lookup a template with this name in&#xA;`Ember.TEMPLATES` (a shared global object)." name="TextSupport" />
          <variable attributes="property private" citdl="Function" doc="The template used to render the view. This should be a function that&#xA;accepts an optional context parameter and returns a string of HTML that&#xA;will be inserted into the DOM relative to its parent view.&#xA; In general, you should set the `templateName` property instead of setting&#xA;the template yourself." name="TextSupport" />
          <variable attributes="property private" citdl="Function" doc="A view may contain a layout. A layout is a regular template but&#xA;supersedes the `template` property during rendering. It is the&#xA;responsibility of the layout template to retrieve the `template`&#xA;property from the view (or alternatively, call `Handlebars.helpers.yield`,&#xA;`{{yield}}`) to render it in the correct location.&#xA; This is useful for a view that has a shared wrapper, but which delegates&#xA;the rendering of the contents of the wrapper to the `template` property&#xA;on a subclass." name="TextSupport" />
          <scope attributes="private" doc="Return the nearest ancestor that is an instance of the provided&#xA;class or mixin." ilk="function" name="nearestOfType" signature="nearestOfType(klass)">
            <variable citdl="Class,Mixin" doc="Subclass of Ember.View (or Ember.View itself),&#xA;       or an instance of Ember.Mixin." ilk="argument" name="klass" />
          </scope>
          <scope attributes="private" doc="Return the nearest ancestor that has a given property." ilk="function" name="nearestWithProperty" signature="nearestWithProperty(property)">
            <variable citdl="String" doc="A property name" ilk="argument" name="property" />
          </scope>
          <scope attributes="public" doc="Renders the view again. This will work regardless of whether the&#xA;view is already in the DOM or not. If the view is in the DOM, the&#xA;rendering process will be deferred to give bindings a chance&#xA;to synchronize.&#xA; If children were added during the rendering process using `appendChild`,&#xA;`rerender` will remove them, because they will be added again&#xA;if needed by the next `render`.&#xA; In general, if the display of your view changes, you should modify&#xA;the DOM element directly instead of manually calling `rerender`, which can&#xA;be slow." ilk="function" name="rerender" signature="rerender()" />
          <variable attributes="property public" citdl="DOMElement" doc="Returns the current DOM element for the view." name="TextSupport" />
          <scope attributes="public" doc="Returns a jQuery object for this view&apos;s element. If you pass in a selector&#xA;string, this method will return a jQuery object, using the current element&#xA;as its buffer.&#xA; For example, calling `view.$(&apos;li&apos;)` will return a jQuery object containing&#xA;all of the `li` elements inside the DOM element of this view." ilk="function" name="$" returns="JQuery" signature="$(selector) =&gt; JQuery">
            <variable citdl="String" doc="a jQuery-compatible selector string" ilk="argument" name="selector" />
          </scope>
          <scope attributes="private" doc="Appends the view&apos;s element to the specified parent element.&#xA; If the view does not have an HTML representation yet, `createElement()`&#xA;will be called automatically.&#xA; Note that this method just schedules the view to be appended; the DOM&#xA;element will not be appended to the given element until all bindings have&#xA;finished synchronizing.&#xA; This is not typically a function that you will need to call directly when&#xA;building your application. You might consider using `Ember.ContainerView`&#xA;instead. If you do need to use `appendTo`, be sure that the target element&#xA;you are providing is associated with an `Ember.Application` and does not&#xA;have an ancestor element that is associated with an Ember view." ilk="function" name="appendTo" returns="Ember.View" signature="appendTo(A) =&gt; Ember.View">
            <variable citdl="String|DOMElement|jQuery" doc="selector, element, HTML string, or jQuery object" ilk="argument" name="A" />
          </scope>
          <scope attributes="private" ilk="function" name="renderToElement" returns="HTMLBodyElement" signature="renderToElement(tagName) =&gt; HTMLBodyElement">
            <variable citdl="String" doc="The tag of the element to create and render into. Defaults to &quot;body&quot;." ilk="argument" name="tagName" />
          </scope>
          <scope attributes="private" doc="Replaces the content of the specified parent element with this view&apos;s&#xA;element. If the view does not have an HTML representation yet,&#xA;the element will be generated automatically.&#xA; Note that this method just schedules the view to be appended; the DOM&#xA;element will not be appended to the given element until all bindings have&#xA;finished synchronizing" ilk="function" name="replaceIn" returns="Ember.View" signature="replaceIn(target) =&gt; Ember.View">
            <variable citdl="String|DOMElement|jQuery" doc="A selector, element, HTML string, or jQuery object" ilk="argument" name="target" />
          </scope>
          <scope attributes="private" doc="Appends the view&apos;s element to the document body. If the view does&#xA;not have an HTML representation yet&#xA;the element will be generated automatically.&#xA; If your application uses the `rootElement` property, you must append&#xA;the view within that element. Rendering views outside of the `rootElement`&#xA;is not supported.&#xA; Note that this method just schedules the view to be appended; the DOM&#xA;element will not be appended to the document body until all bindings have&#xA;finished synchronizing." ilk="function" name="append" returns="Ember.View" signature="append() =&gt; Ember.View" />
          <scope attributes="private" doc="Removes the view&apos;s element from the element to which it is attached." ilk="function" name="remove" returns="Ember.View" signature="remove() =&gt; Ember.View" />
          <variable attributes="property public" citdl="String" doc="The HTML `id` of the view&apos;s element in the DOM. You can provide this&#xA;value yourself but it must be unique (just as in HTML):&#xA; ```handlebars&#xA;  {{my-component elementId=&quot;a-really-cool-id&quot;}}&#xA;```&#xA; If not manually set a default value will be provided by the framework.&#xA; Once rendered an element&apos;s `elementId` is considered immutable and you&#xA;should never change it. If you need to compute a dynamic value for the&#xA;`elementId`, you should do this when the component or element is being&#xA;instantiated:&#xA; ```javascript&#xA;  export default Ember.Component.extend({&#xA;    setElementId: Ember.on(&apos;init&apos;, function() {&#xA;      var index = this.get(&apos;index&apos;);&#xA;      this.set(&apos;elementId&apos;, &apos;component-id&apos; + index);&#xA;    })&#xA;  });&#xA;```" name="TextSupport" />
          <scope attributes="private" doc="Attempts to discover the element in the parent element. The default&#xA;implementation looks for an element with an ID of `elementId` (or the&#xA;view&apos;s guid if `elementId` is null). You can override this method to&#xA;provide your own form of lookup. For example, if you want to discover your&#xA;element using a CSS class name instead of an ID." ilk="function" name="findElementInParentElement" returns="DOMElement" signature="findElementInParentElement(parentElement) =&gt; DOMElement">
            <variable citdl="DOMElement" doc="The parent&apos;s DOM element" ilk="argument" name="parentElement" />
          </scope>
          <scope attributes="private" doc="Creates a DOM representation of the view and all of its child views by&#xA;recursively calling the `render()` method. Once the element is created,&#xA;it sets the `element` property of the view to the rendered element.&#xA; After the element has been inserted into the DOM, `didInsertElement` will&#xA;be called on this view and all of its child views." ilk="function" name="createElement" returns="Ember.View" signature="createElement() =&gt; Ember.View" />
          <variable attributes="event public" doc="Called when a view is going to insert an element into the DOM." name="TextSupport" />
          <variable attributes="event public" doc="Called when the element of the view has been inserted into the DOM&#xA;or after the view was re-rendered. Override this function to do any&#xA;set up that requires an element in the document body.&#xA; When a view has children, didInsertElement will be called on the&#xA;child view(s) first, bubbling upwards through the hierarchy." name="TextSupport" />
          <variable attributes="event public" doc="Called when the view is about to rerender, but before anything has&#xA;been torn down. This is a good opportunity to tear down any manual&#xA;observers you have installed based on the DOM state" name="TextSupport" />
          <scope attributes="private" doc="Destroys any existing element along with the element for any child views&#xA;as well. If the view does not currently have a element, then this method&#xA;will do nothing.&#xA; If you implement `willDestroyElement()` on your view, then this method will&#xA;be invoked on your view before your element is destroyed to give you a&#xA;chance to clean up any event handlers, etc.&#xA; If you write a `willDestroyElement()` handler, you can assume that your&#xA;`didInsertElement()` handler was called earlier for the same element.&#xA; You should not call or override this method yourself, but you may&#xA;want to implement the above callbacks." ilk="function" name="destroyElement" returns="Ember.View" signature="destroyElement() =&gt; Ember.View" />
          <variable attributes="event public" doc="Called when the element of the view is going to be destroyed. Override&#xA;this function to do any teardown that requires an element, like removing&#xA;event listeners.&#xA; Please note: any property changes made during this event will have no&#xA;effect on object observers." name="TextSupport" />
          <variable attributes="event private" doc="Called when the parentView property has changed." name="TextSupport" />
          <variable attributes="property public" citdl="String" doc="Tag name for the view&apos;s outer element. The tag name is only used when an&#xA;element is first created. If you change the `tagName` for an element, you&#xA;must destroy and recreate the view element.&#xA; By default, the render buffer will use a `&lt;div&gt;` tag for views." name="TextSupport" />
          <scope attributes="public" doc="Normally, Ember&apos;s component model is &quot;write-only&quot;. The component takes a&#xA;bunch of attributes that it got passed in, and uses them to render its&#xA;template.&#xA; One nice thing about this model is that if you try to set a value to the&#xA;same thing as last time, Ember (through HTMLBars) will avoid doing any&#xA;work on the DOM.&#xA; This is not just a performance optimization. If an attribute has not&#xA;changed, it is important not to clobber the element&apos;s &quot;hidden state&quot;.&#xA;For example, if you set an input&apos;s `value` to the same value as before,&#xA;it will clobber selection state and cursor position. In other words,&#xA;setting an attribute is not **always** idempotent.&#xA; This method provides a way to read an element&apos;s attribute and also&#xA;update the last value Ember knows about at the same time. This makes&#xA;setting an attribute idempotent.&#xA; In particular, what this means is that if you get an `&lt;input&gt;` element&apos;s&#xA;`value` attribute and then re-render the template with the same value,&#xA;it will avoid clobbering the cursor and selection position.&#xA; Since most attribute sets are idempotent in the browser, you typically&#xA;can get away with reading attributes using jQuery, but the most reliable&#xA;way to do so is through this method." ilk="function" name="readDOMAttr" signature="readDOMAttr(name)">
            <variable citdl="String" doc="the name of the attribute" ilk="argument" name="name" />
          </scope>
          <scope attributes="private" doc="Setup a view, but do not finish waking it up.&#xA; * configure `childViews`&#xA;* register the view with the global views hash, which is used for event&#xA;  dispatch" ilk="function" name="init" signature="init()" />
          <scope attributes="private" doc="Removes the view from its `parentView`, if one is found. Otherwise&#xA;does nothing." ilk="function" name="removeFromParent" returns="Ember.View" signature="removeFromParent() =&gt; Ember.View" />
          <scope attributes="private" doc="You must call `destroy` on a view to destroy the view (and all of its&#xA;child views). This will remove the view from any parent node, then make&#xA;sure that the DOM element managed by the view can be released by the&#xA;memory manager." ilk="function" name="destroy" signature="destroy()" />
          <scope attributes="private" doc="Handle events from `Ember.EventDispatcher`" ilk="function" name="handleEvent" signature="handleEvent(eventName,evt)">
            <variable citdl="String" ilk="argument" name="eventName" />
            <variable citdl="Event" ilk="argument" name="evt" />
          </scope>
          <scope attributes="private" doc="Registers the view in the view registry, keyed on the view&apos;s `elementId`.&#xA;This is used by the EventDispatcher to locate the view in response to&#xA;events.&#xA; This method should only be called once the view has been inserted into the&#xA;DOM." ilk="function" name="_register" signature="_register()" />
          <scope attributes="private" doc="Removes the view from the view registry. This should be called when the&#xA;view is removed from DOM." ilk="function" name="_unregister" signature="_unregister()" />
        </scope>
        <scope doc="DAG Vertex" ilk="class" name="Vertex" />
        <scope classrefs="Ember.CoreView" doc="`Ember.View` is the class in Ember responsible for encapsulating templates of&#xA;HTML content, combining templates with data to render as sections of a page&apos;s&#xA;DOM, and registering and responding to user-initiated events.&#xA;  &#xA;## HTML Tag&#xA;  &#xA;The default HTML tag name used for a view&apos;s DOM representation is `div`. This&#xA;can be customized by setting the `tagName` property. The following view&#xA;class:&#xA;  &#xA;```javascript&#xA;ParagraphView = Ember.View.extend({&#xA;  tagName: &apos;em&apos;&#xA;});&#xA;```&#xA;  &#xA;Would result in instances with the following HTML:&#xA;  &#xA;```html&#xA;&lt;em id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;&lt;/em&gt;&#xA;```&#xA;  &#xA;## HTML `class` Attribute&#xA;  &#xA;The HTML `class` attribute of a view&apos;s tag can be set by providing a&#xA;`classNames` property that is set to an array of strings:&#xA;  &#xA;```javascript&#xA;MyView = Ember.View.extend({&#xA;  classNames: [&apos;my-class&apos;, &apos;my-other-class&apos;]&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view my-class my-other-class&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;`class` attribute values can also be set by providing a `classNameBindings`&#xA;property set to an array of properties names for the view. The return value&#xA;of these properties will be added as part of the value for the view&apos;s `class`&#xA;attribute. These properties can be computed properties:&#xA;  &#xA;```javascript&#xA;MyView = Ember.View.extend({&#xA;  classNameBindings: [&apos;propertyA&apos;, &apos;propertyB&apos;],&#xA;  propertyA: &apos;from-a&apos;,&#xA;  propertyB: Ember.computed(function() {&#xA;    if (someLogic) { return &apos;from-b&apos;; }&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view from-a from-b&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;If the value of a class name binding returns a boolean the property name&#xA;itself will be used as the class name if the property is true. The class name&#xA;will not be added if the value is `false` or `undefined`.&#xA;  &#xA;```javascript&#xA;MyView = Ember.View.extend({&#xA;  classNameBindings: [&apos;hovered&apos;],&#xA;  hovered: true&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view hovered&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;When using boolean class name bindings you can supply a string value other&#xA;than the property name for use as the `class` HTML attribute by appending the&#xA;preferred value after a &quot;:&quot; character when defining the binding:&#xA;  &#xA;```javascript&#xA;MyView = Ember.View.extend({&#xA;  classNameBindings: [&apos;awesome:so-very-cool&apos;],&#xA;  awesome: true&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view so-very-cool&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;Boolean value class name bindings whose property names are in a&#xA;camelCase-style format will be converted to a dasherized format:&#xA;  &#xA;```javascript&#xA;MyView = Ember.View.extend({&#xA;  classNameBindings: [&apos;isUrgent&apos;],&#xA;  isUrgent: true&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view is-urgent&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;Class name bindings can also refer to object values that are found by&#xA;traversing a path relative to the view itself:&#xA;  &#xA;```javascript&#xA;MyView = Ember.View.extend({&#xA;  classNameBindings: [&apos;messages.empty&apos;]&#xA;  messages: Ember.Object.create({&#xA;    empty: true&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view empty&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;If you want to add a class name for a property which evaluates to true and&#xA;and a different class name if it evaluates to false, you can pass a binding&#xA;like this:&#xA;  &#xA;```javascript&#xA;// Applies &apos;enabled&apos; class when isEnabled is true and &apos;disabled&apos; when isEnabled is false&#xA;Ember.View.extend({&#xA;  classNameBindings: [&apos;isEnabled:enabled:disabled&apos;]&#xA;  isEnabled: true&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view enabled&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;When isEnabled is `false`, the resulting HTML representation looks like&#xA;this:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view disabled&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;This syntax offers the convenience to add a class if a property is `false`:&#xA;  &#xA;```javascript&#xA;// Applies no class when isEnabled is true and class &apos;disabled&apos; when isEnabled is false&#xA;Ember.View.extend({&#xA;  classNameBindings: [&apos;isEnabled::disabled&apos;]&#xA;  isEnabled: true&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;When the `isEnabled` property on the view is set to `false`, it will result&#xA;in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view disabled&quot;&gt;&lt;/div&gt;&#xA;```&#xA;  &#xA;Updates to the value of a class name binding will result in automatic&#xA;update of the  HTML `class` attribute in the view&apos;s rendered HTML&#xA;representation. If the value becomes `false` or `undefined` the class name&#xA;will be removed.&#xA;  &#xA;Both `classNames` and `classNameBindings` are concatenated properties. See&#xA;[Ember.Object](/api/classes/Ember.Object.html) documentation for more&#xA;information about concatenated properties.&#xA;  &#xA;## HTML Attributes&#xA;  &#xA;The HTML attribute section of a view&apos;s tag can be set by providing an&#xA;`attributeBindings` property set to an array of property names on the view.&#xA;The return value of these properties will be used as the value of the view&apos;s&#xA;HTML associated attribute:&#xA;  &#xA;```javascript&#xA;AnchorView = Ember.View.extend({&#xA;  tagName: &apos;a&apos;,&#xA;  attributeBindings: [&apos;href&apos;],&#xA;  href: &apos;http://google.com&apos;&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;a id=&quot;ember1&quot; class=&quot;ember-view&quot; href=&quot;http://google.com&quot;&gt;&lt;/a&gt;&#xA;```&#xA;  &#xA;One property can be mapped on to another by placing a &quot;:&quot; between&#xA;the source property and the destination property:&#xA;  &#xA;```javascript&#xA;AnchorView = Ember.View.extend({&#xA;  tagName: &apos;a&apos;,&#xA;  attributeBindings: [&apos;url:href&apos;],&#xA;  url: &apos;http://google.com&apos;&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;a id=&quot;ember1&quot; class=&quot;ember-view&quot; href=&quot;http://google.com&quot;&gt;&lt;/a&gt;&#xA;```&#xA;  &#xA;Namespaced attributes (e.g. `xlink:href`) are supported, but have to be&#xA;mapped, since `:` is not a valid character for properties in Javascript:&#xA;  &#xA;```javascript&#xA;UseView = Ember.View.extend({&#xA;  tagName: &apos;use&apos;,&#xA;  attributeBindings: [&apos;xlinkHref:xlink:href&apos;],&#xA;  xlinkHref: &apos;#triangle&apos;&#xA;});&#xA;```&#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;use xlink:href=&quot;#triangle&quot;&gt;&lt;/use&gt;&#xA;```&#xA;  &#xA;If the return value of an `attributeBindings` monitored property is a boolean&#xA;the property will follow HTML&apos;s pattern of repeating the attribute&apos;s name as&#xA;its value:&#xA;  &#xA;```javascript&#xA;MyTextInput = Ember.View.extend({&#xA;  tagName: &apos;input&apos;,&#xA;  attributeBindings: [&apos;disabled&apos;],&#xA;  disabled: true&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;input id=&quot;ember1&quot; class=&quot;ember-view&quot; disabled=&quot;disabled&quot; /&gt;&#xA;```&#xA;  &#xA;`attributeBindings` can refer to computed properties:&#xA;  &#xA;```javascript&#xA;MyTextInput = Ember.View.extend({&#xA;  tagName: &apos;input&apos;,&#xA;  attributeBindings: [&apos;disabled&apos;],&#xA;  disabled: Ember.computed(function() {&#xA;    if (someLogic) {&#xA;      return true;&#xA;    } else {&#xA;      return false;&#xA;    }&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Updates to the property of an attribute binding will result in automatic&#xA;update of the  HTML attribute in the view&apos;s rendered HTML representation.&#xA;  &#xA;`attributeBindings` is a concatenated property. See [Ember.Object](/api/classes/Ember.Object.html)&#xA;documentation for more information about concatenated properties.&#xA;  &#xA;## Templates&#xA;  &#xA;The HTML contents of a view&apos;s rendered representation are determined by its&#xA;template. Templates can be any function that accepts an optional context&#xA;parameter and returns a string of HTML that will be inserted within the&#xA;view&apos;s tag. Most typically in Ember this function will be a compiled&#xA;template.&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  template: Ember.HTMLBars.compile(&apos;I am the template&apos;)&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;I am the template&lt;/div&gt;&#xA;```&#xA;  &#xA;Within an Ember application is more common to define a Handlebars templates as&#xA;part of a page:&#xA;  &#xA;```html&#xA;&lt;script type=&apos;text/x-handlebars&apos; data-template-name=&apos;some-template&apos;&gt;&#xA;  Hello&#xA;&lt;/script&gt;&#xA;```&#xA;  &#xA;And associate it by name using a view&apos;s `templateName` property:&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  templateName: &apos;some-template&apos;&#xA;});&#xA;```&#xA;  &#xA;If you have nested routes, your Handlebars template will look like this:&#xA;  &#xA;```html&#xA;&lt;script type=&apos;text/x-handlebars&apos; data-template-name=&apos;posts/new&apos;&gt;&#xA;  &lt;h1&gt;New Post&lt;/h1&gt;&#xA;&lt;/script&gt;&#xA;```&#xA;  &#xA;And `templateName` property:&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  templateName: &apos;posts/new&apos;&#xA;});&#xA;```&#xA;  &#xA;Using a value for `templateName` that does not have a template&#xA;with a matching `data-template-name` attribute will throw an error.&#xA;  &#xA;For views classes that may have a template later defined (e.g. as the block&#xA;portion of a `{{view}}` helper call in another template or in&#xA;a subclass), you can provide a `defaultTemplate` property set to compiled&#xA;template function. If a template is not later provided for the view instance&#xA;the `defaultTemplate` value will be used:&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  defaultTemplate: Ember.HTMLBars.compile(&apos;I was the default&apos;),&#xA;  template: null,&#xA;  templateName: null&#xA;});&#xA;```&#xA;  &#xA;Will result in instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;I was the default&lt;/div&gt;&#xA;```&#xA;  &#xA;If a `template` or `templateName` is provided it will take precedence over&#xA;`defaultTemplate`:&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  defaultTemplate: Ember.HTMLBars.compile(&apos;I was the default&apos;)&#xA;});&#xA;  &#xA;aView = AView.create({&#xA;  template: Ember.HTMLBars.compile(&apos;I was the template, not default&apos;)&#xA;});&#xA;```&#xA;  &#xA;Will result in the following HTML representation when rendered:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;I was the template, not default&lt;/div&gt;&#xA;```&#xA;  &#xA;## View Context&#xA;  &#xA;The default context of the compiled template is the view&apos;s controller:&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  template: Ember.HTMLBars.compile(&apos;Hello {{excitedGreeting}}&apos;)&#xA;});&#xA;  &#xA;aController = Ember.Object.create({&#xA;  firstName: &apos;Barry&apos;,&#xA;  excitedGreeting: Ember.computed(&apos;content.firstName&apos;, function() {&#xA;    return this.get(&apos;content.firstName&apos;) + &apos;!!!&apos;;&#xA;  })&#xA;});&#xA;  &#xA;aView = AView.create({&#xA;  controller: aController&#xA;});&#xA;```&#xA;  &#xA;Will result in an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;Hello Barry!!!&lt;/div&gt;&#xA;```&#xA;  &#xA;A context can also be explicitly supplied through the view&apos;s `context`&#xA;property. If the view has neither `context` nor `controller` properties, the&#xA;`parentView`&apos;s context will be used.&#xA;  &#xA;## Layouts&#xA;  &#xA;Views can have a secondary template that wraps their main template. Like&#xA;primary templates, layouts can be any function that  accepts an optional&#xA;context parameter and returns a string of HTML that will be inserted inside&#xA;view&apos;s tag. Views whose HTML element is self closing (e.g. `&lt;input /&gt;`)&#xA;cannot have a layout and this property will be ignored.&#xA;  &#xA;Most typically in Ember a layout will be a compiled template.&#xA;  &#xA;A view&apos;s layout can be set directly with the `layout` property or reference&#xA;an existing template by name with the `layoutName` property.&#xA;  &#xA;A template used as a layout must contain a single use of the&#xA;`{{yield}}` helper. The HTML contents of a view&apos;s rendered `template` will be&#xA;inserted at this location:&#xA;  &#xA;```javascript&#xA;AViewWithLayout = Ember.View.extend({&#xA;  layout: Ember.HTMLBars.compile(&quot;&lt;div class=&apos;my-decorative-class&apos;&gt;{{yield}}&lt;/div&gt;&quot;),&#xA;  template: Ember.HTMLBars.compile(&quot;I got wrapped&quot;)&#xA;});&#xA;```&#xA;  &#xA;Will result in view instances with an HTML representation of:&#xA;  &#xA;```html&#xA;&lt;div id=&quot;ember1&quot; class=&quot;ember-view&quot;&gt;&#xA;  &lt;div class=&quot;my-decorative-class&quot;&gt;&#xA;    I got wrapped&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;```&#xA;  &#xA;See [Ember.Templates.helpers.yield](/api/classes/Ember.Templates.helpers.html#method_yield)&#xA;for more information.&#xA;  &#xA;## Responding to Browser Events&#xA;  &#xA;Views can respond to user-initiated events in one of three ways: method&#xA;implementation, through an event manager, and through `{{action}}` helper use&#xA;in their template or layout.&#xA;  &#xA;### Method Implementation&#xA;  &#xA;Views can respond to user-initiated events by implementing a method that&#xA;matches the event name. A `jQuery.Event` object will be passed as the&#xA;argument to this method.&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  click: function(event) {&#xA;    // will be called when an instance&apos;s&#xA;    // rendered element is clicked&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;### Event Managers&#xA;  &#xA;Views can define an object as their `eventManager` property. This object can&#xA;then implement methods that match the desired event names. Matching events&#xA;that occur on the view&apos;s rendered HTML or the rendered HTML of any of its DOM&#xA;descendants will trigger this method. A `jQuery.Event` object will be passed&#xA;as the first argument to the method and an  `Ember.View` object as the&#xA;second. The `Ember.View` will be the view whose rendered HTML was interacted&#xA;with. This may be the view with the `eventManager` property or one of its&#xA;descendant views.&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  eventManager: Ember.Object.create({&#xA;    doubleClick: function(event, view) {&#xA;      // will be called when an instance&apos;s&#xA;      // rendered element or any rendering&#xA;      // of this view&apos;s descendant&#xA;      // elements is clicked&#xA;    }&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;An event defined for an event manager takes precedence over events of the&#xA;same name handled through methods on the view.&#xA;  &#xA;```javascript&#xA;AView = Ember.View.extend({&#xA;  mouseEnter: function(event) {&#xA;    // will never trigger.&#xA;  },&#xA;  eventManager: Ember.Object.create({&#xA;    mouseEnter: function(event, view) {&#xA;      // takes precedence over AView#mouseEnter&#xA;    }&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Similarly a view&apos;s event manager will take precedence for events of any views&#xA;rendered as a descendant. A method name that matches an event name will not&#xA;be called if the view instance was rendered inside the HTML representation of&#xA;a view that has an `eventManager` property defined that handles events of the&#xA;name. Events not handled by the event manager will still trigger method calls&#xA;on the descendant.&#xA;  &#xA;```javascript&#xA;var App = Ember.Application.create();&#xA;App.OuterView = Ember.View.extend({&#xA;  template: Ember.HTMLBars.compile(&quot;outer {{#view &apos;inner&apos;}}inner{{/view}} outer&quot;),&#xA;  eventManager: Ember.Object.create({&#xA;    mouseEnter: function(event, view) {&#xA;      // view might be instance of either&#xA;      // OuterView or InnerView depending on&#xA;      // where on the page the user interaction occurred&#xA;    }&#xA;  })&#xA;});&#xA;  &#xA;App.InnerView = Ember.View.extend({&#xA;  click: function(event) {&#xA;    // will be called if rendered inside&#xA;    // an OuterView because OuterView&apos;s&#xA;    // eventManager doesn&apos;t handle click events&#xA;  },&#xA;  mouseEnter: function(event) {&#xA;    // will never be called if rendered inside&#xA;    // an OuterView.&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;### `{{action}}` Helper&#xA;  &#xA;See [Ember.Templates.helpers.action](/api/classes/Ember.Templates.helpers.html#method_action).&#xA;  &#xA;### Event Names&#xA;  &#xA;All of the event handling approaches described above respond to the same set&#xA;of events. The names of the built-in events are listed below. (The hash of&#xA;built-in events exists in `Ember.EventDispatcher`.) Additional, custom events&#xA;can be registered by using `Ember.Application.customEvents`.&#xA;  &#xA;Touch events:&#xA;  &#xA;* `touchStart`&#xA;* `touchMove`&#xA;* `touchEnd`&#xA;* `touchCancel`&#xA;  &#xA;Keyboard events&#xA;  &#xA;* `keyDown`&#xA;* `keyUp`&#xA;* `keyPress`&#xA;  &#xA;Mouse events&#xA;  &#xA;* `mouseDown`&#xA;* `mouseUp`&#xA;* `contextMenu`&#xA;* `click`&#xA;* `doubleClick`&#xA;* `mouseMove`&#xA;* `focusIn`&#xA;* `focusOut`&#xA;* `mouseEnter`&#xA;* `mouseLeave`&#xA;  &#xA;Form events:&#xA;  &#xA;* `submit`&#xA;* `change`&#xA;* `focusIn`&#xA;* `focusOut`&#xA;* `input`&#xA;  &#xA;HTML5 drag and drop events:&#xA;  &#xA;* `dragStart`&#xA;* `drag`&#xA;* `dragEnter`&#xA;* `dragLeave`&#xA;* `dragOver`&#xA;* `dragEnd`&#xA;* `drop`&#xA;  &#xA;## `{{view}}` Helper&#xA;  &#xA;Other `Ember.View` instances can be included as part of a view&apos;s template by&#xA;using the `{{view}}` helper. See [Ember.Templates.helpers.view](/api/classes/Ember.Templates.helpers.html#method_view)&#xA;for additional information." ilk="class" name="View">
          <scope attributes="private" doc="Given a property name, returns a dasherized version of that&#xA;property name if the property evaluates to a non-falsy value.&#xA; For example, if the view has property `isUrgent` that evaluates to true,&#xA;passing `isUrgent` to this method will return `&quot;is-urgent&quot;`." ilk="function" name="_classStringForProperty" signature="_classStringForProperty(property)">
            <variable ilk="argument" name="property" />
          </scope>
          <variable attributes="property private" citdl="Object" doc="Global views hash" name="View" />
          <scope attributes="public" ilk="function" name="catch" returns="Promise" signature="catch(onRejection,label) =&gt; Promise">
            <variable citdl="Function" ilk="argument" name="onRejection" />
            <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
          <scope attributes="public" ilk="function" name="finally" returns="Promise" signature="finally(callback,label) =&gt; Promise">
            <variable citdl="Function" ilk="argument" name="callback" />
            <variable citdl="String" doc="optional string for labeling the promise.&#xA;Useful for tooling." ilk="argument" name="label" />
          </scope>
        </scope>
        <scope classrefs="Ember.TargetActionSupport" doc="`Ember.ViewTargetActionSupport` is a mixin that can be included in a&#xA;view class to add a `triggerAction` method with semantics similar to&#xA;the Handlebars `{{action}}` helper. It provides intelligent defaults&#xA;for the action&apos;s target: the view&apos;s controller; and the context that is&#xA;sent with the action: the view&apos;s context.&#xA;&#xA;Note: In normal Ember usage, the `{{action}}` helper is usually the best&#xA;choice. This mixin is most often useful when you are doing more complex&#xA;event handling in custom View subclasses.&#xA;&#xA;For example:&#xA;&#xA;```javascript&#xA;App.SaveButtonView = Ember.View.extend(Ember.ViewTargetActionSupport, {&#xA;  action: &apos;save&apos;,&#xA;  click: function() {&#xA;    this.triggerAction(); // Sends the `save` action, along with the current context&#xA;                          // to the current controller&#xA;  }&#xA;});&#xA;```&#xA;&#xA;The `action` can be provided as properties of an optional object argument&#xA;to `triggerAction` as well.&#xA;&#xA;```javascript&#xA;App.SaveButtonView = Ember.View.extend(Ember.ViewTargetActionSupport, {&#xA;  click: function() {&#xA;    this.triggerAction({&#xA;      action: &apos;save&apos;&#xA;    }); // Sends the `save` action, along with the current context&#xA;        // to the current controller&#xA;  }&#xA;});&#xA;```" ilk="class" name="ViewTargetActionSupport">
          <variable attributes="property private" name="ViewTargetActionSupport" />
          <variable attributes="property private" name="ViewTargetActionSupport" />
        </scope>
        <scope ilk="class" name="VisibilitySupport">
          <variable attributes="property public" citdl="Boolean" doc="If `false`, the view will appear hidden in DOM." name="VisibilitySupport" />
          <scope attributes="private" doc="When the view&apos;s `isVisible` property changes, toggle the visibility&#xA;element of the actual DOM element." ilk="function" name="_isVisibleDidChange" signature="_isVisibleDidChange()" />
          <scope attributes="private" doc="Parse a path and return an object which holds the parsed properties.&#xA;  &#xA;For example a path like &quot;content.isEnabled:enabled:disabled&quot; will return the&#xA;following object:&#xA;  &#xA;```javascript&#xA;{&#xA;  path: &quot;content.isEnabled&quot;,&#xA;  className: &quot;enabled&quot;,&#xA;  falsyClassName: &quot;disabled&quot;,&#xA;  classNames: &quot;:enabled:disabled&quot;&#xA;}&#xA;```" ilk="function" name="parsePropertyPath" signature="parsePropertyPath()" />
          <scope attributes="private" doc="Get the class name for a given value, based on the path, optional&#xA;`className` and optional `falsyClassName`.&#xA;  &#xA;- if a `className` or `falsyClassName` has been specified:&#xA;  - if the value is truthy and `className` has been specified,&#xA;    `className` is returned&#xA;  - if the value is falsy and `falsyClassName` has been specified,&#xA;    `falsyClassName` is returned&#xA;  - otherwise `null` is returned&#xA;- if the value is `true`, the dasherized last part of the supplied path&#xA;  is returned&#xA;- if the value is not `false`, `undefined` or `null`, the `value`&#xA;  is returned&#xA;- if none of the above rules apply, `null` is returned" ilk="function" name="classStringForValue" signature="classStringForValue(path,val,className,falsyClassName)">
            <variable ilk="argument" name="path" />
            <variable ilk="argument" name="val" />
            <variable ilk="argument" name="className" />
            <variable ilk="argument" name="falsyClassName" />
          </scope>
          <variable attributes="property private" citdl="Object" doc="Global action id hash." name="VisibilitySupport" />
        </scope>
        <scope ilk="class" name="_Metamorph" />
        <scope classrefs="Ember.View" ilk="class" name="_MetamorphView" />
        <scope doc="This helper returns a new property descriptor that wraps the passed&#xA;computed property function. You can use this helper to define properties&#xA;with mixins or via `Ember.defineProperty()`.&#xA;  &#xA;If you pass a function as an argument, it will be used as a getter. A computed&#xA;property defined in this way might look like this:&#xA;  &#xA;```js&#xA;let Person = Ember.Object.extend({&#xA;  init() {&#xA;    this._super(...arguments);&#xA;  &#xA;    this.firstName = &apos;Betty&apos;;&#xA;    this.lastName = &apos;Jones&apos;;&#xA;  },&#xA;  &#xA;  fullName: Ember.computed(&apos;firstName&apos;, &apos;lastName&apos;, function() {&#xA;    return `${this.get(&apos;firstName&apos;)} ${this.get(&apos;lastName&apos;)}`;&#xA;  })&#xA;});&#xA;  &#xA;let client = Person.create();&#xA;  &#xA;client.get(&apos;fullName&apos;); // &apos;Betty Jones&apos;&#xA;  &#xA;client.set(&apos;lastName&apos;, &apos;Fuller&apos;);&#xA;client.get(&apos;fullName&apos;); // &apos;Betty Fuller&apos;&#xA;```&#xA;  &#xA;You can pass a hash with two functions, `get` and `set`, as an&#xA;argument to provide both a getter and setter:&#xA;  &#xA;```js&#xA;let Person = Ember.Object.extend({&#xA;  init() {&#xA;    this._super(...arguments);&#xA;  &#xA;    this.firstName = &apos;Betty&apos;;&#xA;    this.lastName = &apos;Jones&apos;;&#xA;  },&#xA;  &#xA;  fullName: Ember.computed({&#xA;    get(key) {&#xA;      return `${this.get(&apos;firstName&apos;)} ${this.get(&apos;lastName&apos;)}`;&#xA;    },&#xA;    set(key, value) {&#xA;      let [firstName, lastName] = value.split(/\s+/);&#xA;      this.setProperties({ firstName, lastName });&#xA;      return value;&#xA;    }&#xA;  });&#xA;})&#xA;  &#xA;let client = Person.create();&#xA;client.get(&apos;firstName&apos;); // &apos;Betty&apos;&#xA;  &#xA;client.set(&apos;fullName&apos;, &apos;Carroll Fuller&apos;);&#xA;client.get(&apos;firstName&apos;); // &apos;Carroll&apos;&#xA;```&#xA;  &#xA;The `set` function should accept two parameters, `key` and `value`. The value&#xA;returned from `set` will be the new value of the property.&#xA;  &#xA;_Note: This is the preferred way to define computed properties when writing third-party&#xA;libraries that depend on or use Ember, since there is no guarantee that the user&#xA;will have [prototype Extensions](http://emberjs.com/guides/configuring-ember/disabling-prototype-extensions/) enabled._&#xA;  &#xA;The alternative syntax, with prototype extensions, might look like:&#xA;  &#xA;```js&#xA;fullName() {&#xA;  return this.get(&apos;firstName&apos;) + &apos; &apos; + this.get(&apos;lastName&apos;);&#xA;}.property(&apos;firstName&apos;, &apos;lastName&apos;)&#xA;```" ilk="class" name="computed">
          <scope attributes="public" doc="A computed property that returns true if the value of the dependent&#xA;property is null, an empty string, empty array, or empty function.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var ToDoList = Ember.Object.extend({&#xA;  isDone: Ember.computed.empty(&apos;todos&apos;)&#xA;});&#xA;  &#xA;var todoList = ToDoList.create({&#xA;  todos: [&apos;Unit Test&apos;, &apos;Documentation&apos;, &apos;Release&apos;]&#xA;});&#xA;  &#xA;todoList.get(&apos;isDone&apos;); // false&#xA;todoList.get(&apos;todos&apos;).clear();&#xA;todoList.get(&apos;isDone&apos;); // true&#xA;```" ilk="function" name="empty" returns="Ember.ComputedProperty" signature="empty(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the value of the dependent&#xA;property is NOT null, an empty string, empty array, or empty function.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  hasStuff: Ember.computed.notEmpty(&apos;backpack&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create({ backpack: [&apos;Food&apos;, &apos;Sleeping Bag&apos;, &apos;Tent&apos;] });&#xA;  &#xA;hamster.get(&apos;hasStuff&apos;);         // true&#xA;hamster.get(&apos;backpack&apos;).clear(); // []&#xA;hamster.get(&apos;hasStuff&apos;);         // false&#xA;```" ilk="function" name="notEmpty" returns="Ember.ComputedProperty" signature="notEmpty(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the value of the dependent&#xA;property is null or undefined. This avoids errors from JSLint complaining&#xA;about use of ==, which can be technically confusing.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  isHungry: Ember.computed.none(&apos;food&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;isHungry&apos;); // true&#xA;hamster.set(&apos;food&apos;, &apos;Banana&apos;);&#xA;hamster.get(&apos;isHungry&apos;); // false&#xA;hamster.set(&apos;food&apos;, null);&#xA;hamster.get(&apos;isHungry&apos;); // true&#xA;```" ilk="function" name="none" returns="Ember.ComputedProperty" signature="none(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that returns the inverse boolean value&#xA;of the original value for the dependent property.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var User = Ember.Object.extend({&#xA;  isAnonymous: Ember.computed.not(&apos;loggedIn&apos;)&#xA;});&#xA;  &#xA;var user = User.create({loggedIn: false});&#xA;  &#xA;user.get(&apos;isAnonymous&apos;); // true&#xA;user.set(&apos;loggedIn&apos;, true);&#xA;user.get(&apos;isAnonymous&apos;); // false&#xA;```" ilk="function" name="not" returns="Ember.ComputedProperty" signature="not(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that converts the provided dependent property&#xA;into a boolean value.&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  hasBananas: Ember.computed.bool(&apos;numBananas&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;hasBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 0);&#xA;hamster.get(&apos;hasBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 1);&#xA;hamster.get(&apos;hasBananas&apos;); // true&#xA;hamster.set(&apos;numBananas&apos;, null);&#xA;hamster.get(&apos;hasBananas&apos;); // false&#xA;```" ilk="function" name="bool" returns="Ember.ComputedProperty" signature="bool(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property which matches the original value for the&#xA;dependent property against a given RegExp, returning `true`&#xA;if the value matches the RegExp and `false` if it does not.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var User = Ember.Object.extend({&#xA;  hasValidEmail: Ember.computed.match(&apos;email&apos;, /^.+@.+\..+$/)&#xA;});&#xA;  &#xA;var user = User.create({loggedIn: false});&#xA;  &#xA;user.get(&apos;hasValidEmail&apos;); // false&#xA;user.set(&apos;email&apos;, &apos;&apos;);&#xA;user.get(&apos;hasValidEmail&apos;); // false&#xA;user.set(&apos;email&apos;, &apos;ember_hamster@example.com&apos;);&#xA;user.get(&apos;hasValidEmail&apos;); // true&#xA;```" ilk="function" name="match" returns="Ember.ComputedProperty" signature="match(dependentKey,regexp) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="RegExp" ilk="argument" name="regexp" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the provided dependent property&#xA;is equal to the given value.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  napTime: Ember.computed.equal(&apos;state&apos;, &apos;sleepy&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;napTime&apos;); // false&#xA;hamster.set(&apos;state&apos;, &apos;sleepy&apos;);&#xA;hamster.get(&apos;napTime&apos;); // true&#xA;hamster.set(&apos;state&apos;, &apos;hungry&apos;);&#xA;hamster.get(&apos;napTime&apos;); // false&#xA;```" ilk="function" name="equal" returns="Ember.ComputedProperty" signature="equal(dependentKey,value) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="String|Number|Object" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the provided dependent property&#xA;is greater than the provided value.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  hasTooManyBananas: Ember.computed.gt(&apos;numBananas&apos;, 10)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;hasTooManyBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 3);&#xA;hamster.get(&apos;hasTooManyBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 11);&#xA;hamster.get(&apos;hasTooManyBananas&apos;); // true&#xA;```" ilk="function" name="gt" returns="Ember.ComputedProperty" signature="gt(dependentKey,value) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="Number" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the provided dependent property&#xA;is greater than or equal to the provided value.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  hasTooManyBananas: Ember.computed.gte(&apos;numBananas&apos;, 10)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;hasTooManyBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 3);&#xA;hamster.get(&apos;hasTooManyBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 10);&#xA;hamster.get(&apos;hasTooManyBananas&apos;); // true&#xA;```" ilk="function" name="gte" returns="Ember.ComputedProperty" signature="gte(dependentKey,value) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="Number" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the provided dependent property&#xA;is less than the provided value.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  needsMoreBananas: Ember.computed.lt(&apos;numBananas&apos;, 3)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;needsMoreBananas&apos;); // true&#xA;hamster.set(&apos;numBananas&apos;, 3);&#xA;hamster.get(&apos;needsMoreBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 2);&#xA;hamster.get(&apos;needsMoreBananas&apos;); // true&#xA;```" ilk="function" name="lt" returns="Ember.ComputedProperty" signature="lt(dependentKey,value) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="Number" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="A computed property that returns true if the provided dependent property&#xA;is less than or equal to the provided value.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  needsMoreBananas: Ember.computed.lte(&apos;numBananas&apos;, 3)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;needsMoreBananas&apos;); // true&#xA;hamster.set(&apos;numBananas&apos;, 5);&#xA;hamster.get(&apos;needsMoreBananas&apos;); // false&#xA;hamster.set(&apos;numBananas&apos;, 3);&#xA;hamster.get(&apos;needsMoreBananas&apos;); // true&#xA;```" ilk="function" name="lte" returns="Ember.ComputedProperty" signature="lte(dependentKey,value) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="Number" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="A computed property that performs a logical `and` on the&#xA;original values for the provided dependent properties.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  readyForCamp: Ember.computed.and(&apos;hasTent&apos;, &apos;hasBackpack&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;readyForCamp&apos;); // false&#xA;hamster.set(&apos;hasTent&apos;, true);&#xA;hamster.get(&apos;readyForCamp&apos;); // false&#xA;hamster.set(&apos;hasBackpack&apos;, true);&#xA;hamster.get(&apos;readyForCamp&apos;); // true&#xA;hamster.set(&apos;hasBackpack&apos;, &apos;Yes&apos;);&#xA;hamster.get(&apos;readyForCamp&apos;); // &apos;Yes&apos;&#xA;```" ilk="function" name="and" returns="Ember.ComputedProperty" signature="and(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property which performs a logical `or` on the&#xA;original values for the provided dependent properties.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  readyForRain: Ember.computed.or(&apos;hasJacket&apos;, &apos;hasUmbrella&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;readyForRain&apos;); // false&#xA;hamster.set(&apos;hasUmbrella&apos;, true);&#xA;hamster.get(&apos;readyForRain&apos;); // true&#xA;hamster.set(&apos;hasJacket&apos;, &apos;Yes&apos;);&#xA;hamster.get(&apos;readyForRain&apos;); // &apos;Yes&apos;&#xA;```" ilk="function" name="or" returns="Ember.ComputedProperty" signature="or(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="Creates a new property that is an alias for another property&#xA;on an object. Calls to `get` or `set` this property behave as&#xA;though they were called on the original property.&#xA;  &#xA;```javascript&#xA;var Person = Ember.Object.extend({&#xA;  name: &apos;Alex Matchneer&apos;,&#xA;  nomen: Ember.computed.alias(&apos;name&apos;)&#xA;});&#xA;  &#xA;var alex = Person.create();&#xA;  &#xA;alex.get(&apos;nomen&apos;); // &apos;Alex Matchneer&apos;&#xA;alex.get(&apos;name&apos;);  // &apos;Alex Matchneer&apos;&#xA;  &#xA;alex.set(&apos;nomen&apos;, &apos;@machty&apos;);&#xA;alex.get(&apos;name&apos;);  // &apos;@machty&apos;&#xA;```" ilk="function" name="alias" returns="Ember.ComputedProperty" signature="alias(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="Where `computed.alias` aliases `get` and `set`, and allows for bidirectional&#xA;data flow, `computed.oneWay` only provides an aliased `get`. The `set` will&#xA;not mutate the upstream property, rather causes the current property to&#xA;become the value set. This causes the downstream property to permanently&#xA;diverge from the upstream property.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var User = Ember.Object.extend({&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  nickName: Ember.computed.oneWay(&apos;firstName&apos;)&#xA;});&#xA;  &#xA;var teddy = User.create({&#xA;  firstName: &apos;Teddy&apos;,&#xA;  lastName:  &apos;Zeenny&apos;&#xA;});&#xA;  &#xA;teddy.get(&apos;nickName&apos;);              // &apos;Teddy&apos;&#xA;teddy.set(&apos;nickName&apos;, &apos;TeddyBear&apos;); // &apos;TeddyBear&apos;&#xA;teddy.get(&apos;firstName&apos;);             // &apos;Teddy&apos;&#xA;```" ilk="function" name="oneWay" returns="Ember.ComputedProperty" signature="oneWay(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="This is a more semantically meaningful alias of `computed.oneWay`,&#xA;whose name is somewhat ambiguous as to which direction the data flows." ilk="function" name="reads" returns="Ember.ComputedProperty" signature="reads(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="Where `computed.oneWay` provides oneWay bindings, `computed.readOnly` provides&#xA;a readOnly one way binding. Very often when using `computed.oneWay` one does&#xA;not also want changes to propagate back up, as they will replace the value.&#xA;  &#xA;This prevents the reverse flow, and also throws an exception when it occurs.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var User = Ember.Object.extend({&#xA;  firstName: null,&#xA;  lastName: null,&#xA;  nickName: Ember.computed.readOnly(&apos;firstName&apos;)&#xA;});&#xA;  &#xA;var teddy = User.create({&#xA;  firstName: &apos;Teddy&apos;,&#xA;  lastName:  &apos;Zeenny&apos;&#xA;});&#xA;  &#xA;teddy.get(&apos;nickName&apos;);              // &apos;Teddy&apos;&#xA;teddy.set(&apos;nickName&apos;, &apos;TeddyBear&apos;); // throws Exception&#xA;// throw new Ember.Error(&apos;Cannot Set: nickName on: &lt;User:ember27288&gt;&apos; );`&#xA;teddy.get(&apos;firstName&apos;);             // &apos;Teddy&apos;&#xA;```" ilk="function" name="readOnly" returns="Ember.ComputedProperty" signature="readOnly(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="Creates a new property that is an alias for another property&#xA;on an object. Calls to `get` or `set` this property behave as&#xA;though they were called on the original property, but also&#xA;print a deprecation warning." ilk="function" name="deprecatingAlias" returns="Ember.ComputedProperty" signature="deprecatingAlias(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that returns the sum of the values&#xA;in the dependent array." ilk="function" name="sum" returns="Ember.ComputedProperty" signature="sum(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that calculates the maximum value in the&#xA;dependent array. This will return `-Infinity` when the dependent&#xA;array is empty.&#xA;  &#xA;```javascript&#xA;var Person = Ember.Object.extend({&#xA;  childAges: Ember.computed.mapBy(&apos;children&apos;, &apos;age&apos;),&#xA;  maxChildAge: Ember.computed.max(&apos;childAges&apos;)&#xA;});&#xA;  &#xA;var lordByron = Person.create({ children: [] });&#xA;  &#xA;lordByron.get(&apos;maxChildAge&apos;); // -Infinity&#xA;lordByron.get(&apos;children&apos;).pushObject({&#xA;  name: &apos;Augusta Ada Byron&apos;, age: 7&#xA;});&#xA;lordByron.get(&apos;maxChildAge&apos;); // 7&#xA;lordByron.get(&apos;children&apos;).pushObjects([{&#xA;  name: &apos;Allegra Byron&apos;,&#xA;  age: 5&#xA;}, {&#xA;  name: &apos;Elizabeth Medora Leigh&apos;,&#xA;  age: 8&#xA;}]);&#xA;lordByron.get(&apos;maxChildAge&apos;); // 8&#xA;```" ilk="function" name="max" returns="Ember.ComputedProperty" signature="max(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property that calculates the minimum value in the&#xA;dependent array. This will return `Infinity` when the dependent&#xA;array is empty.&#xA;  &#xA;```javascript&#xA;var Person = Ember.Object.extend({&#xA;  childAges: Ember.computed.mapBy(&apos;children&apos;, &apos;age&apos;),&#xA;  minChildAge: Ember.computed.min(&apos;childAges&apos;)&#xA;});&#xA;  &#xA;var lordByron = Person.create({ children: [] });&#xA;  &#xA;lordByron.get(&apos;minChildAge&apos;); // Infinity&#xA;lordByron.get(&apos;children&apos;).pushObject({&#xA;  name: &apos;Augusta Ada Byron&apos;, age: 7&#xA;});&#xA;lordByron.get(&apos;minChildAge&apos;); // 7&#xA;lordByron.get(&apos;children&apos;).pushObjects([{&#xA;  name: &apos;Allegra Byron&apos;,&#xA;  age: 5&#xA;}, {&#xA;  name: &apos;Elizabeth Medora Leigh&apos;,&#xA;  age: 8&#xA;}]);&#xA;lordByron.get(&apos;minChildAge&apos;); // 5&#xA;```" ilk="function" name="min" returns="Ember.ComputedProperty" signature="min(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="Returns an array mapped via the callback&#xA;  &#xA;The callback method you provide should have the following signature.&#xA;`item` is the current item in the iteration.&#xA;`index` is the integer index of the current item in the iteration.&#xA;  &#xA;```javascript&#xA;function(item, index);&#xA;```&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  excitingChores: Ember.computed.map(&apos;chores&apos;, function(chore, index) {&#xA;    return chore.toUpperCase() + &apos;!&apos;;&#xA;  })&#xA;});&#xA;  &#xA;var hamster = Hamster.create({&#xA;  chores: [&apos;clean&apos;, &apos;write more unit tests&apos;]&#xA;});&#xA;  &#xA;hamster.get(&apos;excitingChores&apos;); // [&apos;CLEAN!&apos;, &apos;WRITE MORE UNIT TESTS!&apos;]&#xA;```" ilk="function" name="map" returns="Ember.ComputedProperty" signature="map(dependentKey,callback) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="public" doc="Returns an array mapped to the specified key.&#xA;  &#xA;```javascript&#xA;var Person = Ember.Object.extend({&#xA;  childAges: Ember.computed.mapBy(&apos;children&apos;, &apos;age&apos;)&#xA;});&#xA;  &#xA;var lordByron = Person.create({ children: [] });&#xA;  &#xA;lordByron.get(&apos;childAges&apos;); // []&#xA;lordByron.get(&apos;children&apos;).pushObject({ name: &apos;Augusta Ada Byron&apos;, age: 7 });&#xA;lordByron.get(&apos;childAges&apos;); // [7]&#xA;lordByron.get(&apos;children&apos;).pushObjects([{&#xA;  name: &apos;Allegra Byron&apos;,&#xA;  age: 5&#xA;}, {&#xA;  name: &apos;Elizabeth Medora Leigh&apos;,&#xA;  age: 8&#xA;}]);&#xA;lordByron.get(&apos;childAges&apos;); // [7, 5, 8]&#xA;```" ilk="function" name="mapBy" returns="Ember.ComputedProperty" signature="mapBy(dependentKey,propertyKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="String" ilk="argument" name="propertyKey" />
          </scope>
          <scope attributes="public" doc="Filters the array by the callback.&#xA;  &#xA;The callback method you provide should have the following signature.&#xA;`item` is the current item in the iteration.&#xA;`index` is the integer index of the current item in the iteration.&#xA;`array` is the dependant array itself.&#xA;  &#xA;```javascript&#xA;function(item, index, array);&#xA;```&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  remainingChores: Ember.computed.filter(&apos;chores&apos;, function(chore, index, array) {&#xA;    return !chore.done;&#xA;  })&#xA;});&#xA;  &#xA;var hamster = Hamster.create({&#xA;  chores: [&#xA;    { name: &apos;cook&apos;, done: true },&#xA;    { name: &apos;clean&apos;, done: true },&#xA;    { name: &apos;write more unit tests&apos;, done: false }&#xA;  ]&#xA;});&#xA;  &#xA;hamster.get(&apos;remainingChores&apos;); // [{name: &apos;write more unit tests&apos;, done: false}]&#xA;```" ilk="function" name="filter" returns="Ember.ComputedProperty" signature="filter(dependentKey,callback) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="Function" ilk="argument" name="callback" />
          </scope>
          <scope attributes="public" doc="Filters the array by the property and value&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  remainingChores: Ember.computed.filterBy(&apos;chores&apos;, &apos;done&apos;, false)&#xA;});&#xA;  &#xA;var hamster = Hamster.create({&#xA;  chores: [&#xA;    { name: &apos;cook&apos;, done: true },&#xA;    { name: &apos;clean&apos;, done: true },&#xA;    { name: &apos;write more unit tests&apos;, done: false }&#xA;  ]&#xA;});&#xA;  &#xA;hamster.get(&apos;remainingChores&apos;); // [{ name: &apos;write more unit tests&apos;, done: false }]&#xA;```" ilk="function" name="filterBy" returns="Ember.ComputedProperty" signature="filterBy(dependentKey,propertyKey,value) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
            <variable citdl="String" ilk="argument" name="propertyKey" />
            <variable citdl="*" ilk="argument" name="value" />
          </scope>
          <scope attributes="public" doc="A computed property which returns a new array with all the unique&#xA;elements from one or more dependent arrays.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  uniqueFruits: Ember.computed.uniq(&apos;fruits&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create({&#xA;  fruits: [&#xA;    &apos;banana&apos;,&#xA;    &apos;grape&apos;,&#xA;    &apos;kale&apos;,&#xA;    &apos;banana&apos;&#xA;  ]&#xA;});&#xA;  &#xA;hamster.get(&apos;uniqueFruits&apos;); // [&apos;banana&apos;, &apos;grape&apos;, &apos;kale&apos;]&#xA;```" ilk="function" name="uniq" returns="Ember.ComputedProperty" signature="uniq(propertyKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="propertyKey" />
          </scope>
          <scope attributes="public" doc="Alias for [Ember.computed.uniq](/api/#method_computed_uniq)." ilk="function" name="union" returns="Ember.ComputedProperty" signature="union(propertyKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="propertyKey" />
          </scope>
          <scope attributes="public" doc="A computed property which returns a new array with all the duplicated&#xA;elements from two or more dependent arrays.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var obj = Ember.Object.extend({&#xA;  friendsInCommon: Ember.computed.intersect(&apos;adaFriends&apos;, &apos;charlesFriends&apos;)&#xA;}).create({&#xA;  adaFriends: [&apos;Charles Babbage&apos;, &apos;John Hobhouse&apos;, &apos;William King&apos;, &apos;Mary Somerville&apos;],&#xA;  charlesFriends: [&apos;William King&apos;, &apos;Mary Somerville&apos;, &apos;Ada Lovelace&apos;, &apos;George Peacock&apos;]&#xA;});&#xA;  &#xA;obj.get(&apos;friendsInCommon&apos;); // [&apos;William King&apos;, &apos;Mary Somerville&apos;]&#xA;```" ilk="function" name="intersect" returns="Ember.ComputedProperty" signature="intersect(propertyKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="propertyKey" />
          </scope>
          <scope attributes="public" doc="A computed property which returns a new array with all the&#xA;properties from the first dependent array that are not in the second&#xA;dependent array.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  likes: [&apos;banana&apos;, &apos;grape&apos;, &apos;kale&apos;],&#xA;  wants: Ember.computed.setDiff(&apos;likes&apos;, &apos;fruits&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create({&#xA;  fruits: [&#xA;    &apos;grape&apos;,&#xA;    &apos;kale&apos;,&#xA;  ]&#xA;});&#xA;  &#xA;hamster.get(&apos;wants&apos;); // [&apos;banana&apos;]&#xA;```" ilk="function" name="setDiff" returns="Ember.ComputedProperty" signature="setDiff(setAProperty,setBProperty) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="setAProperty" />
            <variable citdl="String" ilk="argument" name="setBProperty" />
          </scope>
          <scope attributes="public" doc="A computed property that returns the array of values&#xA;for the provided dependent properties.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var Hamster = Ember.Object.extend({&#xA;  clothes: Ember.computed.collect(&apos;hat&apos;, &apos;shirt&apos;)&#xA;});&#xA;  &#xA;var hamster = Hamster.create();&#xA;  &#xA;hamster.get(&apos;clothes&apos;); // [null, null]&#xA;hamster.set(&apos;hat&apos;, &apos;Camp Hat&apos;);&#xA;hamster.set(&apos;shirt&apos;, &apos;Camp Shirt&apos;);&#xA;hamster.get(&apos;clothes&apos;); // [&apos;Camp Hat&apos;, &apos;Camp Shirt&apos;]&#xA;```" ilk="function" name="collect" returns="Ember.ComputedProperty" signature="collect(dependentKey) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="dependentKey" />
          </scope>
          <scope attributes="public" doc="A computed property which returns a new array with all the&#xA;properties from the first dependent array sorted based on a property&#xA;or sort function.&#xA;  &#xA;The callback method you provide should have the following signature:&#xA;  &#xA;```javascript&#xA;function(itemA, itemB);&#xA;```&#xA;  &#xA;- `itemA` the first item to compare.&#xA;- `itemB` the second item to compare.&#xA;  &#xA;This function should return negative number (e.g. `-1`) when `itemA` should come before&#xA;`itemB`. It should return positive number (e.g. `1`) when `itemA` should come after&#xA;`itemB`. If the `itemA` and `itemB` are equal this function should return `0`.&#xA;  &#xA;Therefore, if this function is comparing some numeric values, simple `itemA - itemB` or&#xA;`itemA.get( &apos;foo&apos; ) - itemB.get( &apos;foo&apos; )` can be used instead of series of `if`.&#xA;  &#xA;Example&#xA;  &#xA;```javascript&#xA;var ToDoList = Ember.Object.extend({&#xA;  // using standard ascending sort&#xA;  todosSorting: [&apos;name&apos;],&#xA;  sortedTodos: Ember.computed.sort(&apos;todos&apos;, &apos;todosSorting&apos;),&#xA;  &#xA;  // using descending sort&#xA;  todosSortingDesc: [&apos;name:desc&apos;],&#xA;  sortedTodosDesc: Ember.computed.sort(&apos;todos&apos;, &apos;todosSortingDesc&apos;),&#xA;  &#xA;  // using a custom sort function&#xA;  priorityTodos: Ember.computed.sort(&apos;todos&apos;, function(a, b){&#xA;    if (a.priority &gt; b.priority) {&#xA;      return 1;&#xA;    } else if (a.priority &lt; b.priority) {&#xA;      return -1;&#xA;    }&#xA;  &#xA;    return 0;&#xA;  })&#xA;});&#xA;  &#xA;var todoList = ToDoList.create({todos: [&#xA;  { name: &apos;Unit Test&apos;, priority: 2 },&#xA;  { name: &apos;Documentation&apos;, priority: 3 },&#xA;  { name: &apos;Release&apos;, priority: 1 }&#xA;]});&#xA;  &#xA;todoList.get(&apos;sortedTodos&apos;);      // [{ name:&apos;Documentation&apos;, priority:3 }, { name:&apos;Release&apos;, priority:1 }, { name:&apos;Unit Test&apos;, priority:2 }]&#xA;todoList.get(&apos;sortedTodosDesc&apos;);  // [{ name:&apos;Unit Test&apos;, priority:2 }, { name:&apos;Release&apos;, priority:1 }, { name:&apos;Documentation&apos;, priority:3 }]&#xA;todoList.get(&apos;priorityTodos&apos;);    // [{ name:&apos;Release&apos;, priority:1 }, { name:&apos;Unit Test&apos;, priority:2 }, { name:&apos;Documentation&apos;, priority:3 }]&#xA;```" ilk="function" name="sort" returns="Ember.ComputedProperty" signature="sort(itemsKey,sortDefinition) =&gt; Ember.ComputedProperty">
            <variable citdl="String" ilk="argument" name="itemsKey" />
            <variable citdl="String or Function" doc="a dependent key to an&#xA;array of sort properties (add `:desc` to the arrays sort properties to sort descending) or a function to use when sorting" ilk="argument" name="sortDefinition" />
          </scope>
        </scope>
        <scope doc="Namespace for injection helper methods." ilk="class" name="inject">
          <scope attributes="public" doc="Creates a property that lazily looks up another controller in the container.&#xA;Can only be used when defining another controller.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;App.PostController = Ember.Controller.extend({&#xA;  posts: Ember.inject.controller()&#xA;});&#xA;```&#xA;  &#xA;This example will create a `posts` property on the `post` controller that&#xA;looks up the `posts` controller in the container, making it easy to&#xA;reference other controllers. This is functionally equivalent to:&#xA;  &#xA;```javascript&#xA;App.PostController = Ember.Controller.extend({&#xA;  needs: &apos;posts&apos;,&#xA;  posts: Ember.computed.alias(&apos;controllers.posts&apos;)&#xA;});&#xA;```" ilk="function" name="controller" returns="Ember.InjectedProperty" signature="controller(name) =&gt; Ember.InjectedProperty">
            <variable citdl="String" doc="(optional) name of the controller to inject, defaults&#xA;       to the property&apos;s name" ilk="argument" name="name" />
          </scope>
          <scope attributes="public" doc="Creates a property that lazily looks up a service in the container. There&#xA;are no restrictions as to what objects a service can be injected into.&#xA;  &#xA;Example:&#xA;  &#xA;```javascript&#xA;App.ApplicationRoute = Ember.Route.extend({&#xA;  authManager: Ember.inject.service(&apos;auth&apos;),&#xA;  &#xA;  model: function() {&#xA;    return this.get(&apos;authManager&apos;).findCurrentUser();&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;This example will create an `authManager` property on the application route&#xA;that looks up the `auth` service in the container, making it easily&#xA;accessible in the `model` hook." ilk="function" name="service" returns="Ember.InjectedProperty" signature="service(name) =&gt; Ember.InjectedProperty">
            <variable citdl="String" doc="(optional) name of the service to inject, defaults to&#xA;       the property&apos;s name" ilk="argument" name="name" />
          </scope>
        </scope>
        <scope doc="Runs the passed target and method inside of a RunLoop, ensuring any&#xA;deferred actions including bindings and views updates are flushed at the&#xA;end.&#xA;  &#xA;Normally you should not need to invoke this method yourself. However if&#xA;you are implementing raw event handlers when interfacing with other&#xA;libraries or plugins, you should probably wrap all of your code inside this&#xA;call.&#xA;  &#xA;```javascript&#xA;run(function() {&#xA;  // code to be executed within a RunLoop&#xA;});&#xA;```" ilk="class" name="run">
          <scope attributes="public" doc="If no run-loop is present, it creates a new one. If a run loop is&#xA;present it will queue itself to run on the existing run-loops action&#xA;queue.&#xA;  &#xA;Please note: This is not for normal usage, and should be used sparingly.&#xA;  &#xA;If invoked when not within a run loop:&#xA;  &#xA;```javascript&#xA;run.join(function() {&#xA;  // creates a new run-loop&#xA;});&#xA;```&#xA;  &#xA;Alternatively, if called within an existing run loop:&#xA;  &#xA;```javascript&#xA;run(function() {&#xA;  // creates a new run-loop&#xA;  run.join(function() {&#xA;    // joins with the existing run-loop, and queues for invocation on&#xA;    // the existing run-loops action queue.&#xA;  });&#xA;});&#xA;```" ilk="function" name="join" returns="Object" signature="join(target,method,args*) =&gt; Object">
            <variable citdl="Object" doc="target of method to call" ilk="argument" name="target" />
            <variable citdl="Function|String" doc="Method to invoke.&#xA;  May be a function or a string. If you pass a string&#xA;  then it will be looked up on the passed target." ilk="argument" name="method" />
            <variable citdl="Object" doc="Any additional arguments you wish to pass to the method." ilk="argument" name="args*" />
          </scope>
          <scope attributes="public" doc="Allows you to specify which context to call the specified function in while&#xA;adding the execution of that function to the Ember run loop. This ability&#xA;makes this method a great way to asynchronously integrate third-party libraries&#xA;into your Ember application.&#xA;  &#xA;`run.bind` takes two main arguments, the desired context and the function to&#xA;invoke in that context. Any additional arguments will be supplied as arguments&#xA;to the function that is passed in.&#xA;  &#xA;Let&apos;s use the creation of a TinyMCE component as an example. Currently,&#xA;TinyMCE provides a setup configuration option we can use to do some processing&#xA;after the TinyMCE instance is initialized but before it is actually rendered.&#xA;We can use that setup option to do some additional setup for our component.&#xA;The component itself could look something like the following:&#xA;  &#xA;```javascript&#xA;App.RichTextEditorComponent = Ember.Component.extend({&#xA;  initializeTinyMCE: Ember.on(&apos;didInsertElement&apos;, function() {&#xA;    tinymce.init({&#xA;      selector: &apos;#&apos; + this.$().prop(&apos;id&apos;),&#xA;      setup: Ember.run.bind(this, this.setupEditor)&#xA;    });&#xA;  }),&#xA;  &#xA;  setupEditor: function(editor) {&#xA;    this.set(&apos;editor&apos;, editor);&#xA;  &#xA;    editor.on(&apos;change&apos;, function() {&#xA;      console.log(&apos;content changed!&apos;);&#xA;    });&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;In this example, we use Ember.run.bind to bind the setupEditor method to the&#xA;context of the App.RichTextEditorComponent and to have the invocation of that&#xA;method be safely handled and executed by the Ember run loop." ilk="function" name="bind" returns="Function" signature="bind(target,method,args*) =&gt; Function">
            <variable citdl="Object" doc="target of method to call" ilk="argument" name="target" />
            <variable citdl="Function|String" doc="Method to invoke.&#xA;  May be a function or a string. If you pass a string&#xA;  then it will be looked up on the passed target." ilk="argument" name="method" />
            <variable citdl="Object" doc="Any additional arguments you wish to pass to the method." ilk="argument" name="args*" />
          </scope>
          <scope attributes="public" doc="Begins a new RunLoop. Any deferred actions invoked after the begin will&#xA;be buffered until you invoke a matching call to `run.end()`. This is&#xA;a lower-level way to use a RunLoop instead of using `run()`.&#xA;  &#xA;```javascript&#xA;run.begin();&#xA;// code to be executed within a RunLoop&#xA;run.end();&#xA;```" ilk="function" name="begin" returns="Void" signature="begin() =&gt; Void" />
          <scope attributes="public" doc="Ends a RunLoop. This must be called sometime after you call&#xA;`run.begin()` to flush any deferred actions. This is a lower-level way&#xA;to use a RunLoop instead of using `run()`.&#xA;  &#xA;```javascript&#xA;run.begin();&#xA;// code to be executed within a RunLoop&#xA;run.end();&#xA;```" ilk="function" name="end" returns="Void" signature="end() =&gt; Void" />
          <variable attributes="property private" citdl="Array" doc="Array of named queues. This array determines the order in which queues&#xA;are flushed at the end of the RunLoop. You can define your own queues by&#xA;simply adding the queue name to this array. Normally you should not need&#xA;to inspect or modify this property." name="run" />
          <scope attributes="public" doc="Adds the passed target/method and any optional arguments to the named&#xA;queue to be executed at the end of the RunLoop. If you have not already&#xA;started a RunLoop when calling this method one will be started for you&#xA;automatically.&#xA;  &#xA;At the end of a RunLoop, any methods scheduled in this way will be invoked.&#xA;Methods will be invoked in an order matching the named queues defined in&#xA;the `run.queues` property.&#xA;  &#xA;```javascript&#xA;run.schedule(&apos;sync&apos;, this, function() {&#xA;  // this will be executed in the first RunLoop queue, when bindings are synced&#xA;  console.log(&apos;scheduled on sync queue&apos;);&#xA;});&#xA;  &#xA;run.schedule(&apos;actions&apos;, this, function() {&#xA;  // this will be executed in the &apos;actions&apos; queue, after bindings have synced.&#xA;  console.log(&apos;scheduled on actions queue&apos;);&#xA;});&#xA;  &#xA;// Note the functions will be run in order based on the run queues order.&#xA;// Output would be:&#xA;//   scheduled on sync queue&#xA;//   scheduled on actions queue&#xA;```" ilk="function" name="schedule" returns="Void" signature="schedule(queue,target,method,arguments*) =&gt; Void">
            <variable citdl="String" doc="The name of the queue to schedule against.&#xA;  Default queues are &apos;sync&apos; and &apos;actions&apos;" ilk="argument" name="queue" />
            <variable citdl="Object" doc="target object to use as the context when invoking a method." ilk="argument" name="target" />
            <variable citdl="String|Function" doc="The method to invoke. If you pass a string it&#xA;  will be resolved on the target object at the time the scheduled item is&#xA;  invoked allowing you to change the target function." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to be passed to the queued method." ilk="argument" name="arguments*" />
          </scope>
          <scope attributes="private" doc="Immediately flushes any events scheduled in the &apos;sync&apos; queue. Bindings&#xA;use this queue so this method is a useful way to immediately force all&#xA;bindings in the application to sync.&#xA;  &#xA;You should call this method anytime you need any changed state to propagate&#xA;throughout the app immediately without repainting the UI (which happens&#xA;in the later &apos;render&apos; queue added by the `ember-views` package).&#xA;  &#xA;```javascript&#xA;run.sync();&#xA;```" ilk="function" name="sync" returns="Void" signature="sync() =&gt; Void" />
          <scope attributes="public" doc="Invokes the passed target/method and optional arguments after a specified&#xA;period of time. The last parameter of this method must always be a number&#xA;of milliseconds.&#xA;  &#xA;You should use this method whenever you need to run some action after a&#xA;period of time instead of using `setTimeout()`. This method will ensure that&#xA;items that expire during the same script execution cycle all execute&#xA;together, which is often more efficient than using a real setTimeout.&#xA;  &#xA;```javascript&#xA;run.later(myContext, function() {&#xA;  // code here will execute within a RunLoop in about 500ms with this == myContext&#xA;}, 500);&#xA;```" ilk="function" name="later" returns="*" signature="later(target,method,args*,wait) =&gt; *">
            <variable citdl="Object" doc="target of method to invoke" ilk="argument" name="target" />
            <variable citdl="Function|String" doc="The method to invoke.&#xA;  If you pass a string it will be resolved on the&#xA;  target at the time the method is invoked." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to pass to the timeout." ilk="argument" name="args*" />
            <variable citdl="Number" doc="Number of milliseconds to wait." ilk="argument" name="wait" />
          </scope>
          <scope attributes="public" doc="Schedule a function to run one time during the current RunLoop. This is equivalent&#xA;to calling `scheduleOnce` with the &quot;actions&quot; queue." ilk="function" name="once" returns="Object" signature="once(target,method,args*) =&gt; Object">
            <variable citdl="Object" doc="The target of the method to invoke." ilk="argument" name="target" />
            <variable citdl="Function|String" doc="The method to invoke.&#xA;  If you pass a string it will be resolved on the&#xA;  target at the time the method is invoked." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to pass to the timeout." ilk="argument" name="args*" />
          </scope>
          <scope attributes="public" doc="Schedules a function to run one time in a given queue of the current RunLoop.&#xA;Calling this method with the same queue/target/method combination will have&#xA;no effect (past the initial call).&#xA;  &#xA;Note that although you can pass optional arguments these will not be&#xA;considered when looking for duplicates. New arguments will replace previous&#xA;calls.&#xA;  &#xA;```javascript&#xA;function sayHi() {&#xA;  console.log(&apos;hi&apos;);&#xA;}&#xA;  &#xA;run(function() {&#xA;  run.scheduleOnce(&apos;afterRender&apos;, myContext, sayHi);&#xA;  run.scheduleOnce(&apos;afterRender&apos;, myContext, sayHi);&#xA;  // sayHi will only be executed once, in the afterRender queue of the RunLoop&#xA;});&#xA;```&#xA;  &#xA;Also note that passing an anonymous function to `run.scheduleOnce` will&#xA;not prevent additional calls with an identical anonymous function from&#xA;scheduling the items multiple times, e.g.:&#xA;  &#xA;```javascript&#xA;function scheduleIt() {&#xA;  run.scheduleOnce(&apos;actions&apos;, myContext, function() {&#xA;    console.log(&apos;Closure&apos;);&#xA;  });&#xA;}&#xA;  &#xA;scheduleIt();&#xA;scheduleIt();&#xA;  &#xA;// &quot;Closure&quot; will print twice, even though we&apos;re using `run.scheduleOnce`,&#xA;// because the function we pass to it is anonymous and won&apos;t match the&#xA;// previously scheduled operation.&#xA;```&#xA;  &#xA;Available queues, and their order, can be found at `run.queues`" ilk="function" name="scheduleOnce" returns="Object" signature="scheduleOnce(queue,target,method,args*) =&gt; Object">
            <variable citdl="String" doc="The name of the queue to schedule against. Default queues are &apos;sync&apos; and &apos;actions&apos;." ilk="argument" name="queue" />
            <variable citdl="Object" doc="The target of the method to invoke." ilk="argument" name="target" />
            <variable citdl="Function|String" doc="The method to invoke.&#xA;  If you pass a string it will be resolved on the&#xA;  target at the time the method is invoked." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to pass to the timeout." ilk="argument" name="args*" />
          </scope>
          <scope attributes="public" doc="Schedules an item to run from within a separate run loop, after&#xA;control has been returned to the system. This is equivalent to calling&#xA;`run.later` with a wait time of 1ms.&#xA;  &#xA;```javascript&#xA;run.next(myContext, function() {&#xA;  // code to be executed in the next run loop,&#xA;  // which will be scheduled after the current one&#xA;});&#xA;```&#xA;  &#xA;Multiple operations scheduled with `run.next` will coalesce&#xA;into the same later run loop, along with any other operations&#xA;scheduled by `run.later` that expire right around the same&#xA;time that `run.next` operations will fire.&#xA;  &#xA;Note that there are often alternatives to using `run.next`.&#xA;For instance, if you&apos;d like to schedule an operation to happen&#xA;after all DOM element operations have completed within the current&#xA;run loop, you can make use of the `afterRender` run loop queue (added&#xA;by the `ember-views` package, along with the preceding `render` queue&#xA;where all the DOM element operations happen). Example:&#xA;  &#xA;```javascript&#xA;App.MyCollectionView = Ember.CollectionView.extend({&#xA;  didInsertElement: function() {&#xA;    run.scheduleOnce(&apos;afterRender&apos;, this, &apos;processChildElements&apos;);&#xA;  },&#xA;  processChildElements: function() {&#xA;    // ... do something with collectionView&apos;s child view&#xA;    // elements after they&apos;ve finished rendering, which&#xA;    // can&apos;t be done within the CollectionView&apos;s&#xA;    // `didInsertElement` hook because that gets run&#xA;    // before the child elements have been added to the DOM.&#xA;  }&#xA;});&#xA;```&#xA;  &#xA;One benefit of the above approach compared to using `run.next` is&#xA;that you will be able to perform DOM/CSS operations before unprocessed&#xA;elements are rendered to the screen, which may prevent flickering or&#xA;other artifacts caused by delaying processing until after rendering.&#xA;  &#xA;The other major benefit to the above approach is that `run.next`&#xA;introduces an element of non-determinism, which can make things much&#xA;harder to test, due to its reliance on `setTimeout`; it&apos;s much harder&#xA;to guarantee the order of scheduled operations when they are scheduled&#xA;outside of the current run loop, i.e. with `run.next`." ilk="function" name="next" returns="Object" signature="next(target,method,args*) =&gt; Object">
            <variable citdl="Object" doc="target of method to invoke" ilk="argument" name="target" />
            <variable citdl="Function|String" doc="The method to invoke.&#xA;  If you pass a string it will be resolved on the&#xA;  target at the time the method is invoked." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to pass to the timeout." ilk="argument" name="args*" />
          </scope>
          <scope attributes="public" doc="Cancels a scheduled item. Must be a value returned by `run.later()`,&#xA;`run.once()`, `run.scheduleOnce()`, `run.next()`, `run.debounce()`, or&#xA;`run.throttle()`.&#xA;  &#xA;```javascript&#xA;var runNext = run.next(myContext, function() {&#xA;  // will not be executed&#xA;});&#xA;  &#xA;run.cancel(runNext);&#xA;  &#xA;var runLater = run.later(myContext, function() {&#xA;  // will not be executed&#xA;}, 500);&#xA;  &#xA;run.cancel(runLater);&#xA;  &#xA;var runScheduleOnce = run.scheduleOnce(&apos;afterRender&apos;, myContext, function() {&#xA;  // will not be executed&#xA;});&#xA;  &#xA;run.cancel(runScheduleOnce);&#xA;  &#xA;var runOnce = run.once(myContext, function() {&#xA;  // will not be executed&#xA;});&#xA;  &#xA;run.cancel(runOnce);&#xA;  &#xA;var throttle = run.throttle(myContext, function() {&#xA;  // will not be executed&#xA;}, 1, false);&#xA;  &#xA;run.cancel(throttle);&#xA;  &#xA;var debounce = run.debounce(myContext, function() {&#xA;  // will not be executed&#xA;}, 1);&#xA;  &#xA;run.cancel(debounce);&#xA;  &#xA;var debounceImmediate = run.debounce(myContext, function() {&#xA;  // will be executed since we passed in true (immediate)&#xA;}, 100, true);&#xA;  &#xA;// the 100ms delay until this method can be called again will be cancelled&#xA;run.cancel(debounceImmediate);&#xA;```" ilk="function" name="cancel" returns="Boolean" signature="cancel(timer) =&gt; Boolean">
            <variable citdl="Object" doc="Timer object to cancel" ilk="argument" name="timer" />
          </scope>
          <scope attributes="public" doc="Delay calling the target method until the debounce period has elapsed&#xA;with no additional debounce calls. If `debounce` is called again before&#xA;the specified time has elapsed, the timer is reset and the entire period&#xA;must pass again before the target method is called.&#xA;  &#xA;This method should be used when an event may be called multiple times&#xA;but the action should only be called once when the event is done firing.&#xA;A common example is for scroll events where you only want updates to&#xA;happen once scrolling has ceased.&#xA;  &#xA;```javascript&#xA;function whoRan() {&#xA;  console.log(this.name + &apos; ran.&apos;);&#xA;}&#xA;  &#xA;var myContext = { name: &apos;debounce&apos; };&#xA;  &#xA;run.debounce(myContext, whoRan, 150);&#xA;  &#xA;// less than 150ms passes&#xA;run.debounce(myContext, whoRan, 150);&#xA;  &#xA;// 150ms passes&#xA;// whoRan is invoked with context myContext&#xA;// console logs &apos;debounce ran.&apos; one time.&#xA;```&#xA;  &#xA;Immediate allows you to run the function immediately, but debounce&#xA;other calls for this function until the wait time has elapsed. If&#xA;`debounce` is called again before the specified time has elapsed,&#xA;the timer is reset and the entire period must pass again before&#xA;the method can be called again.&#xA;  &#xA;```javascript&#xA;function whoRan() {&#xA;  console.log(this.name + &apos; ran.&apos;);&#xA;}&#xA;  &#xA;var myContext = { name: &apos;debounce&apos; };&#xA;  &#xA;run.debounce(myContext, whoRan, 150, true);&#xA;  &#xA;// console logs &apos;debounce ran.&apos; one time immediately.&#xA;// 100ms passes&#xA;run.debounce(myContext, whoRan, 150, true);&#xA;  &#xA;// 150ms passes and nothing else is logged to the console and&#xA;// the debouncee is no longer being watched&#xA;run.debounce(myContext, whoRan, 150, true);&#xA;  &#xA;// console logs &apos;debounce ran.&apos; one time immediately.&#xA;// 150ms passes and nothing else is logged to the console and&#xA;// the debouncee is no longer being watched&#xA;  &#xA;```" ilk="function" name="debounce" returns="Array" signature="debounce(target,method,args*,wait,immediate) =&gt; Array">
            <variable citdl="Object" doc="target of method to invoke" ilk="argument" name="target" />
            <variable citdl="Function|String" doc="The method to invoke.&#xA;  May be a function or a string. If you pass a string&#xA;  then it will be looked up on the passed target." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to pass to the timeout." ilk="argument" name="args*" />
            <variable citdl="Number" doc="Number of milliseconds to wait." ilk="argument" name="wait" />
            <variable citdl="Boolean" doc="Trigger the function on the leading instead&#xA;  of the trailing edge of the wait interval. Defaults to false." ilk="argument" name="immediate" />
          </scope>
          <scope attributes="public" doc="Ensure that the target method is never called more frequently than&#xA;the specified spacing period. The target method is called immediately.&#xA;  &#xA;```javascript&#xA;function whoRan() {&#xA;  console.log(this.name + &apos; ran.&apos;);&#xA;}&#xA;  &#xA;var myContext = { name: &apos;throttle&apos; };&#xA;  &#xA;run.throttle(myContext, whoRan, 150);&#xA;// whoRan is invoked with context myContext&#xA;// console logs &apos;throttle ran.&apos;&#xA;  &#xA;// 50ms passes&#xA;run.throttle(myContext, whoRan, 150);&#xA;  &#xA;// 50ms passes&#xA;run.throttle(myContext, whoRan, 150);&#xA;  &#xA;// 150ms passes&#xA;run.throttle(myContext, whoRan, 150);&#xA;// whoRan is invoked with context myContext&#xA;// console logs &apos;throttle ran.&apos;&#xA;```" ilk="function" name="throttle" returns="Array" signature="throttle(target,method,args*,spacing,immediate) =&gt; Array">
            <variable citdl="Object" doc="target of method to invoke" ilk="argument" name="target" />
            <variable citdl="Function|String" doc="The method to invoke.&#xA;  May be a function or a string. If you pass a string&#xA;  then it will be looked up on the passed target." ilk="argument" name="method" />
            <variable citdl="Object" doc="Optional arguments to pass to the timeout." ilk="argument" name="args*" />
            <variable citdl="Number" doc="Number of milliseconds to space out requests." ilk="argument" name="spacing" />
            <variable citdl="Boolean" doc="Trigger the function on the leading instead&#xA;  of the trailing edge of the wait interval. Defaults to true." ilk="argument" name="immediate" />
          </scope>
          <scope attributes="private" doc="Add a new named queue after the specified queue.&#xA;  &#xA;The queue to add will only be added once." ilk="function" name="_addQueue" signature="_addQueue(name,after)">
            <variable citdl="String" doc="the name of the queue to add." ilk="argument" name="name" />
            <variable citdl="String" doc="the name of the queue to add after." ilk="argument" name="after" />
          </scope>
          <scope attributes="public" doc="Set a list of properties on an object. These properties are set inside&#xA;a single `beginPropertyChanges` and `endPropertyChanges` batch, so&#xA;observers will be buffered.&#xA;  &#xA;```javascript&#xA;var anObject = Ember.Object.create();&#xA;  &#xA;anObject.setProperties({&#xA;  firstName: &apos;Stanley&apos;,&#xA;  lastName: &apos;Stuart&apos;,&#xA;  age: 21&#xA;});&#xA;```" ilk="function" name="setProperties" signature="setProperties(obj,properties)">
            <variable ilk="argument" name="obj" />
            <variable citdl="Object" ilk="argument" name="properties" />
          </scope>
        </scope>
        <scope ilk="namespace" name="stream">
          <scope ilk="class" name="Stream" />
        </scope>
        <scope ilk="namespace" name="streams">
          <scope ilk="class" name="Dependency" />
          <scope ilk="namespace" name="Ember">
            <scope ilk="class" name="stream">
              <scope attributes="private" doc="Generate a new stream by providing a source stream and a function that can&#xA;be used to transform the stream&apos;s value. In the case of a non-stream object,&#xA;returns the result of the function.&#xA;  &#xA;The value to transform would typically be available to the function you pass&#xA;to `chain()` via scope. For example:&#xA;  &#xA;```javascript&#xA;    var source = ...;  // stream returning a number&#xA;                           // or a numeric (non-stream) object&#xA;    var result = chain(source, function() {&#xA;      var currentValue = read(source);&#xA;      return currentValue + 1;&#xA;    });&#xA;```&#xA;  &#xA;In the example, result is a stream if source is a stream, or a number of&#xA;source was numeric." ilk="function" name="chain" returns="Object|Stream" signature="chain(value,fn) =&gt; Object|Stream">
                <variable citdl="Object|Stream" doc="A stream or non-stream object" ilk="argument" name="value" />
                <variable citdl="Function" doc="function to be run when the stream value changes, or to&#xA;                     be run once in the case of a non-stream object" ilk="argument" name="fn" />
              </scope>
            </scope>
          </scope>
          <scope ilk="class" name="Subscriber" />
        </scope>
        <scope attributes="public" doc="Framework objects in an Ember application (components, services, routes, etc.)&#xA;are created via a factory and dependency injection system. Each of these&#xA;objects is the responsibility of an &quot;owner&quot;, which handled its&#xA;instantiation and manages its lifetime.&#xA;  &#xA;`getOwner` fetches the owner object responsible for an instance. This can&#xA;be used to lookup or resolve other class instances, or register new factories&#xA;into the owner.&#xA;  &#xA;For example, this component dynamically looks up a service based on the&#xA;`audioType` passed as an attribute:&#xA;  &#xA;```&#xA;// app/components/play-audio.js&#xA;import Ember from &apos;ember&apos;;&#xA;  &#xA;// Usage:&#xA;//&#xA;//   {{play-audio audioType=model.audioType audioFile=model.file}}&#xA;//&#xA;export default Ember.Component.extend({&#xA;  audioService: Ember.computed(&apos;audioType&apos;, function() {&#xA;    let owner = Ember.getOwner(this);&#xA;    return owner.lookup(`service:${this.get(&apos;audioType&apos;)}`);&#xA;  }),&#xA;  click() {&#xA;    let player = this.get(&apos;audioService&apos;);&#xA;    player.play(this.get(&apos;audioFile&apos;));&#xA;  }&#xA;});&#xA;```" ilk="function" name="getOwner" returns="Object" signature="getOwner(object) =&gt; Object">
          <variable citdl="Object" doc="A object with an owner." ilk="argument" name="object" />
        </scope>
        <scope attributes="public" doc="`setOwner` forces a new owner on a given object instance. This is primarily&#xA;useful in some testing cases." ilk="function" name="setOwner" returns="Object" signature="setOwner(object) =&gt; Object">
          <variable citdl="Object" doc="A object with an owner." ilk="argument" name="object" />
        </scope>
        <variable attributes="property private" citdl="Object" doc="Global hash of shared templates. This will automatically be populated&#xA;by the build tools so that you can store your Handlebars templates in&#xA;separate files that get loaded into JavaScript at buildtime." name="Ember" />
        <scope attributes="public" doc="Copy properties from a source object to a target object.&#xA;  &#xA;```javascript&#xA;var a = {first: &apos;Yehuda&apos;};&#xA;var b = {last: &apos;Katz&apos;};&#xA;var c = {company: &apos;Tilde Inc.&apos;};&#xA;Ember.assign(a, b, c); // a === {first: &apos;Yehuda&apos;, last: &apos;Katz&apos;, company: &apos;Tilde Inc.&apos;}, b === {last: &apos;Katz&apos;}, c === {company: &apos;Tilde Inc.&apos;}&#xA;```" ilk="function" name="assign" returns="Object" signature="assign(original,args) =&gt; Object">
          <variable citdl="Object" doc="The object to assign into" ilk="argument" name="original" />
          <variable citdl="Object" doc="The objects to copy properties from" ilk="argument" name="args" />
        </scope>
        <variable attributes="property public" citdl="Boolean" doc="Debug parameter you can turn on. This will log all bindings that fire to&#xA;the console. This should be disabled in production code. Note that you&#xA;can also enable this from the console or temporarily." name="Ember" />
        <scope attributes="private" doc="Returns true if the provided path is global (e.g., `MyApp.fooController.bar`)&#xA;instead of local (`foo.bar.baz`)." ilk="function" name="isGlobalPath" signature="isGlobalPath(path)">
          <variable citdl="String" ilk="argument" name="path" />
        </scope>
        <scope attributes="public" doc="Global helper method to create a new binding. Just pass the root object&#xA;along with a `to` and `from` path to create and connect the binding." ilk="function" name="bind" returns="Ember.Binding" signature="bind(obj,to,from) =&gt; Ember.Binding">
          <variable citdl="Object" doc="The root object of the transform." ilk="argument" name="obj" />
          <variable citdl="String" doc="The path to the &apos;to&apos; side of the binding.&#xA;  Must be relative to obj." ilk="argument" name="to" />
          <variable citdl="String" doc="The path to the &apos;from&apos; side of the binding.&#xA;  Must be relative to obj or a global path." ilk="argument" name="from" />
        </scope>
        <scope attributes="public" doc="Returns the cached value for a property, if one exists.&#xA;This can be useful for peeking at the value of a computed&#xA;property that is generated lazily, without accidentally causing&#xA;it to be created." ilk="function" name="cacheFor" returns="Object" signature="cacheFor(obj,key) =&gt; Object">
          <variable citdl="Object" doc="the object whose property you want to check" ilk="argument" name="obj" />
          <variable citdl="String" doc="the name of the property whose cached value you want&#xA;  to return" ilk="argument" name="key" />
        </scope>
        <variable attributes="property public" citdl="String" doc="The semantic version." name="Ember" />
        <variable attributes="property public" citdl="Object" doc="The hash of environment variables used to control various configuration&#xA;settings. To specify your own or override default settings, add the&#xA;desired properties to a global hash named `EmberENV` (or `ENV` for&#xA;backwards compatibility with earlier versions of Ember). The `EmberENV`&#xA;hash must be created before loading Ember." name="Ember" />
        <variable attributes="property public" citdl="Boolean" doc="Determines whether Ember should add to `Array`, `Function`, and `String`&#xA;native object prototypes, a few extra methods in order to provide a more&#xA;friendly API.&#xA;  &#xA;We generally recommend leaving this option set to true however, if you need&#xA;to turn it off, you can add the configuration property&#xA;`EXTEND_PROTOTYPES` to `EmberENV` and set it to `false`.&#xA;  &#xA;Note, when disabled (the default configuration for Ember Addons), you will&#xA;instead have to access all methods and functions from the Ember&#xA;namespace." name="Ember" />
        <variable attributes="property public" citdl="Boolean" doc="The `LOG_STACKTRACE_ON_DEPRECATION` property, when true, tells Ember to log&#xA;a full stack trace during deprecation warnings." name="Ember" />
        <variable attributes="property public" citdl="Boolean" doc="The `LOG_VERSION` property, when true, tells Ember to log versions of all&#xA;dependent libraries in use." name="Ember" />
        <scope attributes="public" doc="An empty function useful for some operations. Always returns `this`." ilk="function" name="K" returns="Object" signature="K() =&gt; Object" />
        <scope attributes="private" doc="Used internally to allow changing properties in a backwards compatible way, and print a helpful&#xA;deprecation warning." ilk="function" name="deprecateProperty" signature="deprecateProperty(object,deprecatedKey,newKey)">
          <variable citdl="Object" doc="The object to add the deprecated property to." ilk="argument" name="object" />
          <variable citdl="String" doc="The property to add (and print deprecation warnings upon accessing)." ilk="argument" name="deprecatedKey" />
          <variable citdl="String" doc="The property that will be aliased." ilk="argument" name="newKey" />
        </scope>
        <scope attributes="public" doc="Add an event listener" ilk="function" name="addListener" signature="addListener(obj,eventName,target,method,once)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="eventName" />
          <variable citdl="Object|Function" doc="A target object or a function" ilk="argument" name="target" />
          <variable citdl="Function|String" doc="A function or the name of a function to be called on `target`" ilk="argument" name="method" />
          <variable citdl="Boolean" doc="A flag whether a function should only be called once" ilk="argument" name="once" />
        </scope>
        <scope attributes="public" doc="Remove an event listener&#xA;  &#xA;Arguments should match those passed to `Ember.addListener`." ilk="function" name="removeListener" signature="removeListener(obj,eventName,target,method)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="eventName" />
          <variable citdl="Object|Function" doc="A target object or a function" ilk="argument" name="target" />
          <variable citdl="Function|String" doc="A function or the name of a function to be called on `target`" ilk="argument" name="method" />
        </scope>
        <scope attributes="private" doc="Suspend listener during callback.&#xA;  &#xA;This should only be used by the target of the event listener&#xA;when it is taking an action that would cause the event, e.g.&#xA;an object might suspend its property change listener while it is&#xA;setting that property." ilk="function" name="suspendListener" signature="suspendListener(obj,eventName,target,method,callback)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="eventName" />
          <variable citdl="Object|Function" doc="A target object or a function" ilk="argument" name="target" />
          <variable citdl="Function|String" doc="A function or the name of a function to be called on `target`" ilk="argument" name="method" />
          <variable citdl="Function" ilk="argument" name="callback" />
        </scope>
        <scope attributes="private" doc="Suspends multiple listeners during a callback." ilk="function" name="suspendListeners" signature="suspendListeners(obj,eventNames,target,method,callback)">
          <variable ilk="argument" name="obj" />
          <variable citdl="Array" doc="Array of event names" ilk="argument" name="eventNames" />
          <variable citdl="Object|Function" doc="A target object or a function" ilk="argument" name="target" />
          <variable citdl="Function|String" doc="A function or the name of a function to be called on `target`" ilk="argument" name="method" />
          <variable citdl="Function" ilk="argument" name="callback" />
        </scope>
        <scope attributes="private" doc="Return a list of currently watched events" ilk="function" name="watchedEvents" signature="watchedEvents(obj)">
          <variable ilk="argument" name="obj" />
        </scope>
        <scope attributes="public" doc="Send an event. The execution of suspended listeners&#xA;is skipped, and once listeners are removed. A listener without&#xA;a target is executed on the passed object. If an array of actions&#xA;is not passed, the actions stored on the passed object are invoked." ilk="function" name="sendEvent" signature="sendEvent(obj,eventName,params,actions)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="eventName" />
          <variable citdl="Array" doc="Optional parameters for each listener." ilk="argument" name="params" />
          <variable citdl="Array" doc="Optional array of actions (listeners)." ilk="argument" name="actions" />
        </scope>
        <scope attributes="private" ilk="function" name="hasListeners" signature="hasListeners(obj,eventName)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="eventName" />
        </scope>
        <scope attributes="private" ilk="function" name="listenersFor" signature="listenersFor(obj,eventName)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="eventName" />
        </scope>
        <scope attributes="public" doc="Define a property as a function that should be executed when&#xA;a specified event or events are triggered.&#xA;  &#xA;  &#xA;``` javascript&#xA;var Job = Ember.Object.extend({&#xA;  logCompleted: Ember.on(&apos;completed&apos;, function() {&#xA;    console.log(&apos;Job completed!&apos;);&#xA;  })&#xA;});&#xA;  &#xA;var job = Job.create();&#xA;  &#xA;Ember.sendEvent(job, &apos;completed&apos;); // Logs &apos;Job completed!&apos;&#xA;   ```" ilk="function" name="on" signature="on(eventNames,func)">
          <variable citdl="String" ilk="argument" name="eventNames" />
          <variable citdl="Function" ilk="argument" name="func" />
        </scope>
        <scope attributes="private" doc="Expands `pattern`, invoking `callback` for each expansion.&#xA;  &#xA;The only pattern supported is brace-expansion, anything else will be passed&#xA;once to `callback` directly.&#xA;  &#xA;Example&#xA;  &#xA;```js&#xA;function echo(arg){ console.log(arg); }&#xA;  &#xA;Ember.expandProperties(&apos;foo.bar&apos;, echo);              //=&gt; &apos;foo.bar&apos;&#xA;Ember.expandProperties(&apos;{foo,bar}&apos;, echo);            //=&gt; &apos;foo&apos;, &apos;bar&apos;&#xA;Ember.expandProperties(&apos;foo.{bar,baz}&apos;, echo);        //=&gt; &apos;foo.bar&apos;, &apos;foo.baz&apos;&#xA;Ember.expandProperties(&apos;{foo,bar}.baz&apos;, echo);        //=&gt; &apos;foo.baz&apos;, &apos;bar.baz&apos;&#xA;Ember.expandProperties(&apos;foo.{bar,baz}.[]&apos;, echo)      //=&gt; &apos;foo.bar.[]&apos;, &apos;foo.baz.[]&apos;&#xA;Ember.expandProperties(&apos;{foo,bar}.{spam,eggs}&apos;, echo) //=&gt; &apos;foo.spam&apos;, &apos;foo.eggs&apos;, &apos;bar.spam&apos;, &apos;bar.eggs&apos;&#xA;Ember.expandProperties(&apos;{foo}.bar.{baz}&apos;)             //=&gt; &apos;foo.bar.baz&apos;&#xA;```" ilk="function" name="expandProperties" signature="expandProperties(pattern,callback)">
          <variable citdl="String" doc="The property pattern to expand." ilk="argument" name="pattern" />
          <variable citdl="Function" doc="The callback to invoke.  It is invoked once per&#xA;expansion, and is passed the expansion." ilk="argument" name="callback" />
        </scope>
        <scope attributes="public" doc="To get multiple properties at once, call `Ember.getProperties`&#xA;with an object followed by a list of strings or an array:&#xA;  &#xA;```javascript&#xA;Ember.getProperties(record, &apos;firstName&apos;, &apos;lastName&apos;, &apos;zipCode&apos;);&#xA;// { firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, zipCode: &apos;10011&apos; }&#xA;```&#xA;  &#xA;is equivalent to:&#xA;  &#xA;```javascript&#xA;Ember.getProperties(record, [&apos;firstName&apos;, &apos;lastName&apos;, &apos;zipCode&apos;]);&#xA;// { firstName: &apos;John&apos;, lastName: &apos;Doe&apos;, zipCode: &apos;10011&apos; }&#xA;```" ilk="function" name="getProperties" returns="Object" signature="getProperties(obj,list) =&gt; Object">
          <variable citdl="Object" ilk="argument" name="obj" />
          <variable citdl="String...|Array" doc="of keys to get" ilk="argument" name="list" />
        </scope>
        <variable attributes="event public" doc="A function may be assigned to `Ember.onerror` to be called when Ember&#xA;internals encounter an error. This is useful for specialized error handling&#xA;and reporting code.&#xA;  &#xA;```javascript&#xA;Ember.onerror = function(error) {&#xA;  Em.$.ajax(&apos;/report-error&apos;, &apos;POST&apos;, {&#xA;    stack: error.stack,&#xA;    otherInformation: &apos;whatever app state you want to provide&apos;&#xA;  });&#xA;};&#xA;```&#xA;  &#xA;Internally, `Ember.onerror` is used as Backburner&apos;s error handler." name="Ember" />
        <scope attributes="public" doc="A value is blank if it is empty or a whitespace string.&#xA;  &#xA;```javascript&#xA;Ember.isBlank();                // true&#xA;Ember.isBlank(null);            // true&#xA;Ember.isBlank(undefined);       // true&#xA;Ember.isBlank(&apos;&apos;);              // true&#xA;Ember.isBlank([]);              // true&#xA;Ember.isBlank(&apos;\n\t&apos;);          // true&#xA;Ember.isBlank(&apos;  &apos;);            // true&#xA;Ember.isBlank({});              // false&#xA;Ember.isBlank(&apos;\n\t Hello&apos;);    // false&#xA;Ember.isBlank(&apos;Hello world&apos;);   // false&#xA;Ember.isBlank([1,2,3]);         // false&#xA;```" ilk="function" name="isBlank" returns="Boolean" signature="isBlank(obj) =&gt; Boolean">
          <variable citdl="Object" doc="Value to test" ilk="argument" name="obj" />
        </scope>
        <scope attributes="public" doc="Verifies that a value is `null` or an empty string, empty array,&#xA;or empty function.&#xA;  &#xA;Constrains the rules on `Ember.isNone` by returning true for empty&#xA;string and empty arrays.&#xA;  &#xA;```javascript&#xA;Ember.isEmpty();                // true&#xA;Ember.isEmpty(null);            // true&#xA;Ember.isEmpty(undefined);       // true&#xA;Ember.isEmpty(&apos;&apos;);              // true&#xA;Ember.isEmpty([]);              // true&#xA;Ember.isEmpty({});              // false&#xA;Ember.isEmpty(&apos;Adam Hawkins&apos;);  // false&#xA;Ember.isEmpty([0,1,2]);         // false&#xA;Ember.isEmpty(&apos;\n\t&apos;);          // false&#xA;Ember.isEmpty(&apos;  &apos;);            // false&#xA;```" ilk="function" name="isEmpty" returns="Boolean" signature="isEmpty(obj) =&gt; Boolean">
          <variable citdl="Object" doc="Value to test" ilk="argument" name="obj" />
        </scope>
        <scope attributes="public" doc="Returns true if the passed value is null or undefined. This avoids errors&#xA;from JSLint complaining about use of ==, which can be technically&#xA;confusing.&#xA;  &#xA;```javascript&#xA;Ember.isNone();              // true&#xA;Ember.isNone(null);          // true&#xA;Ember.isNone(undefined);     // true&#xA;Ember.isNone(&apos;&apos;);            // false&#xA;Ember.isNone([]);            // false&#xA;Ember.isNone(function() {}); // false&#xA;```" ilk="function" name="isNone" returns="Boolean" signature="isNone(obj) =&gt; Boolean">
          <variable citdl="Object" doc="Value to test" ilk="argument" name="obj" />
        </scope>
        <scope attributes="public" doc="A value is present if it not `isBlank`.&#xA;  &#xA;```javascript&#xA;Ember.isPresent();                // false&#xA;Ember.isPresent(null);            // false&#xA;Ember.isPresent(undefined);       // false&#xA;Ember.isPresent(&apos;&apos;);              // false&#xA;Ember.isPresent(&apos;  &apos;);            // false&#xA;Ember.isPresent(&apos;\n\t&apos;);          // false&#xA;Ember.isPresent([]);              // false&#xA;Ember.isPresent({ length: 0 })    // false&#xA;Ember.isPresent(false);           // true&#xA;Ember.isPresent(true);            // true&#xA;Ember.isPresent(&apos;string&apos;);        // true&#xA;Ember.isPresent(0);               // true&#xA;Ember.isPresent(function() {})    // true&#xA;Ember.isPresent({});              // true&#xA;Ember.isPresent(false);           // true&#xA;Ember.isPresent(&apos;\n\t Hello&apos;);    // true&#xA;Ember.isPresent([1,2,3]);         // true&#xA;```" ilk="function" name="isPresent" returns="Boolean" signature="isPresent(obj) =&gt; Boolean">
          <variable citdl="Object" doc="Value to test" ilk="argument" name="obj" />
        </scope>
        <scope attributes="public" doc="Merge the contents of two objects together into the first object.&#xA;  &#xA;```javascript&#xA;Ember.merge({first: &apos;Tom&apos;}, {last: &apos;Dale&apos;}); // {first: &apos;Tom&apos;, last: &apos;Dale&apos;}&#xA;var a = {first: &apos;Yehuda&apos;};&#xA;var b = {last: &apos;Katz&apos;};&#xA;Ember.merge(a, b); // a == {first: &apos;Yehuda&apos;, last: &apos;Katz&apos;}, b == {last: &apos;Katz&apos;}&#xA;```" ilk="function" name="merge" returns="Object" signature="merge(original,updates) =&gt; Object">
          <variable citdl="Object" doc="The object to merge into" ilk="argument" name="original" />
          <variable citdl="Object" doc="The object to copy properties from" ilk="argument" name="updates" />
        </scope>
        <scope attributes="private" doc="Retrieves the meta hash for an object. If `writable` is true ensures the&#xA;hash is writable for this object as well.&#xA;  &#xA;The meta object contains information about computed property descriptors as&#xA;well as any watched properties and other information. You generally will&#xA;not access this information directly but instead work with higher level&#xA;methods that manipulate this hash indirectly." ilk="function" name="meta" returns="Object" signature="meta(obj,writable) =&gt; Object">
          <variable citdl="Object" doc="The object to retrieve meta for" ilk="argument" name="obj" />
          <variable citdl="Boolean" doc="Pass `false` if you do not intend to modify&#xA;  the meta hash, allowing the method to avoid making an unnecessary copy." ilk="argument" name="writable" />
        </scope>
        <scope attributes="private" ilk="function" name="mixin" signature="mixin(obj,mixins)">
          <variable ilk="argument" name="obj" />
          <variable ilk="argument" name="mixins" />
        </scope>
        <scope attributes="private" doc="Denotes a required property for a mixin" ilk="function" name="required" signature="required()" />
        <scope attributes="public" doc="Makes a method available via an additional name.&#xA;  &#xA;```javascript&#xA;App.Person = Ember.Object.extend({&#xA;  name: function() {&#xA;    return &apos;Tomhuda Katzdale&apos;;&#xA;  },&#xA;  moniker: Ember.aliasMethod(&apos;name&apos;)&#xA;});&#xA;  &#xA;var goodGuy = App.Person.create();&#xA;  &#xA;goodGuy.name();    // &apos;Tomhuda Katzdale&apos;&#xA;goodGuy.moniker(); // &apos;Tomhuda Katzdale&apos;&#xA;```" ilk="function" name="aliasMethod" signature="aliasMethod(methodName)">
          <variable citdl="String" doc="name of the method to alias" ilk="argument" name="methodName" />
        </scope>
        <scope attributes="public" doc="Specify a method that observes property changes.&#xA;  &#xA;```javascript&#xA;Ember.Object.extend({&#xA;  valueObserver: Ember.observer(&apos;value&apos;, function() {&#xA;    // Executes whenever the &quot;value&quot; property changes&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Also available as `Function.prototype.observes` if prototype extensions are&#xA;enabled." ilk="function" name="observer" signature="observer(propertyNames,func)">
          <variable citdl="String" ilk="argument" name="propertyNames" />
          <variable citdl="Function" ilk="argument" name="func" />
        </scope>
        <scope attributes="private" doc="Specify a method that observes property changes.&#xA;  &#xA;```javascript&#xA;Ember.Object.extend({&#xA;  valueObserver: Ember.immediateObserver(&apos;value&apos;, function() {&#xA;    // Executes whenever the &quot;value&quot; property changes&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;In the future, `Ember.observer` may become asynchronous. In this event,&#xA;`Ember.immediateObserver` will maintain the synchronous behavior.&#xA;  &#xA;Also available as `Function.prototype.observesImmediately` if prototype extensions are&#xA;enabled." ilk="function" name="_immediateObserver" signature="_immediateObserver(propertyNames,func)">
          <variable citdl="String" ilk="argument" name="propertyNames" />
          <variable citdl="Function" ilk="argument" name="func" />
        </scope>
        <scope attributes="private" doc="When observers fire, they are called with the arguments `obj`, `keyName`.&#xA;  &#xA;Note, `@each.property` observer is called per each add or replace of an element&#xA;and it&apos;s not called with a specific enumeration item.&#xA;  &#xA;A `_beforeObserver` fires before a property changes.&#xA;  &#xA;A `_beforeObserver` is an alternative form of `.observesBefore()`.&#xA;  &#xA;```javascript&#xA;App.PersonView = Ember.View.extend({&#xA;  friends: [{ name: &apos;Tom&apos; }, { name: &apos;Stefan&apos; }, { name: &apos;Kris&apos; }],&#xA;  &#xA;  valueDidChange: Ember.observer(&apos;content.value&apos;, function(obj, keyName) {&#xA;      // only run if updating a value already in the DOM&#xA;      if (this.get(&apos;state&apos;) === &apos;inDOM&apos;) {&#xA;        var color = obj.get(keyName) &gt; this.changingFrom ? &apos;green&apos; : &apos;red&apos;;&#xA;        // logic&#xA;      }&#xA;  }),&#xA;  &#xA;  friendsDidChange: Ember.observer(&apos;friends.@each.name&apos;, function(obj, keyName) {&#xA;    // some logic&#xA;    // obj.get(keyName) returns friends array&#xA;  })&#xA;});&#xA;```&#xA;  &#xA;Also available as `Function.prototype.observesBefore` if prototype extensions are&#xA;enabled." ilk="function" name="beforeObserver" signature="beforeObserver(propertyNames,func)">
          <variable citdl="String" ilk="argument" name="propertyNames" />
          <variable citdl="Function" ilk="argument" name="func" />
        </scope>
        <scope attributes="public" ilk="function" name="addObserver" signature="addObserver(obj,_path,target,method)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="_path" />
          <variable citdl="Object|Function" ilk="argument" name="target" />
          <variable citdl="Function|String" ilk="argument" name="method" />
        </scope>
        <scope attributes="public" ilk="function" name="removeObserver" signature="removeObserver(obj,path,target,method)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="path" />
          <variable citdl="Object|Function" ilk="argument" name="target" />
          <variable citdl="Function|String" ilk="argument" name="method" />
        </scope>
        <scope attributes="private" ilk="function" name="_addBeforeObserver" signature="_addBeforeObserver(obj,path,target,method)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="path" />
          <variable citdl="Object|Function" ilk="argument" name="target" />
          <variable citdl="Function|String" ilk="argument" name="method" />
        </scope>
        <scope attributes="private" ilk="function" name="removeBeforeObserver" signature="removeBeforeObserver(obj,path,target,method)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="path" />
          <variable citdl="Object|Function" ilk="argument" name="target" />
          <variable citdl="Function|String" ilk="argument" name="method" />
        </scope>
        <scope attributes="private" doc="NOTE: This is a low-level method used by other parts of the API. You almost&#xA;never want to call this method directly. Instead you should use&#xA;`Ember.mixin()` to define new properties.&#xA;  &#xA;Defines a property on an object. This method works much like the ES5&#xA;`Object.defineProperty()` method except that it can also accept computed&#xA;properties and other special descriptors.&#xA;  &#xA;Normally this method takes only three parameters. However if you pass an&#xA;instance of `Descriptor` as the third param then you can pass an&#xA;optional value as the fourth parameter. This is often more efficient than&#xA;creating new descriptor hashes for each property.&#xA;  &#xA;## Examples&#xA;  &#xA;```javascript&#xA;// ES5 compatible mode&#xA;Ember.defineProperty(contact, &apos;firstName&apos;, {&#xA;  writable: true,&#xA;  configurable: false,&#xA;  enumerable: true,&#xA;  value: &apos;Charles&apos;&#xA;});&#xA;  &#xA;// define a simple property&#xA;Ember.defineProperty(contact, &apos;lastName&apos;, undefined, &apos;Jolley&apos;);&#xA;  &#xA;// define a computed property&#xA;Ember.defineProperty(contact, &apos;fullName&apos;, Ember.computed(function() {&#xA;  return this.firstName+&apos; &apos;+this.lastName;&#xA;}).property(&apos;firstName&apos;, &apos;lastName&apos;));&#xA;```" ilk="function" name="defineProperty" signature="defineProperty(obj,keyName,desc,data)">
          <variable citdl="Object" doc="the object to define this property on. This may be a prototype." ilk="argument" name="obj" />
          <variable citdl="String" doc="the name of the property" ilk="argument" name="keyName" />
          <variable citdl="Descriptor" doc="an instance of `Descriptor` (typically a&#xA;  computed property) or an ES5 descriptor.&#xA;  You must provide this or `data` but not both." ilk="argument" name="desc" />
          <variable citdl="*" doc="something other than a descriptor, that will&#xA;  become the explicit value of this property." ilk="argument" name="data" />
        </scope>
        <scope attributes="private" doc="This function is called just before an object property is about to change.&#xA;It will notify any before observers and prepare caches among other things.&#xA;  &#xA;Normally you will not need to call this method directly but if for some&#xA;reason you can&apos;t directly watch a property you can invoke this method&#xA;manually along with `Ember.propertyDidChange()` which you should call just&#xA;after the property value changes." ilk="function" name="propertyWillChange" returns="Void" signature="propertyWillChange(obj,keyName) =&gt; Void">
          <variable citdl="Object" doc="The object with the property that will change" ilk="argument" name="obj" />
          <variable citdl="String" doc="The property key (or path) that will change." ilk="argument" name="keyName" />
        </scope>
        <scope attributes="private" doc="This function is called just after an object property has changed.&#xA;It will notify any observers and clear caches among other things.&#xA;  &#xA;Normally you will not need to call this method directly but if for some&#xA;reason you can&apos;t directly watch a property you can invoke this method&#xA;manually along with `Ember.propertyWillChange()` which you should call just&#xA;before the property value changes." ilk="function" name="propertyDidChange" returns="Void" signature="propertyDidChange(obj,keyName) =&gt; Void">
          <variable citdl="Object" doc="The object with the property that will change" ilk="argument" name="obj" />
          <variable citdl="String" doc="The property key (or path) that will change." ilk="argument" name="keyName" />
        </scope>
        <scope attributes="private" ilk="function" name="beginPropertyChanges" signature="beginPropertyChanges()" />
        <scope attributes="private" ilk="function" name="endPropertyChanges" signature="endPropertyChanges()" />
        <scope attributes="private" doc="Make a series of property changes together in an&#xA;exception-safe way.&#xA;  &#xA;```javascript&#xA;Ember.changeProperties(function() {&#xA;  obj1.set(&apos;foo&apos;, mayBlowUpWhenSet);&#xA;  obj2.set(&apos;bar&apos;, baz);&#xA;});&#xA;```" ilk="function" name="changeProperties" signature="changeProperties(callback,binding)">
          <variable citdl="Function" ilk="argument" name="callback" />
          <variable ilk="argument" name="binding" />
        </scope>
        <scope attributes="public" doc="Gets the value of a property on an object. If the property is computed,&#xA;the function will be invoked. If the property is not defined but the&#xA;object implements the `unknownProperty` method then that will be invoked.&#xA;  &#xA;If you plan to run on IE8 and older browsers then you should use this&#xA;method anytime you want to retrieve a property on an object that you don&apos;t&#xA;know for sure is private. (Properties beginning with an underscore &apos;_&apos;&#xA;are considered private.)&#xA;  &#xA;On all newer browsers, you only need to use this method to retrieve&#xA;properties if the property might not be defined on the object and you want&#xA;to respect the `unknownProperty` handler. Otherwise you can ignore this&#xA;method.&#xA;  &#xA;Note that if the object itself is `undefined`, this method will throw&#xA;an error." ilk="function" name="get" returns="Object" signature="get(obj,keyName) =&gt; Object">
          <variable citdl="Object" doc="The object to retrieve from." ilk="argument" name="obj" />
          <variable citdl="String" doc="The property key to retrieve" ilk="argument" name="keyName" />
        </scope>
        <scope attributes="private" doc="Normalizes a target/path pair to reflect that actual target/path that should&#xA;be observed, etc. This takes into account passing in global property&#xA;paths (i.e. a path beginning with a capital letter not defined on the&#xA;target)." ilk="function" name="normalizeTuple" returns="Array" signature="normalizeTuple(target,path) =&gt; Array">
          <variable citdl="Object" doc="The current target. May be `null`." ilk="argument" name="target" />
          <variable citdl="String" doc="A path on the target or a global property path." ilk="argument" name="path" />
        </scope>
        <scope attributes="public" doc="Retrieves the value of a property from an Object, or a default value in the&#xA;case that the property returns `undefined`.&#xA;  &#xA;```javascript&#xA;Ember.getWithDefault(person, &apos;lastName&apos;, &apos;Doe&apos;);&#xA;```" ilk="function" name="getWithDefault" returns="Object" signature="getWithDefault(obj,keyName,defaultValue) =&gt; Object">
          <variable citdl="Object" doc="The object to retrieve from." ilk="argument" name="obj" />
          <variable citdl="String" doc="The name of the property to retrieve" ilk="argument" name="keyName" />
          <variable citdl="Object" doc="The value to return if the property value is undefined" ilk="argument" name="defaultValue" />
        </scope>
        <scope attributes="public" doc="Sets the value of a property on an object, respecting computed properties&#xA;and notifying observers and other listeners of the change. If the&#xA;property is not defined but the object implements the `setUnknownProperty`&#xA;method then that will be invoked as well." ilk="function" name="set" returns="Object" signature="set(obj,keyName,value) =&gt; Object">
          <variable citdl="Object" doc="The object to modify." ilk="argument" name="obj" />
          <variable citdl="String" doc="The property key to set" ilk="argument" name="keyName" />
          <variable citdl="Object" doc="The value to set" ilk="argument" name="value" />
        </scope>
        <scope attributes="public" doc="Error-tolerant form of `Ember.set`. Will not blow up if any part of the&#xA;chain is `undefined`, `null`, or destroyed.&#xA;  &#xA;This is primarily used when syncing bindings, which may try to update after&#xA;an object has been destroyed." ilk="function" name="trySet" signature="trySet(root,path,value)">
          <variable citdl="Object" doc="The object to modify." ilk="argument" name="root" />
          <variable citdl="String" doc="The property path to set" ilk="argument" name="path" />
          <variable citdl="Object" doc="The value to set" ilk="argument" name="value" />
        </scope>
        <scope attributes="public" doc="Replaces objects in an array with the passed objects.&#xA;  &#xA;```javascript&#xA;  var array = [1,2,3];&#xA;  Ember.EnumerableUtils.replace(array, 1, 2, [4, 5]); // [1, 4, 5]&#xA;  &#xA;  var array = [1,2,3];&#xA;  Ember.EnumerableUtils.replace(array, 1, 1, [4, 5]); // [1, 4, 5, 3]&#xA;  &#xA;  var array = [1,2,3];&#xA;  Ember.EnumerableUtils.replace(array, 10, 1, [4, 5]); // [1, 2, 3, 4, 5]&#xA;```" ilk="function" name="replace" returns="Array" signature="replace(array,idx,amt,objects) =&gt; Array">
          <variable citdl="Array" doc="The array the objects should be inserted into." ilk="argument" name="array" />
          <variable citdl="Number" doc="Starting index in the array to replace. If *idx* &gt;=&#xA;length, then append to the end of the array." ilk="argument" name="idx" />
          <variable citdl="Number" doc="Number of elements that should be removed from the array,&#xA;starting at *idx*" ilk="argument" name="amt" />
          <variable citdl="Array" doc="An array of zero or more objects that should be&#xA;inserted into the array at *idx*" ilk="argument" name="objects" />
        </scope>
        <variable attributes="property private" citdl="String" doc="Prefix used for guids through out Ember." name="Ember" />
        <variable attributes="property private" citdl="String" doc="A unique key used to assign guids and other private metadata to objects.&#xA;If you inspect an object in your browser debugger you will often see these.&#xA;They can be safely ignored.&#xA;  &#xA;On browsers that support it, these properties are added with enumeration&#xA;disabled so they won&apos;t show up when you iterate over your properties." name="Ember" />
        <scope attributes="private" doc="Generates a new guid, optionally saving the guid to the object that you&#xA;pass in. You will rarely need to use this method. Instead you should&#xA;call `Ember.guidFor(obj)`, which return an existing guid if available." ilk="function" name="generateGuid" returns="String" signature="generateGuid(obj,prefix) =&gt; String">
          <variable citdl="Object" doc="Object the guid will be used for. If passed in, the guid will&#xA;  be saved on the object and reused whenever you pass the same object&#xA;  again.&#xA;  &#xA;  If no object is passed, just generate a new guid." ilk="argument" name="obj" />
          <variable citdl="String" doc="Prefix to place in front of the guid. Useful when you want to&#xA;  separate the guid into separate namespaces." ilk="argument" name="prefix" />
        </scope>
        <scope attributes="public" doc="Returns a unique id for the object. If the object does not yet have a guid,&#xA;one will be assigned to it. You can call this on any object,&#xA;`Ember.Object`-based or not, but be aware that it will add a `_guid`&#xA;property.&#xA;  &#xA;You can also use this method on DOM Element objects." ilk="function" name="guidFor" returns="String" signature="guidFor(obj) =&gt; String">
          <variable citdl="Object" doc="any object, string, number, Element, or primitive" ilk="argument" name="obj" />
        </scope>
        <scope attributes="private" doc="Wraps the passed function so that `this._super` will point to the superFunc&#xA;when the function is invoked. This is the primitive we use to implement&#xA;calls to super." ilk="function" name="wrap" returns="Function" signature="wrap(func,superFunc) =&gt; Function">
          <variable citdl="Function" doc="The function to call" ilk="argument" name="func" />
          <variable citdl="Function" doc="The super function." ilk="argument" name="superFunc" />
        </scope>
        <scope attributes="private" doc="Checks to see if the `methodName` exists on the `obj`.&#xA;  &#xA;```javascript&#xA;var foo = { bar: function() { return &apos;bar&apos;; }, baz: null };&#xA;  &#xA;Ember.canInvoke(foo, &apos;bar&apos;); // true&#xA;Ember.canInvoke(foo, &apos;baz&apos;); // false&#xA;Ember.canInvoke(foo, &apos;bat&apos;); // false&#xA;```" ilk="function" name="canInvoke" returns="Boolean" signature="canInvoke(obj,methodName) =&gt; Boolean">
          <variable citdl="Object" doc="The object to check for the method" ilk="argument" name="obj" />
          <variable citdl="String" doc="The method name to check for" ilk="argument" name="methodName" />
        </scope>
        <scope attributes="public" doc="Checks to see if the `methodName` exists on the `obj`,&#xA;and if it does, invokes it with the arguments passed.&#xA;  &#xA;```javascript&#xA;var d = new Date(&apos;03/15/2013&apos;);&#xA;  &#xA;Ember.tryInvoke(d, &apos;getTime&apos;);              // 1363320000000&#xA;Ember.tryInvoke(d, &apos;setFullYear&apos;, [2014]);  // 1394856000000&#xA;Ember.tryInvoke(d, &apos;noSuchMethod&apos;, [2014]); // undefined&#xA;```" ilk="function" name="tryInvoke" returns="*" signature="tryInvoke(obj,methodName,args) =&gt; *">
          <variable citdl="Object" doc="The object to check for the method" ilk="argument" name="obj" />
          <variable citdl="String" doc="The method name to check for" ilk="argument" name="methodName" />
          <variable citdl="Array" doc="The arguments to pass to the method" ilk="argument" name="args" />
        </scope>
        <scope attributes="private" doc="Forces the passed object to be part of an array. If the object is already&#xA;an array, it will return the object. Otherwise, it will add the object to&#xA;an array. If obj is `null` or `undefined`, it will return an empty array.&#xA;  &#xA;```javascript&#xA;Ember.makeArray();            // []&#xA;Ember.makeArray(null);        // []&#xA;Ember.makeArray(undefined);   // []&#xA;Ember.makeArray(&apos;lindsay&apos;);   // [&apos;lindsay&apos;]&#xA;Ember.makeArray([1, 2, 42]);  // [1, 2, 42]&#xA;  &#xA;var controller = Ember.ArrayProxy.create({ content: [] });&#xA;  &#xA;Ember.makeArray(controller) === controller;  // true&#xA;```" ilk="function" name="makeArray" returns="Array" signature="makeArray(obj) =&gt; Array">
          <variable citdl="Object" doc="the object" ilk="argument" name="obj" />
        </scope>
        <scope attributes="private" doc="Convenience method to inspect an object. This method will attempt to&#xA;convert the object into a useful string description.&#xA;  &#xA;It is a pretty simple implementation. If you want something more robust,&#xA;use something like JSDump: https://github.com/NV/jsDump" ilk="function" name="inspect" returns="String" signature="inspect(obj) =&gt; String">
          <variable citdl="Object" doc="The object you want to inspect." ilk="argument" name="obj" />
        </scope>
        <scope attributes="private" doc="Starts watching a property on an object. Whenever the property changes,&#xA;invokes `Ember.propertyWillChange` and `Ember.propertyDidChange`. This is the&#xA;primitive used by observers and dependent keys; usually you will never call&#xA;this method directly but instead use higher level methods like&#xA;`Ember.addObserver()`" ilk="function" name="watch" signature="watch(obj,_keyPath)">
          <variable ilk="argument" name="obj" />
          <variable citdl="String" ilk="argument" name="_keyPath" />
        </scope>
        <scope attributes="private" doc="Tears down the meta on an object so that it can be garbage collected.&#xA;Multiple calls will have no effect." ilk="function" name="destroy" returns="Void" signature="destroy(obj) =&gt; Void">
          <variable citdl="Object" doc="the object to destroy" ilk="argument" name="obj" />
        </scope>
        <variable attributes="property public" doc="Defines which query parameters the controller accepts.&#xA;If you give the names `[&apos;category&apos;,&apos;page&apos;]` it will bind&#xA;the values of these query parameters to the variables&#xA;`this.category` and `this.page`" name="Ember" />
        <variable attributes="property private" name="Ember" />
        <scope attributes="private" ilk="function" name="_qpChanged" signature="_qpChanged()" />
        <scope attributes="private" doc="Finds a controller instance." ilk="function" name="controllerFor" signature="controllerFor()" />
        <scope attributes="private" doc="Generates a controller factory" ilk="function" name="generateControllerFactory" signature="generateControllerFactory()" />
        <scope attributes="private" doc="Generates and instantiates a controller.&#xA;  &#xA;The type of the generated controller factory is derived&#xA;from the context. If the context is an array an array controller&#xA;is generated, if an object, an object controller otherwise, a basic&#xA;controller is generated." ilk="function" name="generateController" signature="generateController()" />
        <scope attributes="public" doc="Compares two javascript values and returns:&#xA;  &#xA; - -1 if the first is smaller than the second,&#xA; - 0 if both are equal,&#xA; - 1 if the first is greater than the second.&#xA;  &#xA; ```javascript&#xA; Ember.compare(&apos;hello&apos;, &apos;hello&apos;);  // 0&#xA; Ember.compare(&apos;abc&apos;, &apos;dfg&apos;);      // -1&#xA; Ember.compare(2, 1);              // 1&#xA; ```&#xA;  &#xA;If the types of the two objects are different precedence occurs in the&#xA;following order, with types earlier in the list considered `&lt;` types&#xA;later in the list:&#xA;  &#xA; - undefined&#xA; - null&#xA; - boolean&#xA; - number&#xA; - string&#xA; - array&#xA; - object&#xA; - instance&#xA; - function&#xA; - class&#xA; - date&#xA;  &#xA; ```javascript&#xA; Ember.compare(&apos;hello&apos;, 50);       // 1&#xA; Ember.compare(50, &apos;hello&apos;);       // -1&#xA; ```" ilk="function" name="compare" returns="Number" signature="compare(v,w) =&gt; Number">
          <variable citdl="Object" doc="First value to compare" ilk="argument" name="v" />
          <variable citdl="Object" doc="Second value to compare" ilk="argument" name="w" />
        </scope>
        <scope attributes="public" doc="Creates a shallow copy of the passed object. A deep copy of the object is&#xA;returned if the optional `deep` argument is `true`.&#xA;  &#xA;If the passed object implements the `Ember.Copyable` interface, then this&#xA;function will delegate to the object&apos;s `copy()` method and return the&#xA;result. See `Ember.Copyable` for further details.&#xA;  &#xA;For primitive values (which are immutable in JavaScript), the passed object&#xA;is simply returned." ilk="function" name="copy" returns="Object" signature="copy(obj,deep) =&gt; Object">
          <variable citdl="Object" doc="The object to clone" ilk="argument" name="obj" />
          <variable citdl="Boolean" doc="If true, a deep copy of the object is made." ilk="argument" name="deep" />
        </scope>
        <variable attributes="property private" citdl="Object" doc="Defines the hash of localized strings for the current language. Used by&#xA;the `Ember.String.loc()` helper. To localize, add string values to this&#xA;hash." name="Ember" />
        <scope attributes="private" doc="This method allows other Ember modules to register injection helpers for a&#xA;given container type. Helpers are exported to the `inject` namespace as the&#xA;container type itself." ilk="function" name="createInjectionHelper" signature="createInjectionHelper(type,validator)">
          <variable citdl="String" doc="The container type the helper will inject" ilk="argument" name="type" />
          <variable citdl="Function" doc="A validation callback that is executed at mixin-time" ilk="argument" name="validator" />
        </scope>
        <scope attributes="private" doc="Validation function that runs per-type validation functions once for each&#xA;injected type encountered." ilk="function" name="validatePropertyInjections" signature="validatePropertyInjections(factory)">
          <variable citdl="Object" doc="The factory object" ilk="argument" name="factory" />
        </scope>
        <scope attributes="public" doc="Compares two objects, returning true if they are equal.&#xA;  &#xA;```javascript&#xA;Ember.isEqual(&apos;hello&apos;, &apos;hello&apos;);                   // true&#xA;Ember.isEqual(1, 2);                               // false&#xA;```&#xA;  &#xA;`isEqual` is a more specific comparison than a triple equal comparison.&#xA;It will call the `isEqual` instance method on the objects being&#xA;compared, allowing finer control over when objects should be considered&#xA;equal to each other.&#xA;  &#xA;```javascript&#xA;let Person = Ember.Object.extend({&#xA;  isEqual(other) { return this.ssn == other.ssn; }&#xA;});&#xA;  &#xA;let personA = Person.create({name: &apos;Muhammad Ali&apos;, ssn: &apos;123-45-6789&apos;});&#xA;let personB = Person.create({name: &apos;Cassius Clay&apos;, ssn: &apos;123-45-6789&apos;});&#xA;  &#xA;Ember.isEqual(personA, personB); // true&#xA;```&#xA;  &#xA;Due to the expense of array comparisons, collections will never be equal to&#xA;each other even if each of their items are equal to each other.&#xA;  &#xA;```javascript&#xA;Ember.isEqual([4, 2], [4, 2]);                     // false&#xA;```" ilk="function" name="isEqual" returns="Boolean" signature="isEqual(a,b) =&gt; Boolean">
          <variable citdl="Object" doc="first object to compare" ilk="argument" name="a" />
          <variable citdl="Object" doc="second object to compare" ilk="argument" name="b" />
        </scope>
        <scope attributes="private" doc="Detects when a specific package of Ember (e.g. &apos;Ember.Application&apos;)&#xA;has fully loaded and is available for extension.&#xA;  &#xA;The provided `callback` will be called with the `name` passed&#xA;resolved from a string into the object:&#xA;  &#xA;``` javascript&#xA;Ember.onLoad(&apos;Ember.Application&apos; function(hbars) {&#xA;  hbars.registerHelper(...);&#xA;});&#xA;```" ilk="function" name="onLoad" signature="onLoad(name,callback)">
          <variable citdl="String" doc="name of hook" ilk="argument" name="name" />
          <variable citdl="Function" doc="callback to be called" ilk="argument" name="callback" />
        </scope>
        <scope attributes="private" doc="Called when an Ember.js package (e.g Ember.Application) has finished&#xA;loading. Triggers any callbacks registered for this event." ilk="function" name="runLoadHooks" signature="runLoadHooks(name,object)">
          <variable citdl="String" doc="name of hook" ilk="argument" name="name" />
          <variable citdl="Object" doc="object to pass to callbacks" ilk="argument" name="object" />
        </scope>
        <scope attributes="public" doc="Creates an `Ember.NativeArray` from an Array like object.&#xA;Does not modify the original object. Ember.A is not needed if&#xA;`Ember.EXTEND_PROTOTYPES` is `true` (the default value). However,&#xA;it is recommended that you use Ember.A when creating addons for&#xA;ember or when you can not guarantee that `Ember.EXTEND_PROTOTYPES`&#xA;will be `true`.&#xA;  &#xA;Example&#xA;  &#xA;```js&#xA;var Pagination = Ember.CollectionView.extend({&#xA;  tagName: &apos;ul&apos;,&#xA;  classNames: [&apos;pagination&apos;],&#xA;  &#xA;  init: function() {&#xA;    this._super(...arguments);&#xA;    if (!this.get(&apos;content&apos;)) {&#xA;      this.set(&apos;content&apos;, Ember.A());&#xA;    }&#xA;  }&#xA;});&#xA;```" ilk="function" name="A" returns="Ember.NativeArray" signature="A() =&gt; Ember.NativeArray" />
        <scope attributes="public" doc="Returns true if the passed object is an array or Array-like.&#xA;  &#xA;Objects are considered Array-like if any of the following are true:&#xA;  &#xA;  - the object is a native Array&#xA;  - the object has an objectAt property&#xA;  - the object is an Object, and has a length property&#xA;  &#xA;Unlike `Ember.typeOf` this method returns true even if the passed object is&#xA;not formally an array but appears to be array-like (i.e. implements `Ember.Array`)&#xA;  &#xA;```javascript&#xA;Ember.isArray();                                          // false&#xA;Ember.isArray([]);                                        // true&#xA;Ember.isArray(Ember.ArrayProxy.create({ content: [] }));  // true&#xA;```" ilk="function" name="isArray" returns="Boolean" signature="isArray(obj) =&gt; Boolean">
          <variable citdl="Object" doc="The object to test" ilk="argument" name="obj" />
        </scope>
        <scope attributes="public" doc="Returns a consistent type for the passed object.&#xA;  &#xA;Use this instead of the built-in `typeof` to get the type of an item.&#xA;It will return the same result across all browsers and includes a bit&#xA;more detail. Here is what will be returned:&#xA;  &#xA;    | Return Value  | Meaning                                              |&#xA;    |---------------|------------------------------------------------------|&#xA;    | &apos;string&apos;      | String primitive or String object.                   |&#xA;    | &apos;number&apos;      | Number primitive or Number object.                   |&#xA;    | &apos;boolean&apos;     | Boolean primitive or Boolean object.                 |&#xA;    | &apos;null&apos;        | Null value                                           |&#xA;    | &apos;undefined&apos;   | Undefined value                                      |&#xA;    | &apos;function&apos;    | A function                                           |&#xA;    | &apos;array&apos;       | An instance of Array                                 |&#xA;    | &apos;regexp&apos;      | An instance of RegExp                                |&#xA;    | &apos;date&apos;        | An instance of Date                                  |&#xA;    | &apos;class&apos;       | An Ember class (created using Ember.Object.extend()) |&#xA;    | &apos;instance&apos;    | An Ember object instance                             |&#xA;    | &apos;error&apos;       | An instance of the Error object                      |&#xA;    | &apos;object&apos;      | A JavaScript object not inheriting from Ember.Object |&#xA;  &#xA;Examples:&#xA;  &#xA;```javascript&#xA;Ember.typeOf();                       // &apos;undefined&apos;&#xA;Ember.typeOf(null);                   // &apos;null&apos;&#xA;Ember.typeOf(undefined);              // &apos;undefined&apos;&#xA;Ember.typeOf(&apos;michael&apos;);              // &apos;string&apos;&#xA;Ember.typeOf(new String(&apos;michael&apos;));  // &apos;string&apos;&#xA;Ember.typeOf(101);                    // &apos;number&apos;&#xA;Ember.typeOf(new Number(101));        // &apos;number&apos;&#xA;Ember.typeOf(true);                   // &apos;boolean&apos;&#xA;Ember.typeOf(new Boolean(true));      // &apos;boolean&apos;&#xA;Ember.typeOf(Ember.makeArray);        // &apos;function&apos;&#xA;Ember.typeOf([1, 2, 90]);             // &apos;array&apos;&#xA;Ember.typeOf(/abc/);                  // &apos;regexp&apos;&#xA;Ember.typeOf(new Date());             // &apos;date&apos;&#xA;Ember.typeOf(Ember.Object.extend());  // &apos;class&apos;&#xA;Ember.typeOf(Ember.Object.create());  // &apos;instance&apos;&#xA;Ember.typeOf(new Error(&apos;teamocil&apos;));  // &apos;error&apos;&#xA;  &#xA;// &apos;normal&apos; JavaScript object&#xA;Ember.typeOf({ a: &apos;b&apos; });             // &apos;object&apos;&#xA;```" ilk="function" name="typeOf" returns="String" signature="typeOf(item) =&gt; String">
          <variable citdl="Object" doc="the item to check" ilk="argument" name="item" />
        </scope>
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
        <scope attributes="public" doc="Alias for jQuery" ilk="function" name="$" signature="$()" />
      </scope>
      <scope ilk="class" name="Function">
        <scope attributes="public" doc="The `property` extension of Javascript&apos;s Function prototype is available&#xA;when `Ember.EXTEND_PROTOTYPES` or `Ember.EXTEND_PROTOTYPES.Function` is&#xA;`true`, which is the default.&#xA; Computed properties allow you to treat a function like a property:&#xA; ```javascript&#xA;MyApp.President = Ember.Object.extend({&#xA;  firstName: &apos;&apos;,&#xA;  lastName:  &apos;&apos;,&#xA;   fullName: function() {&#xA;    return this.get(&apos;firstName&apos;) + &apos; &apos; + this.get(&apos;lastName&apos;);&#xA;  }.property() // Call this flag to mark the function as a property&#xA;});&#xA; var president = MyApp.President.create({&#xA;  firstName: &apos;Barack&apos;,&#xA;  lastName: &apos;Obama&apos;&#xA;});&#xA; president.get(&apos;fullName&apos;); // &apos;Barack Obama&apos;&#xA;```&#xA; Treating a function like a property is useful because they can work with&#xA;bindings, just like any other property.&#xA; Many computed properties have dependencies on other properties. For&#xA;example, in the above example, the `fullName` property depends on&#xA;`firstName` and `lastName` to determine its value. You can tell Ember&#xA;about these dependencies like this:&#xA; ```javascript&#xA;MyApp.President = Ember.Object.extend({&#xA;  firstName: &apos;&apos;,&#xA;  lastName:  &apos;&apos;,&#xA;   fullName: function() {&#xA;    return this.get(&apos;firstName&apos;) + &apos; &apos; + this.get(&apos;lastName&apos;);&#xA;     // Tell Ember.js that this computed property depends on firstName&#xA;    // and lastName&#xA;  }.property(&apos;firstName&apos;, &apos;lastName&apos;)&#xA;});&#xA;```&#xA; Make sure you list these dependencies so Ember knows when to update&#xA;bindings that connect to a computed property. Changing a dependency&#xA;will not immediately trigger an update of the computed property, but&#xA;will instead clear the cache so that it is updated when the next `get`&#xA;is called on the property.&#xA; See [Ember.ComputedProperty](/api/classes/Ember.ComputedProperty.html), [Ember.computed](/api/#method_computed)." ilk="function" name="property" signature="property()" />
        <scope attributes="public" doc="The `observes` extension of Javascript&apos;s Function prototype is available&#xA;when `Ember.EXTEND_PROTOTYPES` or `Ember.EXTEND_PROTOTYPES.Function` is&#xA;true, which is the default.&#xA; You can observe property changes simply by adding the `observes`&#xA;call to the end of your method declarations in classes that you write.&#xA;For example:&#xA; ```javascript&#xA;Ember.Object.extend({&#xA;  valueObserver: function() {&#xA;    // Executes whenever the &quot;value&quot; property changes&#xA;  }.observes(&apos;value&apos;)&#xA;});&#xA;```&#xA; In the future this method may become asynchronous.&#xA; See `Ember.observer`." ilk="function" name="observes" signature="observes()" />
        <scope attributes="private" doc="The `observesImmediately` extension of Javascript&apos;s Function prototype is&#xA;available when `Ember.EXTEND_PROTOTYPES` or&#xA;`Ember.EXTEND_PROTOTYPES.Function` is true, which is the default.&#xA; You can observe property changes simply by adding the `observesImmediately`&#xA;call to the end of your method declarations in classes that you write.&#xA;For example:&#xA; ```javascript&#xA;Ember.Object.extend({&#xA;  valueObserver: function() {&#xA;    // Executes immediately after the &quot;value&quot; property changes&#xA;  }.observesImmediately(&apos;value&apos;)&#xA;});&#xA;```&#xA; In the future, `observes` may become asynchronous. In this event,&#xA;`observesImmediately` will maintain the synchronous behavior.&#xA; See `Ember.immediateObserver`." ilk="function" name="observesImmediately" signature="observesImmediately()" />
        <scope attributes="public" doc="The `on` extension of Javascript&apos;s Function prototype is available&#xA;when `Ember.EXTEND_PROTOTYPES` or `Ember.EXTEND_PROTOTYPES.Function` is&#xA;true, which is the default.&#xA; You can listen for events simply by adding the `on` call to the end of&#xA;your method declarations in classes or mixins that you write. For example:&#xA; ```javascript&#xA;Ember.Mixin.create({&#xA;  doSomethingWithElement: function() {&#xA;    // Executes whenever the &quot;didInsertElement&quot; event fires&#xA;  }.on(&apos;didInsertElement&apos;)&#xA;});&#xA;```&#xA; See `Ember.on`." ilk="function" name="on" signature="on()" />
      </scope>
      <scope doc="Helper class that allows you to register your library with Ember.&#xA;  &#xA;Singleton created at `Ember.libraries`." ilk="class" name="Libraries" />
      <scope ilk="namespace" name="RSVP">
        <scope ilk="class" name="EventTarget">
          <scope attributes="private" doc="Registers a callback to be executed when `eventName` is triggered&#xA; ```javascript&#xA;object.on(&apos;event&apos;, function(eventInfo){&#xA;  // handle the event&#xA;});&#xA; object.trigger(&apos;event&apos;);&#xA;```" ilk="function" name="on" signature="on(eventName,callback)">
            <variable citdl="String" doc="name of the event to listen for" ilk="argument" name="eventName" />
            <variable citdl="Function" doc="function to be called when the event is triggered." ilk="argument" name="callback" />
          </scope>
          <scope attributes="private" doc="You can use `off` to stop firing a particular callback for an event:&#xA; ```javascript&#xA;function doStuff() { // do stuff! }&#xA;object.on(&apos;stuff&apos;, doStuff);&#xA; object.trigger(&apos;stuff&apos;); // doStuff will be called&#xA; // Unregister ONLY the doStuff callback&#xA;object.off(&apos;stuff&apos;, doStuff);&#xA;object.trigger(&apos;stuff&apos;); // doStuff will NOT be called&#xA;```&#xA; If you don&apos;t pass a `callback` argument to `off`, ALL callbacks for the&#xA;event will not be executed when the event fires. For example:&#xA; ```javascript&#xA;var callback1 = function(){};&#xA;var callback2 = function(){};&#xA; object.on(&apos;stuff&apos;, callback1);&#xA;object.on(&apos;stuff&apos;, callback2);&#xA; object.trigger(&apos;stuff&apos;); // callback1 and callback2 will be executed.&#xA; object.off(&apos;stuff&apos;);&#xA;object.trigger(&apos;stuff&apos;); // callback1 and callback2 will not be executed!&#xA;```" ilk="function" name="off" signature="off(eventName,callback)">
            <variable citdl="String" doc="event to stop listening to" ilk="argument" name="eventName" />
            <variable citdl="Function" doc="optional argument. If given, only the function&#xA;given will be removed from the event&apos;s callback queue. If no `callback`&#xA;argument is given, all callbacks will be removed from the event&apos;s callback&#xA;queue." ilk="argument" name="callback" />
          </scope>
          <scope attributes="private" doc="Use `trigger` to fire custom events. For example:&#xA; ```javascript&#xA;object.on(&apos;foo&apos;, function(){&#xA;  console.log(&apos;foo event happened!&apos;);&#xA;});&#xA;object.trigger(&apos;foo&apos;);&#xA;// &apos;foo event happened!&apos; logged to the console&#xA;```&#xA; You can also pass a value as a second argument to `trigger` that will be&#xA;passed as an argument to all event listeners for the event:&#xA; ```javascript&#xA;object.on(&apos;foo&apos;, function(value){&#xA;  console.log(value.name);&#xA;});&#xA; object.trigger(&apos;foo&apos;, { name: &apos;bar&apos; });&#xA;// &apos;bar&apos; logged to the console&#xA;```" ilk="function" name="trigger" signature="trigger(eventName,options)">
            <variable citdl="String" doc="name of the event to be triggered" ilk="argument" name="eventName" />
            <variable citdl="*" doc="optional value to be passed to any event handlers for&#xA;the given `eventName`" ilk="argument" name="options" />
          </scope>
        </scope>
      </scope>
      <scope doc="A registry used to store factory and option information keyed&#xA;by type.&#xA;  &#xA;A `Registry` stores the factory and option information needed by a&#xA;`Container` to instantiate and cache objects.&#xA;  &#xA;The API for `Registry` is still in flux and should not be considered stable." ilk="class" name="Registry">
        <variable attributes="property private" citdl="Registry" doc="A backup registry for resolving registrations when no matches can be found." name="Registry" />
        <variable attributes="property private" citdl="Resolver" doc="An object that has a `resolve` method that resolves a name." name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <variable attributes="property private" citdl="InheritingDict" name="Registry" />
        <scope attributes="private" doc="Creates a container based on this registry." ilk="function" name="container" returns="Container" signature="container(options) =&gt; Container">
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="Registers a factory for later injection.&#xA; Example:&#xA; ```javascript&#xA;var registry = new Registry();&#xA; registry.register(&apos;model:user&apos;, Person, {singleton: false });&#xA;registry.register(&apos;fruit:favorite&apos;, Orange);&#xA;registry.register(&apos;communication:main&apos;, Email, {singleton: false});&#xA;```" ilk="function" name="register" signature="register(fullName,factory,options)">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Function" ilk="argument" name="factory" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="Unregister a fullName&#xA; ```javascript&#xA;var registry = new Registry();&#xA;registry.register(&apos;model:user&apos;, User);&#xA; registry.resolve(&apos;model:user&apos;).create() instanceof User //=&gt; true&#xA; registry.unregister(&apos;model:user&apos;)&#xA;registry.resolve(&apos;model:user&apos;) === undefined //=&gt; true&#xA;```" ilk="function" name="unregister" signature="unregister(fullName)">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="Given a fullName return the corresponding factory.&#xA; By default `resolve` will retrieve the factory from&#xA;the registry.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;registry.register(&apos;api:twitter&apos;, Twitter);&#xA; registry.resolve(&apos;api:twitter&apos;) // =&gt; Twitter&#xA;```&#xA; Optionally the registry can be provided with a custom resolver.&#xA;If provided, `resolve` will first provide the custom resolver&#xA;the opportunity to resolve the fullName, otherwise it will fallback&#xA;to the registry.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;registry.resolver = function(fullName) {&#xA;   // lookup via the module system of choice&#xA; };&#xA; // the twitter factory is added to the module system&#xA;registry.resolve(&apos;api:twitter&apos;) // =&gt; Twitter&#xA;```" ilk="function" name="resolve" returns="Function" signature="resolve(fullName,options) =&gt; Function">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="A hook that can be used to describe how the resolver will&#xA;attempt to find the factory.&#xA; For example, the default Ember `.describe` returns the full&#xA;class name (including namespace) where Ember&apos;s resolver expects&#xA;to find the `fullName`." ilk="function" name="describe" returns="String" signature="describe(fullName) =&gt; String">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="A hook to enable custom fullName normalization behaviour" ilk="function" name="normalizeFullName" returns="String" signature="normalizeFullName(fullName) =&gt; String">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="Normalize a fullName based on the application&apos;s conventions" ilk="function" name="normalize" returns="String" signature="normalize(fullName) =&gt; String">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" ilk="function" name="makeToString" returns="Function" signature="makeToString(factory,fullName) =&gt; Function">
          <variable citdl="Any" ilk="argument" name="factory" />
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="Given a fullName check if the container is aware of its factory&#xA;or singleton instance." ilk="function" name="has" returns="Boolean" signature="has(fullName,options) =&gt; Boolean">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="Allow registering options for all factories of a type.&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; // if all of type `connection` must not be singletons&#xA;registry.optionsForType(&apos;connection&apos;, { singleton: false });&#xA; registry.register(&apos;connection:twitter&apos;, TwitterConnection);&#xA;registry.register(&apos;connection:facebook&apos;, FacebookConnection);&#xA; var twitter = container.lookup(&apos;connection:twitter&apos;);&#xA;var twitter2 = container.lookup(&apos;connection:twitter&apos;);&#xA; twitter === twitter2; // =&gt; false&#xA; var facebook = container.lookup(&apos;connection:facebook&apos;);&#xA;var facebook2 = container.lookup(&apos;connection:facebook&apos;);&#xA; facebook === facebook2; // =&gt; false&#xA;```" ilk="function" name="optionsForType" signature="optionsForType(type,options)">
          <variable citdl="String" ilk="argument" name="type" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" ilk="function" name="options" signature="options(fullName,options)">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="private" doc="Used only via `injection`.&#xA; Provides a specialized form of injection, specifically enabling&#xA;all objects of one type to be injected with a reference to another&#xA;object.&#xA; For example, provided each object of type `controller` needed a `router`.&#xA;one would do the following:&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;router:main&apos;, Router);&#xA;registry.register(&apos;controller:user&apos;, UserController);&#xA;registry.register(&apos;controller:post&apos;, PostController);&#xA; registry.typeInjection(&apos;controller&apos;, &apos;router&apos;, &apos;router:main&apos;);&#xA; var user = container.lookup(&apos;controller:user&apos;);&#xA;var post = container.lookup(&apos;controller:post&apos;);&#xA; user.router instanceof Router; //=&gt; true&#xA;post.router instanceof Router; //=&gt; true&#xA; // both controllers share the same router&#xA;user.router === post.router; //=&gt; true&#xA;```" ilk="function" name="typeInjection" signature="typeInjection(type,property,fullName)">
          <variable citdl="String" ilk="argument" name="type" />
          <variable citdl="String" ilk="argument" name="property" />
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="Defines injection rules.&#xA; These rules are used to inject dependencies onto objects when they&#xA;are instantiated.&#xA; Two forms of injections are possible:&#xA; * Injecting one fullName on another fullName&#xA;* Injecting one fullName on a type&#xA; Example:&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;source:main&apos;, Source);&#xA;registry.register(&apos;model:user&apos;, User);&#xA;registry.register(&apos;model:post&apos;, Post);&#xA; // injecting one fullName on another fullName&#xA;// eg. each user model gets a post model&#xA;registry.injection(&apos;model:user&apos;, &apos;post&apos;, &apos;model:post&apos;);&#xA; // injecting one fullName on another type&#xA;registry.injection(&apos;model&apos;, &apos;source&apos;, &apos;source:main&apos;);&#xA; var user = container.lookup(&apos;model:user&apos;);&#xA;var post = container.lookup(&apos;model:post&apos;);&#xA; user.source instanceof Source; //=&gt; true&#xA;post.source instanceof Source; //=&gt; true&#xA; user.post instanceof Post; //=&gt; true&#xA; // and both models share the same source&#xA;user.source === post.source; //=&gt; true&#xA;```" ilk="function" name="injection" signature="injection(factoryName,property,injectionName)">
          <variable citdl="String" ilk="argument" name="factoryName" />
          <variable citdl="String" ilk="argument" name="property" />
          <variable citdl="String" ilk="argument" name="injectionName" />
        </scope>
        <scope attributes="private" doc="Used only via `factoryInjection`.&#xA; Provides a specialized form of injection, specifically enabling&#xA;all factory of one type to be injected with a reference to another&#xA;object.&#xA; For example, provided each factory of type `model` needed a `store`.&#xA;one would do the following:&#xA; ```javascript&#xA;var registry = new Registry();&#xA; registry.register(&apos;store:main&apos;, SomeStore);&#xA; registry.factoryTypeInjection(&apos;model&apos;, &apos;store&apos;, &apos;store:main&apos;);&#xA; var store = registry.lookup(&apos;store:main&apos;);&#xA;var UserFactory = registry.lookupFactory(&apos;model:user&apos;);&#xA; UserFactory.store instanceof SomeStore; //=&gt; true&#xA;```" ilk="function" name="factoryTypeInjection" signature="factoryTypeInjection(type,property,fullName)">
          <variable citdl="String" ilk="argument" name="type" />
          <variable citdl="String" ilk="argument" name="property" />
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="private" doc="Defines factory injection rules.&#xA; Similar to regular injection rules, but are run against factories, via&#xA;`Registry#lookupFactory`.&#xA; These rules are used to inject objects onto factories when they&#xA;are looked up.&#xA; Two forms of injections are possible:&#xA; * Injecting one fullName on another fullName&#xA;* Injecting one fullName on a type&#xA; Example:&#xA; ```javascript&#xA;var registry = new Registry();&#xA;var container = registry.container();&#xA; registry.register(&apos;store:main&apos;, Store);&#xA;registry.register(&apos;store:secondary&apos;, OtherStore);&#xA;registry.register(&apos;model:user&apos;, User);&#xA;registry.register(&apos;model:post&apos;, Post);&#xA; // injecting one fullName on another type&#xA;registry.factoryInjection(&apos;model&apos;, &apos;store&apos;, &apos;store:main&apos;);&#xA; // injecting one fullName on another fullName&#xA;registry.factoryInjection(&apos;model:post&apos;, &apos;secondaryStore&apos;, &apos;store:secondary&apos;);&#xA; var UserFactory = container.lookupFactory(&apos;model:user&apos;);&#xA;var PostFactory = container.lookupFactory(&apos;model:post&apos;);&#xA;var store = container.lookup(&apos;store:main&apos;);&#xA; UserFactory.store instanceof Store; //=&gt; true&#xA;UserFactory.secondaryStore instanceof OtherStore; //=&gt; false&#xA; PostFactory.store instanceof Store; //=&gt; true&#xA;PostFactory.secondaryStore instanceof OtherStore; //=&gt; true&#xA; // and both models share the same source instance&#xA;UserFactory.store === PostFactory.store; //=&gt; true&#xA;```" ilk="function" name="factoryInjection" signature="factoryInjection(factoryName,property,injectionName)">
          <variable citdl="String" ilk="argument" name="factoryName" />
          <variable citdl="String" ilk="argument" name="property" />
          <variable citdl="String" ilk="argument" name="injectionName" />
        </scope>
        <scope attributes="private" ilk="function" name="knownForType" signature="knownForType(type)">
          <variable citdl="String" doc="the type to iterate over" ilk="argument" name="type" />
        </scope>
        <scope attributes="private" doc="Given a fullName and a source fullName returns the fully resolved&#xA;fullName. Used to allow for local lookup.&#xA; ```javascript&#xA;var registry = new Registry();&#xA; // the twitter factory is added to the module system&#xA;registry.expandLocalLookup(&apos;component:post-title&apos;, { source: &apos;template:post&apos; }) // =&gt; component:post/post-title&#xA;```" ilk="function" name="expandLocalLookup" returns="String" signature="expandLocalLookup(fullName,options) =&gt; String">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
      </scope>
      <scope doc="RegistryProxyMixin is used to provide public access to specific&#xA;registry functionality." ilk="class" name="RegistryProxyMixin">
        <scope attributes="public" doc="Given a fullName return the corresponding factory." ilk="function" name="resolveRegistration" returns="Function" signature="resolveRegistration(fullName) =&gt; Function">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="public" doc="Registers a factory that can be used for dependency injection (with&#xA;`inject`) or for service lookup. Each factory is registered with&#xA;a full name including two parts: `type:name`.&#xA; A simple example:&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA; App.Orange = Ember.Object.extend();&#xA;App.register(&apos;fruit:favorite&apos;, App.Orange);&#xA;```&#xA; Ember will resolve factories from the `App` namespace automatically.&#xA;For example `App.CarsController` will be discovered and returned if&#xA;an application requests `controller:cars`.&#xA; An example of registering a controller with a non-standard name:&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA;var Session = Ember.Controller.extend();&#xA; App.register(&apos;controller:session&apos;, Session);&#xA; // The Session controller can now be treated like a normal controller,&#xA;// despite its non-standard name.&#xA;App.ApplicationController = Ember.Controller.extend({&#xA;  needs: [&apos;session&apos;]&#xA;});&#xA;```&#xA; Registered factories are **instantiated** by having `create`&#xA;called on them. Additionally they are **singletons**, each time&#xA;they are looked up they return the same instance.&#xA; Some examples modifying that default behavior:&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA; App.Person = Ember.Object.extend();&#xA;App.Orange = Ember.Object.extend();&#xA;App.Email = Ember.Object.extend();&#xA;App.session = Ember.Object.create();&#xA; App.register(&apos;model:user&apos;, App.Person, { singleton: false });&#xA;App.register(&apos;fruit:favorite&apos;, App.Orange);&#xA;App.register(&apos;communication:main&apos;, App.Email, { singleton: false });&#xA;App.register(&apos;session&apos;, App.session, { instantiate: false });&#xA;```" ilk="function" name="register" signature="register(fullName,factory,options)">
          <variable citdl="String" doc="type:name (e.g., &apos;model:user&apos;)" ilk="argument" name="fullName" />
          <variable citdl="Function" doc="(e.g., App.Person)" ilk="argument" name="factory" />
          <variable citdl="Object" doc="(optional) disable instantiation or singleton usage" ilk="argument" name="options" />
        </scope>
        <scope attributes="public" doc="Unregister a factory.&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA;var User = Ember.Object.extend();&#xA;App.register(&apos;model:user&apos;, User);&#xA; App.resolveRegistration(&apos;model:user&apos;).create() instanceof User //=&gt; true&#xA; App.unregister(&apos;model:user&apos;)&#xA;App.resolveRegistration(&apos;model:user&apos;) === undefined //=&gt; true&#xA;```" ilk="function" name="unregister" signature="unregister(fullName)">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="public" doc="Check if a factory is registered." ilk="function" name="hasRegistration" returns="Boolean" signature="hasRegistration(fullName) =&gt; Boolean">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="public" doc="Register an option for a particular factory." ilk="function" name="registerOption" signature="registerOption(fullName,optionName,options)">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="String" ilk="argument" name="optionName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="public" doc="Return a specific registered option for a particular factory." ilk="function" name="registeredOption" returns="Object" signature="registeredOption(fullName,optionName) =&gt; Object">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="String" ilk="argument" name="optionName" />
        </scope>
        <scope attributes="public" doc="Register options for a particular factory." ilk="function" name="registerOptions" signature="registerOptions(fullName,options)">
          <variable citdl="String" ilk="argument" name="fullName" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="public" doc="Return registered options for a particular factory." ilk="function" name="registeredOptions" returns="Object" signature="registeredOptions(fullName) =&gt; Object">
          <variable citdl="String" ilk="argument" name="fullName" />
        </scope>
        <scope attributes="public" doc="Allow registering options for all factories of a type.&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA;var appInstance = App.buildInstance();&#xA; // if all of type `connection` must not be singletons&#xA;appInstance.optionsForType(&apos;connection&apos;, { singleton: false });&#xA; appInstance.register(&apos;connection:twitter&apos;, TwitterConnection);&#xA;appInstance.register(&apos;connection:facebook&apos;, FacebookConnection);&#xA; var twitter = appInstance.lookup(&apos;connection:twitter&apos;);&#xA;var twitter2 = appInstance.lookup(&apos;connection:twitter&apos;);&#xA; twitter === twitter2; // =&gt; false&#xA; var facebook = appInstance.lookup(&apos;connection:facebook&apos;);&#xA;var facebook2 = appInstance.lookup(&apos;connection:facebook&apos;);&#xA; facebook === facebook2; // =&gt; false&#xA;```" ilk="function" name="registerOptionsForType" signature="registerOptionsForType(type,options)">
          <variable citdl="String" ilk="argument" name="type" />
          <variable citdl="Object" ilk="argument" name="options" />
        </scope>
        <scope attributes="public" doc="Return the registered options for all factories of a type." ilk="function" name="registeredOptionsForType" returns="Object" signature="registeredOptionsForType(type) =&gt; Object">
          <variable citdl="String" ilk="argument" name="type" />
        </scope>
        <scope attributes="public" doc="Define a dependency injection onto a specific factory or all factories&#xA;of a type.&#xA; When Ember instantiates a controller, view, or other framework component&#xA;it can attach a dependency to that component. This is often used to&#xA;provide services to a set of framework components.&#xA; An example of providing a session object to all controllers:&#xA; ```javascript&#xA;var App = Ember.Application.create();&#xA;var Session = Ember.Object.extend({ isAuthenticated: false });&#xA; // A factory must be registered before it can be injected&#xA;App.register(&apos;session:main&apos;, Session);&#xA; // Inject &apos;session:main&apos; onto all factories of the type &apos;controller&apos;&#xA;// with the name &apos;session&apos;&#xA;App.inject(&apos;controller&apos;, &apos;session&apos;, &apos;session:main&apos;);&#xA; App.IndexController = Ember.Controller.extend({&#xA;  isLoggedIn: Ember.computed.alias(&apos;session.isAuthenticated&apos;)&#xA;});&#xA;```&#xA; Injections can also be performed on specific factories.&#xA; ```javascript&#xA;App.inject(&lt;full_name or type&gt;, &lt;property name&gt;, &lt;full_name&gt;)&#xA;App.inject(&apos;route&apos;, &apos;source&apos;, &apos;source:main&apos;)&#xA;App.inject(&apos;route:application&apos;, &apos;email&apos;, &apos;model:email&apos;)&#xA;```&#xA; It is important to note that injections can only be performed on&#xA;classes that are instantiated by Ember itself. Instantiating a class&#xA;directly (via `create` or `new`) bypasses the dependency injection&#xA;system.&#xA; **Note:** Ember-Data instantiates its models in a unique manner, and consequently&#xA;injections onto models (or all models) will not work as expected. Injections&#xA;on models can be enabled by setting `Ember.MODEL_FACTORY_INJECTIONS`&#xA;to `true`." ilk="function" name="inject" signature="inject(factoryNameOrType,property,injectionName)">
          <variable citdl="String" ilk="argument" name="factoryNameOrType" />
          <variable citdl="String" ilk="argument" name="property" />
          <variable citdl="String" ilk="argument" name="injectionName" />
        </scope>
      </scope>
      <scope doc="The Routing service is used by LinkComponent, and provides facilities for&#xA;the component/view layer to interact with the router.&#xA;  &#xA;While still private, this service can eventually be opened up, and provides&#xA;the set of API needed for components to control routing without interacting&#xA;with router internals." ilk="class" name="RoutingService" />
      <scope ilk="class" name="String">
        <scope attributes="private" doc="See [Ember.String.fmt](/api/classes/Ember.String.html#method_fmt)." ilk="function" name="fmt" signature="fmt()" />
        <scope attributes="private" doc="See [Ember.String.w](/api/classes/Ember.String.html#method_w)." ilk="function" name="w" signature="w()" />
        <scope attributes="private" doc="See [Ember.String.loc](/api/classes/Ember.String.html#method_loc)." ilk="function" name="loc" signature="loc()" />
        <scope attributes="private" doc="See [Ember.String.camelize](/api/classes/Ember.String.html#method_camelize)." ilk="function" name="camelize" signature="camelize()" />
        <scope attributes="private" doc="See [Ember.String.decamelize](/api/classes/Ember.String.html#method_decamelize)." ilk="function" name="decamelize" signature="decamelize()" />
        <scope attributes="private" doc="See [Ember.String.dasherize](/api/classes/Ember.String.html#method_dasherize)." ilk="function" name="dasherize" signature="dasherize()" />
        <scope attributes="private" doc="See [Ember.String.underscore](/api/classes/Ember.String.html#method_underscore)." ilk="function" name="underscore" signature="underscore()" />
        <scope attributes="private" doc="See [Ember.String.classify](/api/classes/Ember.String.html#method_classify)." ilk="function" name="classify" signature="classify()" />
        <scope attributes="private" doc="See [Ember.String.capitalize](/api/classes/Ember.String.html#method_capitalize)." ilk="function" name="capitalize" signature="capitalize()" />
      </scope>
      <scope doc="An HTMLBars AST transformation that replaces all instances of&#xA;  &#xA;```handlebars&#xA;{{#each item in items}}&#xA;{{/each}}&#xA;```&#xA;  &#xA;with&#xA;  &#xA;```handlebars&#xA;{{#each items keyword=&quot;item&quot;}}&#xA;{{/each}}&#xA;```" ilk="class" name="TransformEachInToHash">
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
      </scope>
      <scope doc="An HTMLBars AST transformation that replaces all instances of&#xA;  &#xA;```handlebars&#xA;   {{input on=&quot;enter&quot; action=&quot;doStuff&quot;}}&#xA;   {{input on=&quot;key-press&quot; action=&quot;doStuff&quot;}}&#xA;```&#xA;  &#xA;with&#xA;  &#xA;```handlebars&#xA;   {{input enter=&quot;doStuff&quot;}}&#xA;   {{input key-press=&quot;doStuff&quot;}}&#xA;```" ilk="class" name="TransformInputOnToOnEvent">
        <scope attributes="private" ilk="function" name="transform" signature="transform(ast)">
          <variable citdl="AST" doc="The AST to be transformed." ilk="argument" name="ast" />
        </scope>
        <scope attributes="private" ilk="function" name="transform" signature="transform(The)">
          <variable citdl="AST" doc="AST to be transformed." ilk="argument" name="The" />
        </scope>
        <variable attributes="property private" name="TransformInputOnToOnEvent" />
        <scope attributes="private" doc="Adds an AST plugin to be used by Ember.HTMLBars.compile." ilk="function" name="registerASTPlugin" signature="registerASTPlugin()" />
        <scope attributes="private" doc="Uses HTMLBars `compile` function to process a string into a compiled template.&#xA;  &#xA;This is not present in production builds." ilk="function" name="compile" signature="compile(templateString,options)">
          <variable citdl="String" doc="This is the string to be compiled by HTMLBars." ilk="argument" name="templateString" />
          <variable citdl="Object" doc="This is an options hash to augment the compiler options." ilk="argument" name="options" />
        </scope>
        <variable attributes="property private" name="TransformInputOnToOnEvent" />
        <scope attributes="private" doc="Uses HTMLBars `compile` function to process a string into a compiled template string.&#xA;The returned string must be passed through `Ember.HTMLBars.template`.&#xA;  &#xA;This is not present in production builds." ilk="function" name="precompile" signature="precompile(templateString)">
          <variable citdl="String" doc="This is the string to be compiled by HTMLBars." ilk="argument" name="templateString" />
        </scope>
        <scope attributes="private" doc="Augments the default precompiled output of an HTMLBars template with&#xA;additional information needed by Ember." ilk="function" name="template" signature="template(templateSpec)">
          <variable citdl="Function" doc="This is the compiled HTMLBars template spec." ilk="argument" name="templateSpec" />
        </scope>
      </scope>
    </scope>
  </file>
</codeintel>
